# Runaway Heroes - Skeleton delle Classi
# Generato il: 03/05/2025 21:18:30
# Questo file contiene definizioni complete di classi, inclusi attributi, campi, proprietà, metodi ed eventi.

## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Authoring/ObstacleAuthoringComponents.cs

namespace RunawayHeroes.Authoring
{
     <summary>
    /// Base class per i componenti di authoring degli ostacoli.
    /// Fornisce funzionalità comuni per tutti i tipi di ostacoli.
    /// </summary>

    public abstract class BaseObstacleAuthoring : MonoBehaviour
    {
        public float height;
        public float width;
        public float collisionRadius;
        public float strength;
        public float damageValue;
        public bool isDestructible;
        public ObstaclePreset preset;
         <summary>
        /// Applica i valori predefiniti in base al preset selezionato
        /// </summary>

        public virtual void ApplyPreset();
    }
     <summary>
    /// Presets predefiniti per la configurazione rapida degli ostacoli
    /// </summary>

    public enum ObstaclePreset
    {
        Custom,
        Small,
        Medium,
        Large
    }
     <summary>
    /// Componente di authoring per ostacoli standard senza tag speciali
    /// </summary>

    public class StandardObstacleAuthoring : BaseObstacleAuthoring
    {
    }
     <summary>
    /// Baker per ostacoli standard
    /// </summary>

    public class StandardObstacleBaker : Baker<StandardObstacleAuthoring>
    {
        public override void Bake(StandardObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per ostacoli di lava (Ember può attraversarli con Corpo Ignifugo)
    /// </summary>

    public class LavaObstacleAuthoring : BaseObstacleAuthoring
    {
        public float damagePerSecond;
    }
     <summary>
    /// Baker per ostacoli di lava
    /// </summary>

    public class LavaObstacleBaker : Baker<LavaObstacleAuthoring>
    {
        public override void Bake(LavaObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per ostacoli di ghiaccio (Kai può scioglierli con Aura di Calore)
    /// </summary>

    public class IceObstacleAuthoring : BaseObstacleAuthoring
    {
        public float maxIntegrity;
    }
     <summary>
    /// Baker per ostacoli di ghiaccio
    /// </summary>

    public class IceObstacleBaker : Baker<IceObstacleAuthoring>
    {
        public override void Bake(IceObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per superfici scivolose (Kai con Aura di Calore è immune)
    /// </summary>

    public class SlipperyObstacleAuthoring : BaseObstacleAuthoring
    {
        public float slipFactor;
    }
     <summary>
    /// Baker per superfici scivolose
    /// </summary>

    public class SlipperyObstacleBaker : Baker<SlipperyObstacleAuthoring>
    {
        public override void Bake(SlipperyObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per barriere digitali (Neo può attraversarle con Glitch Controllato)
    /// </summary>

    public class DigitalBarrierAuthoring : BaseObstacleAuthoring
    {
        public override void ApplyPreset();
    }
     <summary>
    /// Baker per barriere digitali
    /// </summary>

    public class DigitalBarrierBaker : Baker<DigitalBarrierAuthoring>
    {
        public override void Bake(DigitalBarrierAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per zone subacquee (Marina è avvantaggiata con Bolla d'Aria)
    /// </summary>

    public class UnderwaterObstacleAuthoring : BaseObstacleAuthoring
    {
        public bool requiresOxygen;
        public float currentStrength;
        public Vector3 currentDirection;
    }
     <summary>
    /// Baker per zone subacquee
    /// </summary>

    public class UnderwaterObstacleBaker : Baker<UnderwaterObstacleAuthoring>
    {
        public override void Bake(UnderwaterObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per correnti d'aria (utilizzate in vari mondi)
    /// </summary>

    public class AirCurrentAuthoring : BaseObstacleAuthoring
    {
        public float currentStrength;
        public Vector3 currentDirection;
    }
     <summary>
    /// Baker per correnti d'aria
    /// </summary>

    public class AirCurrentBaker : Baker<AirCurrentAuthoring>
    {
        public override void Bake(AirCurrentAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per zone di gas tossico
    /// </summary>

    public class ToxicGasAuthoring : BaseObstacleAuthoring
    {
        public float damagePerSecond;
    }
     <summary>
    /// Baker per zone di gas tossico
    /// </summary>

    public class ToxicGasBaker : Baker<ToxicGasAuthoring>
    {
        public override void Bake(ToxicGasAuthoring authoring);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/TutorialScenarioEditor.cs



## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/TutorialSequenceEditor.cs

namespace RunawayHeroes.Editor
{
     <summary>
    /// Editor personalizzato per la configurazione della sequenza di tutorial
    /// </summary>

    public class TutorialSequenceEditor : UnityEditor.Editor
    {
        private bool _showTutorialSequence;
        private bool[] _showTutorialDetails;
        private bool _showScenarios;
        public override void OnInspectorGUI();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/TutorialTestHelper.cs

namespace RunawayHeroes.Editor
{
     <summary>
    /// Helper classe per testare il livello tutorial dall'editor
    /// </summary>

    public class TutorialTestHelper : EditorWindow
    {
        private TutorialLevelInitializer _tutorialInitializer;
        private bool _defaultSettings;
        private WorldTheme _selectedTheme;
        private int _tutorialLength;
        private int _seed;
        private Vector3 _playerStartPos;
        public static void ShowWindow();
        private void OnGUI();
         <summary>
        /// Crea un GameObject con l'inizializzatore del tutorial
        /// </summary>

        private void CreateTutorialManager();
         <summary>
        /// Genera un livello tutorial per il test
        /// </summary>

        private void GenerateTutorialLevel();
         <summary>
        /// Cancella il livello tutorial generato
        /// </summary>

        private void ClearTutorialLevel();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/ShopMenuController.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il menu del negozio che permette acquisti in-app
    /// e gestione del pass premium.
    /// </summary>

    public class ShopMenuController : MonoBehaviour
    {
        public string categoryName;
        public GameObject categoryPanel;
        public Button categoryButton;
        public string itemName;
        public string itemDescription;
        public Sprite itemIcon;
        public string itemId;
        public int price;
        public Button buyButton;
        public GameObject purchasedIndicator;
        [SerializeField] private List<ShopCategory> categories;
        [SerializeField] private List<ShopItem> items;
        [SerializeField] private Button premiumPassButton;
        [SerializeField] private TextMeshProUGUI premiumPassStatusText;
        [SerializeField] private GameObject premiumPassBenefitsPanel;
        [SerializeField] private TextMeshProUGUI coinsText;
        [SerializeField] private TextMeshProUGUI gemsText;
        [SerializeField] private Button backButton;
        [SerializeField] private Button addCoinsButton;
        [SerializeField] private Button addGemsButton;
        private GameObject currentCategoryPanel;
        private void Start();
        private void InitializeUI();
        private void InitializeCategories();
        private void InitializeShopItems();
        private void ShowCategory(int categoryIndex);
        private void PurchaseItem(ShopItem item);
        private void UpdatePremiumPassStatus();
        private void UpdateCurrencyDisplay();
        private bool IsItemPurchased(string itemId);
        private void OnBackButtonClicked();
        private void OnAddCoinsClicked();
        private void OnAddGemsClicked();
        private void OnPremiumPassClicked();
    }
    public class ShopCategory
    {
        public string categoryName;
        public GameObject categoryPanel;
        public Button categoryButton;
    }
    public class ShopItem
    {
        public string itemName;
        public string itemDescription;
        public Sprite itemIcon;
        public string itemId;
        public int price;
        public Button buyButton;
        public GameObject purchasedIndicator;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/TutorialMessagePanel.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il pannello dei messaggi di tutorial.
    /// Gestisce l'aspetto visivo e le animazioni del pannello.
    /// </summary>

    public class TutorialMessagePanel : MonoBehaviour
    {
        [SerializeField] private TextMeshProUGUI messageText;
        [SerializeField] private Image backgroundImage;
        [SerializeField] private Image iconImage;
        [SerializeField] private CanvasGroup canvasGroup;
        [SerializeField] private float fadeInTime;
        [SerializeField] private float fadeOutTime;
        [SerializeField] private AnimationCurve fadeCurve;
        [SerializeField] private Color tutorialColor;
        [SerializeField] private Color notificationColor;
        [SerializeField] private Color warningColor;
        [SerializeField] private Sprite[] typeIcons;
        private Animator _animator;
        private Coroutine _currentAnimation;
        private void Awake();
         <summary>
        /// Mostra il messaggio con il testo e il tipo specificati
        /// </summary>

        public void ShowMessage(string message, byte messageType);
         <summary>
        /// Nasconde il messaggio
        /// </summary>

        public void HideMessage();
         <summary>
        /// Animazione di fade in
        /// </summary>

        private IEnumerator FadeIn();
         <summary>
        /// Animazione di fade out
        /// </summary>

        private IEnumerator FadeOut();
         <summary>
        /// Disattiva il pannello dopo un ritardo
        /// </summary>

        private IEnumerator DisableAfterDelay(float delay);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/ArcadeMenuController.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il menu della modalità Arcade, che permette
    /// di rigiocare livelli già completati.
    /// </summary>

    public class ArcadeMenuController : MonoBehaviour
    {
        public string worldName;
        public Sprite worldIcon;
        public GameObject levelSelectionPanel;
        public List<LevelButton> levels;
        public string levelName;
        public string scenePath;
        public Button button;
        public Image completionStar;
        public TextMeshProUGUI highScoreText;
        [SerializeField] private List<WorldCategory> worlds;
        [SerializeField] private Transform worldButtonContainer;
        [SerializeField] private GameObject worldButtonPrefab;
        [SerializeField] private Button backButton;
        [SerializeField] private TextMeshProUGUI titleText;
        private GameObject currentPanel;
        private void Start();
        private void InitializeUI();
        private void InitializeWorldButtons();
        private void InitializeLevelButtons();
        private void ShowWorldSelection();
        private void OnWorldSelected(int worldIndex);
        private void OnLevelSelected(string scenePath);
        private void OnBackButtonClicked();
        private bool IsWorldUnlocked(int worldIndex);
        private bool IsLevelCompleted(string levelPath);
        private int GetLevelHighScore(string levelPath);
    }
    public class WorldCategory
    {
        public string worldName;
        public Sprite worldIcon;
        public GameObject levelSelectionPanel;
        public List<LevelButton> levels;
    }
    public class LevelButton
    {
        public string levelName;
        public string scenePath;
        public Button button;
        public Image completionStar;
        public TextMeshProUGUI highScoreText;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/MenuController.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il menu principale, gestisce le interazioni specifiche
    /// e le animazioni del menu.
    /// </summary>

    public class MenuController : MonoBehaviour
    {
        [SerializeField] private GameObject menuBackground;
        [SerializeField] private GameObject logoElement;
        [SerializeField] private Button[] menuButtons;
        [SerializeField] private TextMeshProUGUI versionText;
        [SerializeField] private string versionNumber;
        [SerializeField] private Animator menuAnimator;
        private GameObject currentCharacterDisplay;
        private int currentCharacterIndex;
        private void Start();
        private void InitializeMenu();
        private void Update();
         <summary>
        /// Gestisce il pulsante back
        /// </summary>

        private void HandleBackButton();
         <summary>
        /// Riproduce un suono di clic per i pulsanti
        /// </summary>

        public void PlayButtonClickSound();
        private void OnDestroy();
    }
     <summary>
    /// Utility class per gestire il pulsante back (Android/iOS)
    /// </summary>

    public static class BackButtonHandler
    {
        public static void InvokeBackButton();
        public static event BackButtonEvent OnBackButtonPressed;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/UITransitionManager.cs

namespace RunawayHeroes.Runtime.UI
{
    public class UITransitionManager : MonoBehaviour
    {
        [SerializeField] private Image transitionImage;
        [SerializeField] private float transitionDuration;
        private void Start();
        public void FadeIn(System.Action onComplete);
        public void FadeOut(System.Action onComplete);
        private IEnumerator FadeRoutine(float startAlpha, float endAlpha, float duration, System.Action onComplete);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/GameBootstrap.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// 
    /// </summary>

    public class GameBootstrap : MonoBehaviour
    {
        private void Start();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/TutorialLevelInitializer.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// Inizializzatore del livello tutorial che gestisce la creazione di scenari con
    /// ostacoli multipli per ogni scenario.
    /// </summary>

    public class TutorialLevelInitializer : MonoBehaviour
    {
        public string scenarioName;
        public ObstacleSetup[] obstacles;
        public float startPositionZ;
        public float endPositionZ;
        public ObstacleType type;
        public ObstaclePreset preset;
        public Vector3 position;
        public float rotation;
        public float damagePerSecond;
        public float maxIntegrity;
        public float slipFactor;
        public float currentStrength;
        public Vector3 currentDirection;
        public bool requiresOxygen;
        public float height;
        public float width;
        public float collisionRadius;
        public float strength;
        public float damageValue;
        public bool isDestructible;
        [SerializeField] private ScenarioSetup[] scenarios;
        [SerializeField] private bool showDebugGizmos;
        [SerializeField] private Color gizmoColor;
        private EntityManager _entityManager;
        private EntityArchetype _standardObstacleArchetype;
        private EntityArchetype _lavaObstacleArchetype;
        private EntityArchetype _iceObstacleArchetype;
        private EntityArchetype _slipperyObstacleArchetype;
        private EntityArchetype _digitalBarrierArchetype;
        private EntityArchetype _underwaterObstacleArchetype;
        private EntityArchetype _airCurrentArchetype;
        private EntityArchetype _toxicGasArchetype;
        private void Awake();
        private void Start();
        private void InitializeArchetypes();
        private void InitializeScenarios();
        private void InitializeScenario(ScenarioSetup scenario);
        private void CreateObstacle(ObstacleSetup setup);
        private void OnDrawGizmos();
    }
    public class ScenarioSetup
    {
        public string scenarioName;
        public ObstacleSetup[] obstacles;
        public float startPositionZ;
        public float endPositionZ;
    }
    public class ObstacleSetup
    {
        public ObstacleType type;
        public ObstaclePreset preset;
        public Vector3 position;
        public float rotation;
        public float damagePerSecond;
        public float maxIntegrity;
        public float slipFactor;
        public float currentStrength;
        public Vector3 currentDirection;
        public bool requiresOxygen;
        public float height;
        public float width;
        public float collisionRadius;
        public float strength;
        public float damageValue;
        public bool isDestructible;
    }
    public enum ObstacleType
    {
        Standard,
        Lava,
        Ice,
        Slippery,
        DigitalBarrier,
        Underwater,
        AirCurrent,
        ToxicGas
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/ECSBootstrap.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// Sistema di bootstrap per l'inizializzazione dell'Entity Component System.
    /// Questo componente crea e registra tutti i sistemi ECS necessari per il gioco.
    /// </summary>

    public class ECSBootstrap : MonoBehaviour
    {
        private World _world;
        private bool _initialized;
         <summary>
        /// Inizializza il sistema ECS all'avvio del gioco
        /// </summary>

        private void Start();
         <summary>
        /// Crea e registra tutti i sistemi ECS necessari
        /// </summary>

        private void InitializeECS();
         <summary>
        /// Aggiunge i sistemi in modo sicuro, evitando dipendenze circolari
        /// </summary>

        private void AddSystemsSafely(List<Type> systems, SimulationSystemGroup simulationSystemGroup);
        private void AddCoreSystems(List<Type> systems);
        private void AddInputSystems(List<Type> systems);
        private void AddMovementSystems(List<Type> systems);
        private void AddAbilitySystems(List<Type> systems);
        private void AddCombatSystems(List<Type> systems);
        private void AddAISystems(List<Type> systems);
        private void AddGameplaySystems(List<Type> systems);
        private void AddWorldSystems(List<Type> systems);
        private void AddUISystems(List<Type> systems);
        private void AddEventHandlers(List<Type> systems);
         <summary>
        /// Pulisce le risorse quando il componente viene distrutto
        /// </summary>

        private void OnDestroy();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/WorldBootstrap.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// 
    /// </summary>

    public class WorldBootstrap : MonoBehaviour
    {
        private void Start();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Boot/BootSequence.cs

namespace RunawayHeroes.Runtime.Boot
{
    public class BootSequence : MonoBehaviour
    {
        [SerializeField] private CanvasGroup fadeOverlay;
        [SerializeField] private Image logoImage;
        [SerializeField] private RectTransform logoTransform;
        [SerializeField] private Text versionText;
        [SerializeField] private float logoDelay;
        [SerializeField] private float totalDuration;
        [SerializeField] private float fadeInDuration;
        [SerializeField] private float fadeOutDuration;
        [SerializeField] private bool initializeECS;
        [SerializeField] private string nextSceneName;
        [SerializeField] private string versionNumber;
        private bool _isInitialized;
        private void Awake();
        private void Start();
        private IEnumerator DelayedBootStart();
        private IEnumerator BootSequenceCoroutine();
        private void InitializeECSSystem();
        private IEnumerator AnimateLogo();
        private IEnumerator FadeCanvasGroup(CanvasGroup group, float startAlpha, float targetAlpha, float duration);
        private float BounceEaseOut(float t);
        public void ForceCompleteSequence();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/UnityCameraBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Bridge che collega la Camera di Unity con il sistema ECS.
    /// Permette al sistema ECS di controllare o essere informato sulla camera.
    /// </summary>

    public class UnityCameraBridge : MonoBehaviour
    {
        [SerializeField] private float followSpeed;
        [SerializeField] private float smoothTime;
        [SerializeField] private float lookAheadDistance;
        [SerializeField] private Vector3 offset;
        private Camera _camera;
        private Entity _cameraEntity;
        private EntityManager _entityManager;
        public override void Bake(UnityCameraBridge authoring);
        private void Awake();
        private void Start();
        private void LateUpdate();
    }
    public class CameraBridgeBaker : Baker<UnityCameraBridge>
    {
        public override void Bake(UnityCameraBridge authoring);
    }
     <summary>
    /// Tag per identificare l'entità camera
    /// </summary>

    public struct CameraTag : IComponentData
    {
    }
     <summary>
    /// Componente che memorizza le impostazioni della camera
    /// </summary>

    public struct CameraSettingsComponent : IComponentData
    {
        public float FollowSpeed;
        public float SmoothTime;
        public float LookAheadDistance;
        public float3 Offset;
    }
     <summary>
    /// Componente che tiene traccia del target della camera
    /// </summary>

    public struct CameraTargetComponent : IComponentData
    {
        public Entity TargetEntity;
        public bool IsFollowing;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/UnityPhysicsBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Bridge che collega il sistema di fisica di Unity con il sistema ECS.
    /// Permette di sincronizzare collisioni e forze tra i due sistemi.
    /// </summary>

    public class UnityPhysicsBridge : MonoBehaviour
    {
        [SerializeField] private float gravity;
        [SerializeField] private float mass;
        [SerializeField] private float friction;
        [SerializeField] private bool useGravity;
        [SerializeField] private LayerMask groundLayers;
        private Rigidbody _rigidbody;
        private Entity _physicsEntity;
        private EntityManager _entityManager;
        private bool _isGrounded;
        public override void Bake(UnityPhysicsBridge authoring);
        private void Awake();
        private void Start();
        private void FixedUpdate();
        private void CheckGrounded();
        private void OnCollisionEnter(Collision collision);
    }
    public class PhysicsBridgeBaker : Baker<UnityPhysicsBridge>
    {
        public override void Bake(UnityPhysicsBridge authoring);
    }
     <summary>
    /// Tag per identificare l'entità fisica
    /// </summary>

    public struct PhysicsTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/InputBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Componente bridge che collega il sistema di input di Unity con l'ECS.
    /// Questo componente deve essere aggiunto a un GameObject nella scena
    /// e si occupa di convertire gli input in componenti ECS.
    /// </summary>

    public class InputBridge : MonoBehaviour
    {
        public float lateralSensitivity;
        public float focusTimeActivationDuration;
        public bool enableKeyboardControls;
        public bool enableTouchControls;
        private Touch? currentTouch;
        private float touchStartTime;
        private float lastLateralInput;
        private Entity _inputEntity;
        private EntityManager _entityManager;
        private EntityCommandBuffer _commandBuffer;
        public override void Bake(InputBridge authoring);
         <summary>
        /// Inizializza il bridge all'avvio
        /// </summary>

        private void Start();
         <summary>
        /// Aggiorna gli input ad ogni frame
        /// </summary>

        private void Update();
         <summary>
        /// Metodo chiamato quando il bridge viene abilitato
        /// </summary>

        private void OnEnable();
         <summary>
        /// Metodo chiamato quando il bridge viene disabilitato
        /// </summary>

        private void OnDisable();
         <summary>
        /// Implementazione di Unity per update visivi
        /// </summary>

        private void OnGUI();
        private void ProcessFocusTimeInput(Entity playerEntity);
        private void ProcessMovementInput(Entity playerEntity);
        private void ProcessJumpInput(Entity playerEntity);
        private void ProcessSlideInput(Entity playerEntity);
        private void ProcessAbilityInput(Entity playerEntity);
    }
    public class InputBridgeBaker : Baker<InputBridge>
    {
        public override void Bake(InputBridge authoring);
    }
     <summary>
    /// Componente tag per identificare l'entità InputBridge
    /// </summary>

    public struct InputBridgeTag : IComponentData
    {
    }
     <summary>
    /// Componente per memorizzare le impostazioni di input
    /// </summary>

    public struct InputSettingsComponent : IComponentData
    {
        public float LateralSensitivity;
        public float FocusTimeActivationDuration;
        public bool EnableKeyboardControls;
        public bool EnableTouchControls;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/PlayerBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Bridge che collega i GameObject del giocatore con il sistema ECS.
    /// Gestisce la conversione delle proprietà del giocatore in componenti ECS.
    /// </summary>

    public class PlayerBridge : MonoBehaviour
    {
        [SerializeField] private CharacterType characterType;
        [SerializeField] private float maxHealth;
        [SerializeField] private float movementSpeed;
        [SerializeField] private float jumpForce;
        public override void Bake(PlayerBridge authoring);
        private static WorldType GetWorldTypeFromCharacter(CharacterType characterType);
    }
    public class PlayerBridgeBaker : Baker<PlayerBridge>
    {
        public override void Bake(PlayerBridge authoring);
        private static WorldType GetWorldTypeFromCharacter(CharacterType characterType);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/LevelManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// 
    /// </summary>

    public class LevelManager : MonoBehaviour
    {
        public static LevelManager Instance { get; set; }
        private void Awake();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/AudioManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// Gestore centralizzato del sistema audio del gioco.
    /// Supporta effetti sonori, musica di sottofondo e transizioni audio.
    /// </summary>

    public class AudioManager : MonoBehaviour
    {
        public string name;
        public AudioClip clip;
        public float volume;
        public float pitch;
        public float spatialBlend;
        public bool loop;
        public AudioSource source;
        [SerializeField] private Sound[] sfxSounds;
        [SerializeField] private Sound[] musicSounds;
        [SerializeField] private AudioMixerGroup sfxMixerGroup;
        [SerializeField] private AudioMixerGroup musicMixerGroup;
        [SerializeField] private float masterVolume;
        [SerializeField] private float sfxVolume;
        [SerializeField] private float musicVolume;
        private Dictionary<string, Sound> _soundsDictionary;
        private string _currentMusic;
        public static AudioManager Instance { get; set; }
        private void Awake();
        private void InitializeSounds();
         <summary>
        /// Riproduce un effetto sonoro.
        /// </summary>
        /// <param name="soundName">Nome dell'effetto sonoro da riprodurre</param>

        public void PlaySound(string soundName);
         <summary>
        /// Riproduce un effetto sonoro una sola volta, anche se già in esecuzione.
        /// </summary>
        /// <param name="soundName">Nome dell'effetto sonoro da riprodurre</param>

        public void PlaySoundOneShot(string soundName);
         <summary>
        /// Riproduce un brano musicale con dissolvenza.
        /// </summary>
        /// <param name="musicName">Nome del brano musicale da riprodurre</param>
        /// <param name="fadeTime">Tempo di dissolvenza in secondi</param>

        public void PlayMusic(string musicName, float fadeTime);
         <summary>
        /// Interrompe un suono.
        /// </summary>
        /// <param name="soundName">Nome del suono da interrompere</param>

        public void StopSound(string soundName);
         <summary>
        /// Interrompe tutti i suoni.
        /// </summary>

        public void StopAllSounds();
         <summary>
        /// Mette in pausa tutti i suoni.
        /// </summary>

        public void PauseAllSounds();
         <summary>
        /// Riprende tutti i suoni in pausa.
        /// </summary>

        public void ResumeAllSounds();
         <summary>
        /// Imposta il volume master.
        /// </summary>
        /// <param name="volume">Volume da 0 a 1</param>

        public void SetMasterVolume(float volume);
         <summary>
        /// Imposta il volume degli effetti sonori.
        /// </summary>
        /// <param name="volume">Volume da 0 a 1</param>

        public void SetSFXVolume(float volume);
         <summary>
        /// Imposta il volume della musica.
        /// </summary>
        /// <param name="volume">Volume da 0 a 1</param>

        public void SetMusicVolume(float volume);
        private void UpdateAllVolumes();
        private void SaveVolumeSettings();
        private void LoadVolumeSettings();
        private System.Collections.IEnumerator FadeIn(AudioSource audioSource, float targetVolume, float duration);
        private System.Collections.IEnumerator FadeOut(AudioSource audioSource, float duration);
         <summary>
        /// Riproduce un effetto sonoro (alias per PlaySound).
        /// </summary>
        /// <param name="sfxName">Nome dell'effetto sonoro da riprodurre</param>

        public void PlaySFX(string sfxName);
    }
    public class Sound
    {
        public string name;
        public AudioClip clip;
        public float volume;
        public float pitch;
        public float spatialBlend;
        public bool loop;
        public AudioSource source;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/MainMenuManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// Manager specifico per il menu principale che estende la funzionalità
    /// del UIManager per gestire la navigazione tra livelli e altre interazioni
    /// specifiche del menu principale.
    /// </summary>

    public class MainMenuManager : MonoBehaviour
    {
        [SerializeField] private string mainMenuPanelName;
        [SerializeField] private string arcadeMenuPanelName;
        [SerializeField] private string shopMenuPanelName;
        [SerializeField] private string settingsPanelName;
        [SerializeField] private Button playButton;
        [SerializeField] private Button continueButton;
        [SerializeField] private Button arcadeButton;
        [SerializeField] private Button shopButton;
        [SerializeField] private Button settingsButton;
        [SerializeField] private UITransitionManager transitionManager;
        [SerializeField] private GameObject loadingPanel;
        [SerializeField] private float transitionTime;
        [SerializeField] private float uiManagerCheckDelay;
        private UIManager _uiManager;
        private bool _hasSaveGame;
        private bool _initialized;
        private void Start();
        private void TryInitialize();
        private IEnumerator RetryInitialization();
        private void InitializeUI();
         <summary>
        /// Carica una scena di gioco con effetto di transizione
        /// </summary>

        public void LoadGameScene(string sceneName);
        private System.Collections.IEnumerator LoadSceneAsync(string sceneName);
        private void OnPlayButtonClicked();
        private void OnContinueButtonClicked();
        private void OnArcadeButtonClicked();
        private void OnShopButtonClicked();
        private void OnSettingsButtonClicked();
        private System.Collections.IEnumerator LoadSceneCoroutine(string sceneName);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/UIManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// Gestore centralizzato del sistema UI del gioco.
    /// Controlla pannelli, schermate, transizioni e stati dell'interfaccia.
    /// </summary>

    public class UIManager : MonoBehaviour
    {
        public string name;
        public GameObject panel;
        public Animator animator;
        public bool activeAtStart;
        [SerializeField] private UIPanel[] panels;
        [SerializeField] private Animator transitionAnimator;
        [SerializeField] private float transitionTime;
        [SerializeField] private Button globalBackButton;
        [SerializeField] private GameObject loadingIndicator;
        private Dictionary<string, UIPanel> _panelsDictionary;
        private Stack<string> _panelHistory;
        private string _currentPanel;
        public static UIManager Instance { get; set; }
        private void Awake();
        private void InitializePanels();
         <summary>
        /// Apre un pannello UI specifico.
        /// </summary>
        /// <param name="panelName">Nome del pannello da aprire</param>
        /// <param name="addToHistory">Se true, il pannello corrente viene aggiunto alla cronologia</param>

        public void OpenPanel(string panelName, bool addToHistory);
         <summary>
        /// Torna al pannello precedente nella cronologia.
        /// </summary>

        public void BackToPreviousPanel();
         <summary>
        /// Chiude tutti i pannelli e apre il pannello specificato.
        /// </summary>
        /// <param name="panelName">Nome del pannello da aprire</param>

        public void SwitchToPanel(string panelName);
         <summary>
        /// Ritorna al menu principale resettando la cronologia.
        /// </summary>

        public void ReturnToMainMenu();
         <summary>
        /// Mostra l'indicatore di caricamento.
        /// </summary>
        /// <param name="show">True per mostrare, False per nascondere</param>

        public void ShowLoadingIndicator(bool show);
         <summary>
        /// Aggiorna un testo UI specifico.
        /// </summary>
        /// <param name="panelName">Nome del pannello contenente il testo</param>
        /// <param name="textName">Nome del componente di testo</param>
        /// <param name="value">Nuovo valore del testo</param>

        public void UpdateText(string panelName, string textName, string value);
         <summary>
        /// Aggiorna un'immagine UI specifica.
        /// </summary>
        /// <param name="panelName">Nome del pannello contenente l'immagine</param>
        /// <param name="imageName">Nome del componente di immagine</param>
        /// <param name="sprite">Nuovo sprite dell'immagine</param>

        public void UpdateImage(string panelName, string imageName, Sprite sprite);
         <summary>
        /// Verifica se un pannello specifico è attualmente attivo.
        /// </summary>
        /// <param name="panelName">Nome del pannello da verificare</param>
        /// <returns>True se il pannello è attivo, false altrimenti</returns>

        public bool IsPanelActive(string panelName);
         <summary>
        /// Ottiene il nome del pannello attualmente attivo.
        /// </summary>
        /// <returns>Nome del pannello attivo</returns>

        public string GetCurrentPanelName();
        private void ShowPanel(UIPanel panel);
        private void ClosePanel(UIPanel panel, bool animate);
        private System.Collections.IEnumerator DisablePanelDelayed(GameObject panel, float delay);
        private void StartTransition(System.Action onComplete);
        private System.Collections.IEnumerator InvokeAfterDelay(System.Action action, float delay);
    }
    public class UIPanel
    {
        public string name;
        public GameObject panel;
        public Animator animator;
        public bool activeAtStart;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/GameManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// 
    /// </summary>

    public class GameManager : MonoBehaviour
    {
        public static GameManager Instance { get; set; }
        private void Awake();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialManagerWindow.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Gestisce l'interfaccia utente per la selezione e avanzamento dei tutorial
    /// </summary>

    public class TutorialManagerWindow : MonoBehaviour
    {
        [SerializeField] private GameObject tutorialSelectionPanel;
        [SerializeField] private GameObject tutorialButtonPrefab;
        [SerializeField] private Transform tutorialButtonsContainer;
        [SerializeField] private Button backButton;
        [SerializeField] private TextMeshProUGUI titleText;
        [SerializeField] private TutorialLevelInitializer tutorialInitializer;
        private int _highestUnlockedTutorial;
        private void Start();
         <summary>
        /// Carica il progresso del tutorial
        /// </summary>

        private void LoadTutorialProgress();
         <summary>
        /// Inizializza l'UI dei tutorial
        /// </summary>

        private void InitializeUI();
         <summary>
        /// Avvia un tutorial specifico
        /// </summary>

        public void StartTutorial(int tutorialIndex);
         <summary>
        /// Coroutine per avviare il tutorial dopo un breve ritardo
        /// </summary>

        private IEnumerator StartTutorialWithDelay(int tutorialIndex);
         <summary>
        /// Gestisce il click sul pulsante back
        /// </summary>

        private void OnBackButtonClicked();
         <summary>
        /// Sblocca il prossimo tutorial nella sequenza
        /// </summary>

        public void UnlockNextTutorial();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialLevelInitializer.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Inizializzatore per i livelli tutorial, gestisce la configurazione degli scenari
    /// </summary>

    public class TutorialLevelInitializer : MonoBehaviour
    {
        public TutorialLevelData[] tutorialSequence;
        public bool showDebugGizmos;
        private EntityManager _entityManager;
        private float _currentLevelLength;
        private Vector3 _startPosition;
        private void Awake();
        private void Start();
         <summary>
        /// Inizializza un livello tutorial con la sequenza definita
        /// </summary>

        public void InitializeTutorialLevel();
         <summary>
        /// Avanza alla prossima sequenza tutorial
        /// </summary>

        public void AdvanceToNextTutorialSequence();
         <summary>
        /// Configura gli scenari tutorial per una sequenza
        /// </summary>

        private void SetupTutorialScenarios(TutorialLevelData tutorial);
         <summary>
        /// Pulisce gli scenari tutorial precedenti
        /// </summary>

        private void CleanupPreviousScenarios();
         <summary>
        /// Visualizza gizmo per debug nel mondo
        /// </summary>

        private void OnDrawGizmos();
    }
     <summary>
    /// Temi di mondo disponibili
    /// </summary>

    public enum WorldTheme
    {
        Tutorial,
        City,
        Forest,
        Tundra,
        Volcano,
        Abyss,
        Virtual
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialScenario.cs

namespace RunawayHeroes.Gameplay
{
     <summary>
    /// Rappresenta uno scenario di insegnamento nel tutorial
    /// </summary>

    public struct TutorialScenario
    {
        public string name;
        public float distanceFromStart;
        public ObstacleSetup[] obstacles;
        public string instructionMessage;
        public float messageDuration;
        public bool randomPlacement;
        public float obstacleSpacing;
         <summary>
        /// Crea uno scenario di base per il tutorial
        /// </summary>

        public static TutorialScenario CreateBasic(string name, float distance, string message);
         <summary>
        /// Crea uno scenario per insegnare il salto
        /// </summary>

        public static TutorialScenario CreateJumpScenario(float distance);
         <summary>
        /// Crea uno scenario per insegnare la scivolata
        /// </summary>

        public static TutorialScenario CreateSlideScenario(float distance);
         <summary>
        /// Crea uno scenario per insegnare i movimenti laterali
        /// </summary>

        public static TutorialScenario CreateSideStepScenario(float distance);
         <summary>
        /// Crea uno scenario con diversi tipi di ostacoli per movimenti combinati
        /// </summary>

        public static TutorialScenario CreateCombinedMovesScenario(float distance);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialSceneSetup.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Componente che gestisce il setup iniziale della scena del tutorial
    /// </summary>

    public class TutorialSceneSetup : MonoBehaviour
    {
        public GameObject playerPrefab;
        public GameObject cameraPrefab;
        public Vector3 playerStartPosition;
        public int defaultCharacterId;
        public TutorialLevelInitializer tutorialInitializer;
        public bool loadMainMenuOnCompletion;
        private GameObject _player;
        private GameObject _camera;
        private void Awake();
        private void Start();
         <summary>
        /// Spawna il giocatore nella scena
        /// </summary>

        private void SpawnPlayer();
         <summary>
        /// Configura la telecamera per seguire il giocatore
        /// </summary>

        private void SetupCamera();
         <summary>
        /// Configura il personaggio selezionato
        /// </summary>

        private void SetupCharacter(int characterId);
         <summary>
        /// Registra la callback per il completamento del tutorial
        /// </summary>

        private void RegisterTutorialCompletionCallback();
        private void Update();
         <summary>
        /// Carica il prossimo tutorial o torna al menu principale
        /// </summary>

        private void LoadMainMenu();
         <summary>
        /// Carica il prossimo tutorial nella sequenza
        /// </summary>

        private void LoadNextTutorial();
    }
     <summary>
    /// Classe segnaposto per la telecamera che segue il giocatore
    /// In un gioco reale, questa sarebbe una implementazione completa
    /// </summary>

    public class CameraFollow : MonoBehaviour
    {
        public Transform target;
        public Vector3 offset;
        public float smoothSpeed;
        private void LateUpdate();
    }
     <summary>
    /// Classe segnaposto per il tracciamento del progresso del tutorial
    /// In un gioco reale, questa sarebbe gestita da un sistema più complesso
    /// </summary>

    public class ProgressTracker : MonoBehaviour
    {
        private bool _tutorialCompleted;
        private float _progressPercentage;
        public void SetProgress(float percentage);
        public bool IsTutorialCompleted();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialLevelSequence.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Definisce una sequenza di livelli tutorial con progressione di difficoltà
    /// </summary>

    public struct TutorialLevelData
    {
        public string description;
        public WorldTheme theme;
        public int length;
        public int difficulty;
        public float obstacleDensity;
        public float enemyDensity;
        public TutorialScenario[] scenarios;
    }
     <summary>
    /// Definisce uno scenario di insegnamento specifico in un livello tutorial
    /// </summary>

    public struct TutorialScenario
    {
        public string name;
        public float distanceFromStart;
        public ObstacleSetup[] obstacles;
        public string instructionMessage;
        public float messageDuration;
        public bool randomPlacement;
        public float obstacleSpacing;
    }
     <summary>
    /// Configurazione di un tipo di ostacolo per uno scenario tutorial
    /// </summary>

    public struct ObstacleSetup
    {
        public string obstacleCode;
        public int count;
        public ObstaclePlacement placement;
        public bool randomizeHeight;
        public Vector2 heightRange;
        public bool randomizeScale;
        public Vector2 scaleRange;
        public float startOffset;
    }
     <summary>
    /// Posizionamento laterale degli ostacoli
    /// </summary>

    public enum ObstaclePlacement
    {
        Center,
        Left,
        Right,
        Random,
        Pattern
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Characters/PlayerController.cs

namespace RunawayHeroes.Runtime.Characters
{
     <summary>
    /// Controllore del personaggio giocatore che funziona sia in gioco normale
    /// che nel tutorial
    /// </summary>

    public class PlayerController : MonoBehaviour
    {
        public float forwardSpeed;
        public float acceleration;
        public float maxSpeed;
        public float lateralSpeed;
        public float jumpForce;
        public float gravity;
        public int maxJumps;
        public float slideDuration;
        public float slideHeightReduction;
        public ParticleSystem runningEffect;
        public ParticleSystem jumpEffect;
        public ParticleSystem slideEffect;
        public Animator animator;
        private CharacterController _controller;
        private Entity _playerEntity;
        private EntityManager _entityManager;
        private Vector3 _moveDirection;
        private float _currentSpeed;
        private bool _isJumping;
        private bool _isSliding;
        private float _slideTimer;
        private int _jumpCount;
        private float _defaultHeight;
        private float _slidingHeight;
        private Vector3 _defaultCenter;
        private Vector3 _slidingCenter;
        private bool _isTutorial;
        private readonly int _animIsRunning;
        private readonly int _animIsJumping;
        private readonly int _animIsSliding;
        private readonly int _animRunSpeed;
        private void Awake();
        private void Start();
        private void Update();
         <summary>
        /// Gestisce l'input del giocatore
        /// </summary>

        private void HandleInput();
         <summary>
        /// Applica il movimento al character controller
        /// </summary>

        private void ApplyMovement();
         <summary>
        /// Aggiorna le animazioni del personaggio
        /// </summary>

        private void UpdateAnimation();
         <summary>
        /// Aggiorna gli effetti particellari
        /// </summary>

        private void UpdateEffects();
         <summary>
        /// Crea un'entità ECS per il player
        /// </summary>

        private void CreatePlayerEntity();
         <summary>
        /// Aggiorna l'entità ECS del giocatore
        /// </summary>

        private void UpdatePlayerEntity();
         <summary>
        /// Verifica se ci troviamo nella modalità tutorial
        /// </summary>

        private bool IsTutorialMode();
         <summary>
        /// Imposta un personaggio specifico
        /// </summary>

        public void SetCharacterId(int characterId);
    }
     <summary>
    /// Componente per il movimento del giocatore nell'ECS
    /// </summary>

    public struct PlayerMovementComponent : IComponentData
    {
        public float ForwardSpeed;
        public float LateralSpeed;
        public bool IsJumping;
        public bool IsSliding;
    }
     <summary>
    /// Componente per la trasformazione nell'ECS
    /// </summary>

    public struct TransformComponent : IComponentData
    {
        public Vector3 Position;
        public Quaternion Rotation;
        public Vector3 Scale;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/EntityQueries.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class EntityQueries
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/ECSLogger.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class ECSLogger
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/ComponentExtensions.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// Classe di estensione che fornisce metodi di utilità per lavorare con componenti ECS.
    /// Offre funzionalità per semplificare operazioni comuni sui componenti come clonazione,
    /// conversione, ricerca, e manipolazione di valori.
    /// </summary>

    public static class ComponentExtensions
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/EntityDebugger.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class EntityDebugger
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/SystemUtilities.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// Classe di utilità che fornisce metodi e funzioni helper per l'implementazione
    /// e l'ottimizzazione dei sistemi ECS. Include strumenti per profiling, gestione 
    /// dei job, creazione di query ottimizzate e altre operazioni comuni.
    /// </summary>

    public static class SystemUtilities
    {
         <summary>
        /// Registra un job come dipendenza per un sistema con gestione degli errori.
        /// </summary>
        /// <param name="system">Sistema in cui registrare la dipendenza</param>
        /// <param name="jobHandle">Handle del job da registrare</param>
        /// <param name="jobName">Nome del job per scopi di diagnostica</param>
        /// <returns>Lo stesso jobHandle per consentire catene di chiamate</returns>

        public static Unity.Jobs.JobHandle RegisterJobDependency(SystemBase system, Unity.Jobs.JobHandle currentDependency, Unity.Jobs.JobHandle jobHandle, string jobName);
         <summary>
        /// Configura un timer per il profiling delle prestazioni di un sistema.
        /// </summary>
        /// <param name="system">Sistema da profilare</param>
        /// <param name="profileName">Nome identificativo per il profiler</param>
        /// <returns>Un oggetto IDisposable che alla Dispose ferma il timer</returns>

        public static System.IDisposable BeginSystemProfiling(SystemBase system, string profileName);
        public void Dispose();
         <summary>
        /// Verifica se un sistema deve essere aggiornato in base alla presenza di entità
        /// che corrispondono ai requisiti e altre condizioni opzionali.
        /// </summary>
        /// <param name="system">Sistema da verificare</param>
        /// <param name="query">Query da utilizzare per verificare la presenza di entità</param>
        /// <param name="additionalCondition">Condizione aggiuntiva opzionale</param>
        /// <returns>True se il sistema deve essere aggiornato, False altrimenti</returns>

        public static bool ShouldUpdateSystem(SystemBase system, EntityQuery query, System.Func<bool> additionalCondition);
    }
     <summary>
        /// Oggetto helper per gestire lo scope del profiler.
        /// </summary>

    private class ProfilerScope : System.IDisposable
    {
        public void Dispose();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Extensions/StringExtensions.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class StringExtensions
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Extensions/VectorExtensions.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class VectorExtensions
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Helpers/MathHelper.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class MathHelper
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Helpers/StringHelper.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class StringHelper
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Helpers/DebugHelper.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class DebugHelper
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Gameplay/Obstacles/ObstacleSetup.cs

namespace RunawayHeroes.Gameplay
{
     <summary>
    /// Definisce i possibili posizionamenti per gli ostacoli
    /// </summary>

    public enum ObstaclePlacement
    {
        Center = 0,
        Left = 1,
        Right = 2,
        Random = 3,
        Pattern = 4
    }
     <summary>
    /// Configurazione per un tipo di ostacolo in uno scenario
    /// </summary>

    public struct ObstacleSetup
    {
        public string obstacleCode;
        public int count;
        public ObstaclePlacement placement;
        public bool randomizeHeight;
        public Vector2 heightRange;
        public bool randomizeScale;
        public Vector2 scaleRange;
        public float startOffset;
         <summary>
        /// Creazione di un'istanza base di ObstacleSetup
        /// </summary>

        public static ObstacleSetup CreateDefault();
         <summary>
        /// Creazione di un'istanza per ostacoli da saltare
        /// </summary>

        public static ObstacleSetup CreateJumpObstacles(string code, int count);
         <summary>
        /// Creazione di un'istanza per ostacoli da scivolare sotto
        /// </summary>

        public static ObstacleSetup CreateSlideObstacles(string code, int count);
         <summary>
        /// Creazione di un'istanza per ostacoli da evitare con spostamenti laterali
        /// </summary>

        public static ObstacleSetup CreateSideStepObstacles(string code, int count);
         <summary>
        /// Creazione di un'istanza per ostacoli casuali (livelli avanzati)
        /// </summary>

        public static ObstacleSetup CreateRandomObstacles(string code, int count);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/EntityDebugWindow.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class EntityDebugWindow
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/SystemMonitorWindow.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class SystemMonitorWindow
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/DOTSVersionChecker.cs

    public class DOTSVersionChecker : EditorWindow
    {
        public static void ShowWindow();
        private void OnGUI();
        private void CheckDOTSVersions();
        private bool IsDOTSPackage(string packageName);
        private void CheckVersionCompatibility(Dictionary<string, string> packages);
    }


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/SystemDependencyAnalyzer.cs

namespace RunawayHeroes.Editor.ECSDebugger
{
    public class SystemDependencyAnalyzer : EditorWindow
    {
        private Vector2 scrollPosition;
        private bool showAllSystems;
        private bool showOnlyProblematic;
        private List<SystemInfo> systemInfos;
        private List<CyclicDependency> cyclicDependencies;
        public Type Type;
        public string Name;
        public string Group;
        public List<string> UpdateBefore;
        public List<string> UpdateAfter;
        public List<SystemInfo> DependenciesTo;
        public List<SystemInfo> DependenciesFrom;
        public List<SystemInfo> DependentsTo;
        public List<SystemInfo> DependentsFrom;
        public bool IsProblematic;
        public List<SystemInfo> Systems;
        public bool HasDependencies { ... }
        public bool HasDependents { ... }
        public static void ShowWindow();
        private void OnEnable();
        private void OnGUI();
        private void AnalyzeSystems();
        private void FindCyclicDependencies();
        private void FindCycles(SystemInfo start, SystemInfo current, HashSet<SystemInfo> visited, List<SystemInfo> path);
    }
    private class SystemInfo
    {
        public Type Type;
        public string Name;
        public string Group;
        public List<string> UpdateBefore;
        public List<string> UpdateAfter;
        public List<SystemInfo> DependenciesTo;
        public List<SystemInfo> DependenciesFrom;
        public List<SystemInfo> DependentsTo;
        public List<SystemInfo> DependentsFrom;
        public bool IsProblematic;
        public bool HasDependencies { ... }
        public bool HasDependents { ... }
    }
    private class CyclicDependency
    {
        public List<SystemInfo> Systems;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/SystemDebugger.cs

    public class SystemDebugger : MonoBehaviour
    {
         void Start();
    }


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/CustomInspectors/ComponentDataInspector.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class ComponentDataInspector
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/CustomInspectors/EntityInspector.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class EntityInspector
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/Validators/LevelValidatorEditor.cs



## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/Wizards/ECSSystemWizard.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class ECSSystemWizard
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/Wizards/ECSComponentWizard.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class ECSComponentWizard
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/Validation/LevelValidator.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Sistema di validazione che verifica se un livello generato è completabile
    /// </summary>

    public class LevelValidator : MonoBehaviour
    {
        public float characterRadius;
        public float characterHeight;
        public float characterSlideHeight;
        public float maxJumpHeight;
        public int maxConsecutiveJumps;
        public float maxSideStepDistance;
        public bool showDebugVisualization;
        public bool generateDetailedReport;
        public TutorialLevelInitializer tutorialInitializer;
        private List<ValidationIssue> _validationIssues;
        private const float LANE_WIDTH;
        private const float LEFT_POSITION;
        private const float CENTER_POSITION;
        private const float RIGHT_POSITION;
         <summary>
        /// Esegue la validazione del livello tutorial configurato
        /// </summary>

        public ValidationResult ValidateLevel();
         <summary>
        /// Controlla se ci sono problemi critici che rendono il livello impossibile
        /// </summary>

        private bool HasCriticalIssues();
         <summary>
        /// Stampa il risultato della validazione nel log
        /// </summary>

        private void LogValidationResult(bool isValid);
         <summary>
        /// Valida tutte le sequenze tutorial
        /// </summary>

        private void ValidateTutorialSequences(TutorialLevelData[] sequences);
         <summary>
        /// Valida una sequenza tutorial specifica
        /// </summary>

        private void ValidateTutorialSequence(TutorialLevelData sequence, int sequenceIndex);
         <summary>
        /// Verifica che non ci siano sovrapposizioni tra scenari
        /// </summary>

        private void CheckScenarioOverlaps(TutorialLevelData sequence);
         <summary>
        /// Stima la fine di uno scenario in base agli ostacoli presenti
        /// </summary>

        private float EstimateScenarioEnd(TutorialScenario scenario);
         <summary>
        /// Valida uno scenario specifico
        /// </summary>

        private void ValidateScenario(TutorialScenario scenario, TutorialLevelData sequence, int scenarioIndex);
         <summary>
        /// Verifica che la lunghezza della sequenza sia ragionevole
        /// </summary>

        private void ValidateSequenceLength(TutorialLevelData sequence);
         <summary>
        /// Valida una configurazione di ostacoli
        /// </summary>

        private void ValidateObstacleSetup(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica la presenza di collisioni tra diversi ostacoli nello stesso scenario
        /// </summary>

        private void CheckForObstacleCollisions(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica che gli ostacoli possano essere superati con le abilità disponibili
        /// </summary>

        private void CheckIfObstaclesCanBeTraversed(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica gli ostacoli da saltare
        /// </summary>

        private void CheckJumpObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica gli ostacoli da superare con scivolata
        /// </summary>

        private void CheckSlideObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica gli ostacoli da evitare con spostamenti laterali
        /// </summary>

        private void CheckSideObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica ostacoli speciali (lava, ghiaccio, barriere digitali, ecc.)
        /// </summary>

        private void CheckSpecialObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica pattern complessi di ostacoli
        /// </summary>

        private void CheckComplexObstaclePatterns(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Esegue una simulazione semplificata del percorso per verificare se è possibile superare
        /// tutti gli ostacoli nella sequenza
        /// </summary>

        private void ScanObstacleCombination(TutorialScenario scenario);
         <summary>
        /// Verifica se esiste un percorso attraverso gli ostacoli presenti alle posizioni z specificate
        /// </summary>

        private bool CheckPathExistsAt(Dictionary<float, List<(float x, float y, float width, float height)>> obstacleMap, float z1, float z2);
         <summary>
        /// Verifica se una posizione x è bloccata dagli ostacoli
        /// </summary>

        private bool IsPositionBlocked(float x, List<(float min, float max)> blockedRanges);
         <summary>
        /// Popola la mappa degli ostacoli per uno specifico setup
        /// </summary>

        private void PopulateObstacleMap(Dictionary<float, List<(float x, float y, float width, float height)>> map, ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Determina il tipo di ostacolo in base al codice
        /// </summary>

        private ObstacleType DetermineObstacleType(string obstacleCode);
         <summary>
        /// Determina l'altezza predefinita di un ostacolo in base al codice
        /// </summary>

        private float DetermineDefaultObstacleHeight(string obstacleCode);
         <summary>
        /// Determina la larghezza predefinita di un ostacolo in base al codice
        /// </summary>

        private float DetermineDefaultObstacleWidth(string obstacleCode);
         <summary>
        /// Stima le posizioni degli ostacoli in base alla configurazione
        /// </summary>

        private List<(float x, float y, float z)> EstimateObstaclePositions(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Visualizza debug gizmo degli ostacoli e problemi
        /// </summary>

        private void OnDrawGizmos();
    }
     <summary>
    /// Rappresenta un problema di validazione
    /// </summary>

    public class ValidationIssue
    {
        public IssueType Type;
        public string Message;
        public string ScenarioName;
        public Vector3 Position;
    }
     <summary>
    /// Tipo di problema di validazione
    /// </summary>

    public enum IssueType
    {
        Critical,
        Warning
    }
     <summary>
    /// Risultato della validazione
    /// </summary>

    public class ValidationResult
    {
        public bool IsValid;
        public List<ValidationIssue> Issues;
    }
     <summary>
    /// Tipi di ostacoli
    /// </summary>

    public enum ObstacleType
    {
        Generic,
        JumpObstacle,
        SlideObstacle,
        SideObstacle,
        SpecialObstacle
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/UI/UIMessageComponent.cs

namespace RunawayHeroes.ECS.Components.UI
{
     <summary>
    /// Componente che rappresenta un messaggio UI da visualizzare.
    /// Utilizzato principalmente per i messaggi di istruzione del tutorial.
    /// </summary>

    public struct UIMessageComponent : IComponentData
    {
        public FixedString128Bytes Message;
        public float Duration;
        public float RemainingTime;
        public byte MessageType;
        public bool IsPersistent;
        public int MessageId;
    }
     <summary>
    /// Tag per identificare un messaggio attualmente visualizzato nell'UI
    /// </summary>

    public struct ActiveMessageTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare un messaggio in coda di visualizzazione
    /// </summary>

    public struct QueuedMessageTag : IComponentData
    {
        public int QueuePosition;
    }
     <summary>
    /// Evento generato quando un nuovo messaggio deve essere visualizzato
    /// </summary>

    public struct MessageShowEvent : IComponentData
    {
        public Entity MessageEntity;
    }
     <summary>
    /// Evento generato quando un messaggio deve essere nascosto
    /// </summary>

    public struct MessageHideEvent : IComponentData
    {
        public Entity MessageEntity;
        public bool Forced;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/CommonTags.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Tag per identificare le entità del giocatore
    /// </summary>

    public struct PlayerTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare le entità attive
    /// </summary>

    public struct ActiveTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/TagComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Componente per etichettare le entità con tag personalizzati.
    /// Permette di identificare facilmente il tipo o ruolo di un'entità.
    /// </summary>

    public struct TagComponent : IComponentData
    {
        public FixedString64Bytes Tag;
         <summary>
        /// Crea un nuovo TagComponent con il valore di tag specificato
        /// </summary>
        /// <param name="tag">Il valore del tag</param>
        /// <returns>Un nuovo TagComponent con il tag specificato</returns>

        public static TagComponent Create(string tag);
         <summary>
        /// Verifica se il tag corrisponde a quello specificato
        /// </summary>
        /// <param name="tagToCheck">Il tag da confrontare</param>
        /// <returns>True se i tag corrispondono, false altrimenti</returns>

        public bool HasTag(string tagToCheck);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/TransformComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Componente che memorizza la posizione, rotazione e scala di un'entità.
    /// Usato per entità che richiedono un posizionamento nello spazio 3D.
    /// </summary>

    public struct TransformComponent : IComponentData
    {
        public float3 Position;
        public quaternion Rotation;
        public float Scale;
         <summary>
        /// Crea un nuovo TransformComponent con valori predefiniti
        /// </summary>
        /// <returns>TransformComponent inizializzato con valori predefiniti</returns>

        public static TransformComponent Default();
         <summary>
        /// Crea un nuovo TransformComponent con una posizione specifica
        /// </summary>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>TransformComponent inizializzato con la posizione specificata</returns>

        public static TransformComponent WithPosition(float3 position);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/IdentityComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// 
    /// </summary>

    public struct IdentityComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/PhysicsComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Componente che memorizza le proprietà fisiche di un'entità, come velocità, massa e accelerazione.
    /// Utilizzato per simulare movimenti e interazioni fisiche nel gioco.
    /// </summary>

    public struct PhysicsComponent : IComponentData
    {
        public float3 Velocity;
        public float3 Acceleration;
        public float Mass;
        public float Gravity;
        public float Friction;
        public bool UseGravity;
        public bool IsGrounded;
         <summary>
        /// Crea un nuovo PhysicsComponent con valori predefiniti
        /// </summary>
        /// <returns>PhysicsComponent inizializzato con valori predefiniti</returns>

        public static PhysicsComponent Default();
         <summary>
        /// Applica una forza all'entità, modificando la sua accelerazione in base alla massa
        /// </summary>
        /// <param name="force">Forza da applicare</param>
        /// <returns>Nuova accelerazione risultante</returns>

        public float3 ApplyForce(float3 force);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/RenderComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// 
    /// </summary>

    public struct RenderComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/SlideInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input di scivolata per il personaggio.
    /// Viene aggiornato ogni frame dal sistema di input.
    /// </summary>

    public struct SlideInputComponent : IComponentData
    {
        public bool SlidePressed;
        public float SlideForceMultiplier;
        public float CustomSlideDuration;
         <summary>
        /// Resetta lo stato di input per evitare input duplicati
        /// </summary>

        public void Reset();
         <summary>
        /// Crea una nuova istanza con valori predefiniti
        /// </summary>
        /// <returns>Un nuovo SlideInputComponent con valori predefiniti</returns>

        public static SlideInputComponent Default();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/JumpInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input di salto per il personaggio.
    /// Viene aggiornato ogni frame dal sistema di input.
    /// </summary>

    public struct JumpInputComponent : IComponentData
    {
        public bool JumpPressed;
        public float JumpForceMultiplier;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/TouchInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che memorizza lo stato degli input touch per dispositivi mobili.
    /// Permette l'interazione attraverso tap, swipe e gesti multitouch.
    /// </summary>

    public struct TouchInputComponent : IComponentData
    {
        public bool IsTouching;
        public float2 TouchPosition;
        public float2 TouchStartPosition;
        public float2 TouchDelta;
        public float TouchDuration;
        public bool SwipeUp;
        public bool SwipeDown;
        public bool SwipeLeft;
        public bool SwipeRight;
        public bool Tap;
        public bool DoubleTap;
        public bool LongPress;
         <summary>
        /// Resetta gli stati di swipe e tap per evitare duplicazioni
        /// </summary>

        public void ResetGestures();
         <summary>
        /// Resetta completamente lo stato del touch
        /// </summary>

        public void ResetTouch();
         <summary>
        /// Crea una nuova istanza con valori predefiniti
        /// </summary>
        /// <returns>Un nuovo TouchInputComponent con valori predefiniti</returns>

        public static TouchInputComponent Default();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/InputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che memorizza tutti gli input del giocatore in un dato frame.
    /// Centralizza gli input provenienti da touch, tasti, o altri controlli,
    /// convertendoli in uno stato coerente per i sistemi di movimento e abilità.
    /// </summary>

    public struct InputComponent : IComponentData
    {
        public float LateralMovement;
        public float2 MoveDirection;
        public bool IsMovementEnabled;
        public bool JumpPressed;
        public bool SlidePressed;
        public bool FocusTimePressed;
        public bool AbilityPressed;
        public bool CharacterSwitchPressed;
        public float2 TouchPosition;
        public bool TouchActive;
        public float TouchDuration;
         <summary>
        /// Crea un nuovo InputComponent con valori predefiniti
        /// </summary>
        /// <returns>InputComponent inizializzato con tutti gli input a zero/false</returns>

        public static InputComponent Default();
         <summary>
        /// Resetta tutti gli input "premuti" a false, mantenendo solo gli stati analogici
        /// </summary>

        public void ResetPressedInputs();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/AbilityInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input relativo all'attivazione di abilità speciali.
    /// Tiene traccia dei comandi per attivare le abilità uniche di ogni personaggio.
    /// </summary>

    public struct AbilityInputComponent : IComponentData
    {
        public bool ActivateAbility;
        public float2 TargetPosition;
        public AbilityType CurrentAbilityType;
         <summary>
        /// Resetta lo stato di input per evitare input duplicati
        /// </summary>

        public void Reset();
         <summary>
        /// Crea una nuova istanza con valori predefiniti
        /// </summary>
        /// <returns>Un nuovo AbilityInputComponent con valori predefiniti</returns>

        public static AbilityInputComponent Default();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/ResonanceInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input relativo alla Risonanza dei Frammenti,
    /// permettendo al giocatore di cambiare personaggio durante il gameplay.
    /// </summary>

    public struct ResonanceInputComponent : IComponentData
    {
        public int SwitchToCharacterIndex;
        public bool NewCharacterUnlocked;
        public Entity NewCharacterEntity;
        public bool ResonanceLevelUp;
        public int NewResonanceLevel;
         <summary>
        /// Crea un nuovo ResonanceInputComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti</returns>

        public static ResonanceInputComponent Default();
         <summary>
        /// Reimposta gli input a singolo frame per evitare input ripetuti
        /// </summary>

        public void Reset();
         <summary>
        /// Imposta la richiesta di cambio personaggio
        /// </summary>
        /// <param name="characterIndex">Indice del personaggio da attivare</param>

        public void RequestCharacterSwitch(int characterIndex);
         <summary>
        /// Imposta un nuovo personaggio sbloccato
        /// </summary>
        /// <param name="character">Entità del personaggio sbloccato</param>

        public void UnlockNewCharacter(Entity character);
         <summary>
        /// Richiede un aumento di livello per la Risonanza
        /// </summary>
        /// <param name="newLevel">Nuovo livello di Risonanza</param>

        public void UpgradeResonance(int newLevel);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/FocusTimeInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input relativo al sistema Focus Time,
    /// includendo l'attivazione/disattivazione e la selezione di oggetti.
    /// </summary>

    public struct FocusTimeInputComponent : IComponentData
    {
        public bool ActivateFocusTime;
        public bool DeactivateFocusTime;
        public int SelectedItemIndex;
        public bool NewItemDetected;
        public Entity NewItemEntity;
        public float2 FocusPointerPosition;
        public float ActivationHoldTime;
         <summary>
        /// Crea un nuovo FocusTimeInputComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti</returns>

        public static FocusTimeInputComponent Default();
         <summary>
        /// Reimposta gli input a singolo frame per evitare input ripetuti
        /// </summary>

        public void Reset();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/SpawnPointComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct SpawnPointComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/WorldIdentifierComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct WorldIdentifierComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/ObstacleSpawnConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce le configurazioni per lo spawn di ostacoli in un segmento
    /// </summary>

    public struct ObstacleSpawnConfigComponent : IComponentData
    {
        public float DensityFactor;
        public int MinObstacles;
        public int MaxObstacles;
        public float SmallObstacleProbability;
        public float MediumObstacleProbability;
        public float LargeObstacleProbability;
        public float CityObstacleWeight;
        public float ForestObstacleWeight;
        public float TundraObstacleWeight;
        public float VolcanoObstacleWeight;
        public float AbyssObstacleWeight;
        public float VirtualObstacleWeight;
        public float LavaObstacleProbability;
        public float IceObstacleProbability;
        public float DigitalBarrierProbability;
        public float UnderwaterProbability;
        public float SlipperyProbability;
        public float ToxicGroundProbability;
        public float CurrentProbability;
        public float SpecialHazardDensity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RoomTemplateComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce un template di stanza utilizzabile nella generazione procedurale
    /// </summary>

    public struct RoomTemplateComponent : IComponentData
    {
        public int TemplateID;
        public int2 Size;
        public int MinDoorways;
        public int MaxDoorways;
        public RoomType Type;
        public int Difficulty;
        public bool IsStartRoom;
        public bool IsEndRoom;
        public bool RequiresSpecificAbility;
        public int RequiredAbilityType;
    }
     <summary>
    /// Enumerazione che definisce i possibili tipi di stanza
    /// </summary>

    public enum RoomType
    {
        Standard,
        Treasure,
        Challenge,
        Boss,
        Secret,
        Checkpoint,
        Puzzle,
        Hub
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RoomComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che rappresenta una stanza generata all'interno di un livello
    /// </summary>

    public struct RoomComponent : IComponentData
    {
        public float3 Position;
        public quaternion Rotation;
        public int2 GridPosition;
        public int2 Size;
        public int TemplateID;
        public Entity LevelEntity;
        public RoomState State;
        public bool IsVisited;
        public bool IsMapped;
        public bool ContainsCollectibles;
        public bool ContainsEnemies;
    }
     <summary>
    /// Enumerazione che definisce i possibili stati di una stanza
    /// </summary>

    public enum RoomState
    {
        Inactive,
        Active,
        Cleared,
        Locked,
        Secret
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/LevelComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct LevelComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RoomDoorwayBuffer.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Buffer element component che contiene i riferimenti alle doorway di una stanza
    /// </summary>

    public struct RoomDoorwayBuffer : IBufferElementData
    {
        public Entity DoorwayEntity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RandomLevelConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce la configurazione per la generazione di livelli randomizzati
    /// </summary>

    public struct RandomLevelConfigComponent : IComponentData
    {
        public int MinRooms;
        public int MaxRooms;
        public int MinRoomSize;
        public int MaxRoomSize;
        public int CorridorWidth;
        public float BranchingProbability;
        public int Seed;
        public int WorldTheme;
        public bool UseLoops;
        public bool EnsureConnectivity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/DoorwayComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce un punto di connessione tra stanze
    /// </summary>

    public struct DoorwayComponent : IComponentData
    {
        public float3 Position;
        public quaternion Rotation;
        public DoorwayDirection Direction;
        public Entity SourceRoom;
        public Entity TargetRoom;
        public DoorwayType Type;
        public bool IsConnected;
        public bool IsLocked;
        public int KeyID;
    }
     <summary>
    /// Enumerazione che definisce i possibili tipi di doorway
    /// </summary>

    public enum DoorwayType
    {
        Standard,
        OneWay,
        Hidden,
        Boss,
        Challenge,
        AbilityGated,
        KeyGated
    }
     <summary>
    /// Enumerazione che definisce le possibili direzioni di una doorway
    /// </summary>

    public enum DoorwayDirection
    {
        North,
        East,
        South,
        West,
        Up,
        Down
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/EnemySpawnConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce le configurazioni per lo spawn di nemici in un segmento
    /// </summary>

    public struct EnemySpawnConfigComponent : IComponentData
    {
        public float DensityFactor;
        public int MinEnemies;
        public int MaxEnemies;
        public float DroneProbability;
        public float PatrolProbability;
        public float AmbushProbability;
        public float CityEnemyWeight;
        public float ForestEnemyWeight;
        public float TundraEnemyWeight;
        public float VolcanoEnemyWeight;
        public float AbyssEnemyWeight;
        public float VirtualEnemyWeight;
        public float MidBossProbability;
        public float BossProbability;
        public float GroupSpawnProbability;
        public int MinGroupSize;
        public int MaxGroupSize;
        public float EliteEnemyProbability;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/CheckpointComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct CheckpointComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RunnerLevelConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce la configurazione per la generazione di livelli runner
    /// </summary>

    public struct RunnerLevelConfigComponent : IComponentData
    {
        public int LevelLength;
        public int MinSegments;
        public int MaxSegments;
        public int Seed;
        public int StartDifficulty;
        public int EndDifficulty;
        public float DifficultyRamp;
        public float ObstacleDensity;
        public float EnemyDensity;
        public float CollectibleDensity;
        public WorldTheme PrimaryTheme;
        public WorldTheme SecondaryTheme;
        public float ThemeBlendFactor;
        public bool GenerateCheckpoints;
        public bool DynamicDifficulty;
        public float SegmentVarietyFactor;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/WorldDifficultyConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce la configurazione di difficoltà per ciascun tema di mondo.
    /// Consente di scalare la difficoltà in modo appropriato per ogni ambiente di gioco.
    /// </summary>

    public struct WorldDifficultyConfigComponent : IComponentData
    {
        public int TutorialBaseDifficulty;
        public int CityBaseDifficulty;
        public int ForestBaseDifficulty;
        public int TundraBaseDifficulty;
        public int VolcanoBaseDifficulty;
        public int AbyssBaseDifficulty;
        public int VirtualBaseDifficulty;
        public float TutorialObstacleDensityScale;
        public float CityObstacleDensityScale;
        public float ForestObstacleDensityScale;
        public float TundraObstacleDensityScale;
        public float VolcanoObstacleDensityScale;
        public float AbyssObstacleDensityScale;
        public float VirtualObstacleDensityScale;
        public float TutorialEnemyDensityScale;
        public float CityEnemyDensityScale;
        public float ForestEnemyDensityScale;
        public float TundraEnemyDensityScale;
        public float VolcanoEnemyDensityScale;
        public float AbyssEnemyDensityScale;
        public float VirtualEnemyDensityScale;
        public float TutorialDifficultyRampScale;
        public float CityDifficultyRampScale;
        public float ForestDifficultyRampScale;
        public float TundraDifficultyRampScale;
        public float VolcanoDifficultyRampScale;
        public float AbyssDifficultyRampScale;
        public float VirtualDifficultyRampScale;
        public bool EnableTutorialSafezones;
        public float SpecialHazardReductionInTutorial;
         <summary>
        /// Restituisce la difficoltà di base per un tema specifico
        /// </summary>

        public int GetBaseDifficultyForTheme(WorldTheme theme);
         <summary>
        /// Restituisce il fattore di scala della densità degli ostacoli per un tema specifico
        /// </summary>

        public float GetObstacleDensityScaleForTheme(WorldTheme theme, bool isTutorial);
         <summary>
        /// Restituisce il fattore di scala della densità dei nemici per un tema specifico
        /// </summary>

        public float GetEnemyDensityScaleForTheme(WorldTheme theme, bool isTutorial);
         <summary>
        /// Restituisce il fattore di scala del ramp (incremento) della difficoltà per un tema specifico
        /// </summary>

        public float GetDifficultyRampScaleForTheme(WorldTheme theme, bool isTutorial);
         <summary>
        /// Crea una configurazione di difficoltà con valori predefiniti
        /// </summary>

        public static WorldDifficultyConfigComponent CreateDefault();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/HazardComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che rappresenta una zona pericolosa nell'ambiente di gioco.
    /// Può essere lava, tossine, radiazioni o altri elementi dannosi per il giocatore.
    /// </summary>

    public struct HazardComponent : IComponentData
    {
        public HazardType Type;
        public float DamagePerSecond;
        public float Radius;
        public bool IsContinuousDamage;
        public StatusEffectType StatusEffect;
        public float StatusEffectDuration;
        public float StatusEffectIntensity;
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona di lava
        /// </summary>

        public static HazardComponent CreateLavaHazard(float radius, float damagePerSecond);
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona tossica
        /// </summary>

        public static HazardComponent CreateToxicHazard(float radius, float damagePerSecond);
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona elettrificata
        /// </summary>

        public static HazardComponent CreateElectrifiedHazard(float radius, float damagePerSecond);
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona fredda
        /// </summary>

        public static HazardComponent CreateColdHazard(float radius, float damagePerSecond);
    }
     <summary>
    /// Tipi di pericoli ambientali
    /// </summary>

    public enum HazardType
    {
        None = 0,
        Lava = 1,
        Toxic = 2,
        Electric = 3,
        Cold = 4,
        Void = 5,
        Digital = 6,
        Crushing = 7
    }
     <summary>
    /// Tipi di effetti di status che possono essere applicati da pericoli
    /// </summary>

    public enum StatusEffectType
    {
        None = 0,
        Burning = 1,
        Poisoned = 2,
        Slowed = 3,
        Stunned = 4,
        Frozen = 5,
        Confused = 6,
        Weakened = 7
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/SegmentContentBuffer.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Buffer per memorizzare i riferimenti agli elementi (ostacoli, nemici, ecc.) di un segmento
    /// </summary>

    public struct SegmentContentBuffer : IBufferElementData
    {
        public Entity ContentEntity;
        public SegmentContentType Type;
    }
     <summary>
    /// Tipi di contenuto che possono essere presenti in un segmento
    /// </summary>

    public enum SegmentContentType
    {
        Obstacle,
        SmallObstacle,
        MediumObstacle,
        LargeObstacle,
        Enemy,
        Drone,
        Patrol,
        MidBoss,
        Boss,
        Collectible,
        PowerUp,
        Checkpoint,
        EnvironmentHazard,
        Decoration
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/PathSegmentComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce un segmento di percorso in un livello runner
    /// </summary>

    public struct PathSegmentComponent : IComponentData
    {
        public float3 StartPosition;
        public float3 EndPosition;
        public quaternion Rotation;
        public float Length;
        public float Width;
        public SegmentType Type;
        public int SegmentIndex;
        public int DifficultyLevel;
        public WorldTheme Theme;
        public bool IsActive;
        public bool IsGenerated;
        public Entity NextSegment;
    }
     <summary>
    /// Enumerazione dei tipi di segmenti di percorso
    /// </summary>

    public enum SegmentType
    {
        Straight,
        Uphill,
        Downhill,
        Curve,
        Jump,
        Narrow,
        Wide,
        Hazard,
        Checkpoint,
        Challenge
    }
     <summary>
    /// Enumerazione dei temi di mondo disponibili
    /// </summary>

    public enum WorldTheme
    {
        City,
        Forest,
        Tundra,
        Volcano,
        Abyss,
        Virtual
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/PathComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct PathComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/PathSegmentBuffer.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Buffer per memorizzare i riferimenti ai segmenti di percorso in un livello
    /// </summary>

    public struct PathSegmentBuffer : IBufferElementData
    {
        public Entity SegmentEntity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/UrbanDashAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Scatto Urbano" di Alex.
    /// Consente un'accelerazione improvvisa con invulnerabilità temporanea
    /// e la capacità di sfondare piccoli ostacoli.
    /// </summary>

    public struct UrbanDashAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float SpeedMultiplier;
        public float InitialBoost;
        public bool IsActive;
        public float BreakThroughForce;
        public bool IsAvailable { ... }
         <summary>
        /// Crea una nuova istanza di UrbanDashAbilityComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti per Alex</returns>

        public static UrbanDashAbilityComponent Default();
         <summary>
        /// Attiva l'abilità se disponibile
        /// </summary>
        /// <returns>True se l'abilità è stata attivata, false altrimenti</returns>

        public bool Activate();
         <summary>
        /// Disattiva l'abilità e avvia il cooldown
        /// </summary>

        public void Deactivate();
         <summary>
        /// Aggiorna i timer dell'abilità
        /// </summary>
        /// <param name="deltaTime">Il tempo trascorso dall'ultimo aggiornamento in secondi</param>
        /// <returns>True se lo stato dell'abilità è cambiato (attivata/disattivata), false altrimenti</returns>

        public bool Update(float deltaTime);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/FireproofBodyAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Corpo Ignifugo" di Ember.
    /// Trasformazione in forma ignea che permette di attraversare la lava.
    /// </summary>

    public struct FireproofBodyAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float HeatAura;
        public bool LavaWalkingActive;
        public bool IsActive;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/HeatAuraAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Aura di Calore" di Kai.
    /// Crea un campo che scioglie il ghiaccio e protegge dal freddo.
    /// </summary>

    public struct HeatAuraAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float AuraRadius;
        public float MeltIceRate;
        public bool IsActive;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/NatureCallAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Richiamo della Natura" di Maya.
    /// Evoca animali alleati temporanei che distraggono i nemici.
    /// </summary>

    public struct NatureCallAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public int MaxAllies;
        public float AllySummonRadius;
        public float AllyDistractDuration;
        public bool IsActive;
        public FixedList32Bytes<Entity> CurrentAllies;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/ControlledGlitchAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Glitch Controllato" di Neo.
    /// Deforma brevemente la realtà, permettendo di attraversare barriere digitali.
    /// </summary>

    public struct ControlledGlitchAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float GlitchDistance;
        public bool BarrierPenetration;
        public bool IsActive;
        public bool TeleportStarted;
        public bool GlitchCompleted;
        public float3 StartPosition;
        public float3 TargetPosition;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/AbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// 
    /// </summary>

    public struct AbilityComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/AirBubbleAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Bolla d'Aria" di Marina.
    /// Crea una bolla protettiva che fornisce ossigeno e respinge nemici acquatici.
    /// </summary>

    public struct AirBubbleAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float BubbleRadius;
        public float RepelForce;
        public bool IsActive;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ObjectiveComponents.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che rappresenta un obiettivo specifico da completare nel tutorial
    /// </summary>

    public struct ObjectiveComponent : IComponentData
    {
        public byte ObjectiveType;
        public int RequiredValue;
        public int CurrentProgress;
        public int ScenarioId;
        public FixedString128Bytes Description;
        public bool IsCompleted;
        public bool IsOptional;
    }
     <summary>
    /// Tag per indicare un obiettivo attualmente attivo
    /// </summary>

    public struct ActiveObjectiveTag : IComponentData
    {
    }
     <summary>
    /// Componente per tracciare il progresso numerico di un obiettivo
    /// </summary>

    public struct ObjectiveProgressComponent : IComponentData
    {
        public int Count;
        public int MaxCount;
        public float StartTime;
        public float TimeLimit;
    }
     <summary>
    /// Evento generato quando un obiettivo viene completato
    /// </summary>

    public struct ObjectiveCompletedEvent : IComponentData
    {
        public Entity ObjectiveEntity;
        public byte ObjectiveType;
        public int ScenarioId;
        public bool WasRequired;
    }
     <summary>
    /// Evento generato quando si verifica un progresso in un obiettivo
    /// </summary>

    public struct ObjectiveProgressEvent : IComponentData
    {
        public Entity ObjectiveEntity;
        public int PreviousValue;
        public int NewValue;
        public int RequiredValue;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ObstacleTagComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Tag per identificare le superfici di lava, utilizzato per l'abilità Corpo Ignifugo di Ember
    /// </summary>

    public struct LavaTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare le zone di ghiaccio, utilizzato per l'abilità Aura di Calore di Kai
    /// </summary>

    public struct IceObstacleTag : IComponentData
    {
    }
     <summary>
    /// Componente per tracciare l'integrità di un ostacolo di ghiaccio, utilizzato per l'effetto di scioglimento
    /// </summary>

    public struct IceIntegrityComponent : IComponentData
    {
        public float MaxIntegrity;
        public float CurrentIntegrity;
    }
     <summary>
    /// Tag per identificare barriere digitali, utilizzato per l'abilità Glitch Controllato di Neo
    /// </summary>

    public struct DigitalBarrierTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare le zone sottomarine, utilizzato per l'abilità Bolla d'Aria di Marina
    /// </summary>

    public struct UnderwaterTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare superfici scivolose o ghiacciate, utilizzato per l'abilità Aura di Calore di Kai
    /// </summary>

    public struct SlipperyTag : IComponentData
    {
        public float SlipFactor;
    }
     <summary>
    /// Tag per identificare terreni tossici, utilizzato per varie abilità di resistenza
    /// </summary>

    public struct ToxicGroundTag : IComponentData
    {
        public byte ToxicType;
        public float DamagePerSecond;
    }
     <summary>
    /// Tag per identificare correnti d'aria o d'acqua, utilizzato per varie abilità
    /// </summary>

    public struct CurrentTag : IComponentData
    {
        public Unity.Mathematics.float3 Direction;
        public float Strength;
        public byte CurrentType;
    }
     <summary>
    /// Componente per l'effetto visivo di scioglimento del ghiaccio
    /// </summary>

    public struct IceMeltEffectComponent : IComponentData
    {
        public Unity.Mathematics.float3 Position;
        public float Size;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/FocusTimeComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce la meccanica del "Focus Time" che permette
    /// al giocatore di rallentare il tempo per prendere decisioni strategiche
    /// e selezionare oggetti durante l'azione frenetica.
    /// </summary>

    public struct FocusTimeComponent : IComponentData
    {
        public float MaxDuration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float TimeScale;
        public bool IsActive;
        public float MaxEnergy;
        public float CurrentEnergy;
        public float EnergyConsumptionRate;
        public float EnergyRechargeRate;
        public int MaxItemSlots;
        public FixedList128Bytes<Entity> ItemSlots;
        public bool IsAvailable { ... }
        public float EnergyPercentage { ... }
         <summary>
        /// Crea un nuovo FocusTimeComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti</returns>

        public static FocusTimeComponent Default();
         <summary>
        /// Attiva il Focus Time se disponibile
        /// </summary>
        /// <returns>True se il Focus Time è stato attivato, false altrimenti</returns>

        public bool Activate();
         <summary>
        /// Disattiva il Focus Time e avvia il cooldown
        /// </summary>
        /// <param name="applyFullCooldown">Se true, applica l'intero cooldown, altrimenti un cooldown proporzionale al tempo utilizzato</param>

        public void Deactivate(bool applyFullCooldown);
         <summary>
        /// Aggiorna i timer e l'energia del Focus Time
        /// </summary>
        /// <param name="deltaTime">Il tempo trascorso dall'ultimo aggiornamento in secondi</param>
        /// <returns>True se lo stato del Focus Time è cambiato, false altrimenti</returns>

        public bool Update(float deltaTime);
         <summary>
        /// Aggiunge un oggetto a uno slot vuoto del Focus Time
        /// </summary>
        /// <param name="item">L'entità oggetto da aggiungere</param>
        /// <returns>L'indice dello slot assegnato, o -1 se non è stato possibile aggiungere l'oggetto</returns>

        public int AddItem(Entity item);
         <summary>
        /// Rimuove un oggetto dagli slot del Focus Time
        /// </summary>
        /// <param name="slotIndex">L'indice dello slot da cui rimuovere l'oggetto</param>
        /// <returns>L'entità oggetto rimossa, o Entity.Null se lo slot era già vuoto</returns>

        public Entity RemoveItem(int slotIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/TutorialComponents.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Informazioni aggiuntive sul livello tutorial
    /// </summary>

    public struct TutorialLevelInfoComponent : IComponentData
    {
        public FixedString128Bytes Description;
        public int Difficulty;
        public bool IsLastTutorial;
    }
     <summary>
    /// Buffer di scenari di insegnamento per un livello tutorial
    /// </summary>

    public struct TutorialScenarioBuffer : IBufferElementData
    {
        public FixedString64Bytes Name;
        public float DistanceFromStart;
        public FixedString128Bytes InstructionMessage;
        public float MessageDuration;
        public bool Triggered;
        public bool RandomPlacement;
        public float ObstacleSpacing;
    }
     <summary>
    /// Buffer per gli ostacoli in uno scenario di insegnamento
    /// </summary>

    public struct TutorialObstacleBuffer : IBufferElementData
    {
        public FixedString32Bytes ObstacleCode;
        public int Count;
        public byte Placement;
        public bool RandomizeHeight;
        public float2 HeightRange;
        public bool RandomizeScale;
        public float2 ScaleRange;
        public float StartOffset;
    }
     <summary>
    /// Riferimento allo scenario di insegnamento
    /// </summary>

    public struct ScenarioReference : IComponentData
    {
        public Entity TutorialLevelEntity;
        public int ScenarioIndex;
    }
     <summary>
    /// Componente per tracciare il progresso del giocatore nei tutorial
    /// </summary>

    public struct TutorialProgressComponent : IComponentData
    {
        public int CompletedTutorialCount;
        public int HighestUnlockedTutorial;
        public bool TutorialsCompleted;
    }
     <summary>
    /// Tag interno per identificare il completamento di un livello tutorial
    /// </summary>

    public struct TutorialCompletionTag : IComponentData
    {
        public int CompletedTutorialIndex;
    }
     <summary>
    /// Evento generato quando viene completato un tutorial
    /// </summary>

    public struct TutorialFinishedEvent : IComponentData
    {
        public int CompletedTutorialIndex;
        public bool AllTutorialsCompleted;
        public int NextTutorialToUnlock;
    }
     <summary>
    /// Tag per identificare uno scenario di insegnamento che è pronto per essere attivato
    /// </summary>

    public struct ScenarioActivationTag : IComponentData
    {
        public Entity ScenarioEntity;
        public int ScenarioIndex;
        public float ActivationTime;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/EnvironmentalEffectComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// 
    /// </summary>

    public struct EnvironmentalEffectComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/CollectibleComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// 
    /// </summary>

    public struct CollectibleComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/FragmentResonanceComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce la meccanica "Risonanza dei Frammenti",
    /// permettendo ai giocatori di cambiare personaggio istantaneamente durante il gameplay.
    /// </summary>

    public struct FragmentResonanceComponent : IComponentData
    {
        public Entity ActiveCharacter;
        public FixedList128Bytes<Entity> UnlockedCharacters;
        public int CharacterCount;
        public bool IsUnlocked;
        public int ResonanceLevel;
        public float Cooldown;
        public float CooldownRemaining;
        public float FocusTimeCost;
        public float InvulnerabilityDuration;
        public float EnergyWaveRadius;
        public float EnergyWaveDamage;
        public bool IsAvailable { ... }
         <summary>
        /// Crea un nuovo componente FragmentResonance con valori di default
        /// </summary>
        /// <param name="initialCharacter">Personaggio iniziale (Alex)</param>
        /// <returns>Componente inizializzato</returns>

        public static FragmentResonanceComponent Default(Entity initialCharacter);
         <summary>
        /// Aggiorna i timer della Risonanza
        /// </summary>
        /// <param name="deltaTime">Tempo trascorso dall'ultimo frame</param>
        /// <returns>True se lo stato è cambiato (cooldown completato), false altrimenti</returns>

        public bool Update(float deltaTime);
         <summary>
        /// Cambia il personaggio attivo
        /// </summary>
        /// <param name="characterIndex">Indice del personaggio da attivare</param>
        /// <returns>True se il cambio è riuscito, false altrimenti</returns>

        public bool SwitchCharacter(int characterIndex);
         <summary>
        /// Aggiunge un nuovo personaggio alla Risonanza
        /// </summary>
        /// <param name="characterEntity">Entità del personaggio da aggiungere</param>
        /// <returns>True se il personaggio è stato aggiunto, false se già presente o lista piena</returns>

        public bool AddCharacter(Entity characterEntity);
         <summary>
        /// Ottiene i bonus ambientali in base al tipo di mondo e al personaggio
        /// </summary>
        /// <param name="worldType">Il tipo di mondo corrente</param>
        /// <returns>Struttura contenente i bonus applicabili</returns>

        public EnvironmentalBonus GetEnvironmentalBonus(WorldType worldType);
         <summary>
        /// Riduce il cooldown della Risonanza tramite oggetti o abilità
        /// </summary>
        /// <param name="reductionAmount">Quantità di riduzione in secondi</param>

        public void ReduceCooldown(float reductionAmount);
    }
     <summary>
    /// Struttura che definisce i bonus ambientali applicati durante la Risonanza
    /// </summary>

    public struct EnvironmentalBonus
    {
        public float SpeedBonus;
        public float JumpBonus;
        public float HealingEfficiency;
        public float ElementalResistance;
        public float CooldownReduction;
    }
     <summary>
    /// Evento generato quando un personaggio viene cambiato con la Risonanza
    /// </summary>

    public struct CharacterSwitchedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity PreviousCharacter;
        public Entity NewCharacter;
        public float3 Position;
        public float3 Velocity;
        public WorldType WorldType;
        public EnvironmentalBonus AppliedBonus;
    }
     <summary>
    /// Evento generato quando un personaggio viene sbloccato
    /// </summary>

    public struct CharacterUnlockedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity UnlockedCharacter;
        public int TotalCharacters;
    }
     <summary>
    /// Evento generato quando la Risonanza viene sbloccata
    /// </summary>

    public struct ResonanceUnlockedEvent : IComponentData
    {
        public Entity PlayerEntity;
    }
     <summary>
    /// Evento generato quando il livello di Risonanza aumenta
    /// </summary>

    public struct ResonanceUpgradedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public int PreviousLevel;
        public int NewLevel;
    }
     <summary>
    /// Evento generato quando la Risonanza è di nuovo disponibile dopo il cooldown
    /// </summary>

    public struct ResonanceReadyEvent : IComponentData
    {
        public Entity PlayerEntity;
    }
     <summary>
    /// Evento generato quando l'onda di energia della Risonanza viene emessa
    /// </summary>

    public struct EnergyWaveEvent : IComponentData
    {
        public float3 Origin;
        public float Radius;
        public float Damage;
        public Entity SourceEntity;
    }
     <summary>
    /// Evento generato quando si attivano abilità combinate (Risonanza Totale)
    /// </summary>

    public struct CombinedAbilitiesEvent : IComponentData
    {
        public Entity PrimaryCharacter;
        public Entity SecondaryCharacter;
        public float Duration;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/HealthComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce la salute di un'entità, inclusi punti vita attuali, massimi,
    /// stato di invulnerabilità e rigenerazione. Utilizzato sia per il giocatore che per i nemici.
    /// </summary>

    public struct HealthComponent : IComponentData
    {
        public float CurrentHealth;
        public float MaxHealth;
        public bool IsInvulnerable;
        public float InvulnerabilityTime;
        public float RegenRate;
        public bool IsRegenerating;
        public bool IsDead { ... }
        public float HealthPercentage { ... }
         <summary>
        /// Crea un nuovo HealthComponent con valori predefiniti
        /// </summary>
        /// <param name="maxHealth">Punti vita massimi</param>
        /// <returns>HealthComponent inizializzato con i valori specificati</returns>

        public static HealthComponent Default(float maxHealth);
         <summary>
        /// Applica danni all'entità, tenendo conto dell'invulnerabilità
        /// </summary>
        /// <param name="damage">Quantità di danno da applicare</param>
        /// <returns>Danno effettivamente applicato</returns>

        public float ApplyDamage(float damage);
         <summary>
        /// Ripristina salute all'entità
        /// </summary>
        /// <param name="amount">Quantità di salute da ripristinare</param>
        /// <returns>Salute effettivamente ripristinata</returns>

        public float Heal(float amount);
         <summary>
        /// Attiva l'invulnerabilità per un periodo di tempo specificato
        /// </summary>
        /// <param name="duration">Durata dell'invulnerabilità in secondi</param>

        public void SetInvulnerable(float duration);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/MovementComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce i parametri di movimento di un'entità,
    /// inclusi velocità, salto, scivolata e altri attributi di movimento.
    /// </summary>

    public struct MovementComponent : IComponentData
    {
        public float BaseSpeed;
        public float CurrentSpeed;
        public float MaxSpeed;
        public float Acceleration;
        public float JumpForce;
        public int MaxJumps;
        public int RemainingJumps;
        public bool IsJumping;
        public float SlideDuration;
        public float SlideTimeRemaining;
        public bool IsSliding;
        public float SlideSpeedMultiplier;
        public bool IsMoving;
        public float3 MoveDirection;
         <summary>
        /// Genera un MovementComponent con valori di default per un personaggio giocabile
        /// </summary>

        public static MovementComponent DefaultPlayer();
         <summary>
        /// Inizia un salto, se possibile
        /// </summary>
        /// <returns>True se il salto è stato avviato, false altrimenti</returns>

        public bool TryJump();
         <summary>
        /// Inizia una scivolata, se possibile
        /// </summary>
        /// <returns>True se la scivolata è stata avviata, false altrimenti</returns>

        public bool TrySlide();
         <summary>
        /// Reimposta i salti disponibili quando il personaggio tocca terra
        /// </summary>

        public void ResetJumps();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ObstacleComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che rappresenta un ostacolo nel gioco.
    /// Contiene proprietà come dimensioni, resistenza e danno causato.
    /// </summary>

    public struct ObstacleComponent : IComponentData
    {
        public float Height;
        public float Width;
        public float CollisionRadius;
        public float Strength;
        public float DamageValue;
        public bool IsDestructible;
         <summary>
        /// Crea un nuovo ObstacleComponent con valori predefiniti per un ostacolo piccolo
        /// </summary>

        public static ObstacleComponent CreateSmall();
         <summary>
        /// Crea un nuovo ObstacleComponent con valori predefiniti per un ostacolo medio
        /// </summary>

        public static ObstacleComponent CreateMedium();
         <summary>
        /// Crea un nuovo ObstacleComponent con valori predefiniti per un ostacolo grande
        /// </summary>

        public static ObstacleComponent CreateLarge();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ProgressionComponents.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente principale per tracciare la progressione globale del giocatore
    /// </summary>

    public struct PlayerProgressionComponent : IComponentData
    {
        public int CompletedTutorialCount;
        public int HighestUnlockedTutorial;
        public bool TutorialsCompleted;
        public int HighestUnlockedWorld;
        public int CurrentActiveWorld;
        public byte WorldsCompleted;
        public int TotalFragmentsCollected;
        public byte FragmentsCollectedMask;
        public int TotalStarsEarned;
        public int TotalLevelsCompleted;
        public int TotalBonusObjectivesCompleted;
        public byte UnlockedCharactersMask;
        public byte CurrentActiveCharacter;
        public long LastUpdatedTimestamp;
    }
     <summary>
    /// Componente specifico per tracciare la progressione dei tutorial
    /// </summary>

    public struct TutorialProgressionComponent : IComponentData
    {
        public int CompletedTutorialCount;
        public int HighestUnlockedTutorial;
        public bool AllTutorialsCompleted;
        public int MechanicsLearned;
        public int TutorialRetryCount;
        public float AverageTutorialCompletionTime;
    }
     <summary>
    /// Tag che identifica un livello tutorial
    /// </summary>

    public struct TutorialLevelTag : IComponentData
    {
        public int TutorialIndex;
        public bool Completed;
    }
     <summary>
    /// Tag per identificare il completamento di un tutorial
    /// </summary>

    public struct TutorialCompletedTag : IComponentData
    {
        public int CompletedTutorialIndex;
    }
     <summary>
    /// Evento generato quando viene completato un tutorial
    /// </summary>

    public struct TutorialCompletionEvent : IComponentData
    {
        public int CompletedTutorialIndex;
        public bool AllTutorialsCompleted;
        public int NextTutorialToUnlock;
        public float CompletionTime;
    }
     <summary>
    /// Componente per tracciare la progressione all'interno di un mondo
    /// </summary>

    public struct WorldProgressionComponent : IComponentData
    {
        public int WorldIndex;
        public FixedString32Bytes WorldName;
        public byte CompletedLevelsBitmap;
        public byte FullyCompletedLevelsBitmap;
        public byte UnlockedLevelsBitmap;
        public bool IsFragmentCollected;
        public bool IsBossDefeated;
        public byte CollectiblesMask;
        public int TotalStarsInWorld;
        public int StarsCollected;
        public byte DifficultyLevel;
    }
     <summary>
    /// Tag che identifica un mondo di gioco
    /// </summary>

    public struct WorldTag : IComponentData
    {
        public int WorldIndex;
        public bool IsActive;
    }
     <summary>
    /// Evento generato quando viene completato un mondo intero
    /// </summary>

    public struct WorldCompletionEvent : IComponentData
    {
        public int WorldIndex;
        public bool IsFullyCompleted;
        public int NextWorldToUnlock;
        public int FragmentIndex;
        public int CharacterUnlocked;
    }
     <summary>
    /// Tag per identificare lo sblocco di un nuovo mondo
    /// </summary>

    public struct WorldUnlockedTag : IComponentData
    {
        public int WorldIndex;
    }
     <summary>
    /// Componente per tracciare la progressione all'interno di un livello
    /// </summary>

    public struct LevelProgressionComponent : IComponentData
    {
        public int WorldIndex;
        public int LevelIndex;
        public byte StarCount;
        public bool IsCompleted;
        public bool IsBonusObjectiveCompleted;
        public bool AreAllCollectiblesFound;
        public float BestCompletionTime;
        public int AttemptCount;
        public byte TreasuresFound;
        public long LastPlayedTimestamp;
    }
     <summary>
    /// Tag che identifica un livello di gioco
    /// </summary>

    public struct LevelTag : IComponentData
    {
        public int WorldIndex;
        public int LevelIndex;
        public FixedString64Bytes LevelName;
        public bool IsActive;
    }
     <summary>
    /// Evento generato quando viene completato un livello
    /// </summary>

    public struct LevelCompletionEvent : IComponentData
    {
        public int WorldIndex;
        public int LevelIndex;
        public byte StarsEarned;
        public bool BonusObjectiveCompleted;
        public float CompletionTime;
        public int CollectiblesFound;
        public int TreasuresFound;
        public bool IsNewHighScore;
    }
     <summary>
    /// Evento che notifica avanzamento nella progressione generale
    /// </summary>

    public struct ProgressionAdvancementEvent : IComponentData
    {
        public byte ProgressionType;
        public int PrimaryIndex;
        public int SecondaryIndex;
        public int ValueChanged;
        public bool IsSignificantAdvancement;
    }
     <summary>
    /// Evento che notifica lo sblocco di un nuovo elemento
    /// </summary>

    public struct UnlockEvent : IComponentData
    {
        public byte UnlockType;
        public int UnlockedItemIndex;
        public FixedString64Bytes UnlockedItemName;
    }
     <summary>
    /// Evento che notifica il salvataggio dei dati di progressione
    /// </summary>

    public struct ProgressionSaveEvent : IComponentData
    {
        public bool IsAutosave;
        public long Timestamp;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/EmberComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Ember, la sopravvissuta dell'inferno di lava.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Corpo Ignifugo
    /// e la sua resistenza agli ambienti vulcanici.
    /// </summary>

    public struct EmberComponent : IComponentData
    {
        public float HeatResistance;
        public float FireDamageReduction;
        public float ToxicGasResistance;
        public float ExplosionResistance;
        public float MagmaPathfinding;
        public float EruptionSense;
        public float CoolantEfficiency;
        public float AshVision;
         <summary>
        /// Crea un nuovo componente Ember con valori di default
        /// </summary>
        /// <returns>Componente EmberComponent inizializzato</returns>

        public static EmberComponent Default();
         <summary>
        /// Versione potenziata di Ember (livello medio)
        /// </summary>

        public static EmberComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Ember (fine gioco)
        /// </summary>

        public static EmberComponent Master();
         <summary>
        /// Calcola la riduzione del danno da fuoco
        /// </summary>
        /// <param name="fireDamage">Danno da fuoco base</param>
        /// <returns>Danno da fuoco ridotto</returns>

        public float ReduceFireDamage(float fireDamage);
         <summary>
        /// Calcola l'efficacia aumentata degli oggetti raffreddanti
        /// </summary>
        /// <param name="baseDuration">Durata base dell'oggetto raffreddante</param>
        /// <returns>Durata aumentata</returns>

        public float EnhanceCoolantDuration(float baseDuration);
         <summary>
        /// Verifica se Ember può prevedere un'eruzione imminente
        /// </summary>
        /// <returns>True se prevede un'eruzione, false altrimenti</returns>

        public bool DetectEruption();
         <summary>
        /// Calcola la riduzione del danno da gas tossici
        /// </summary>
        /// <param name="toxicDamage">Danno da gas tossico base</param>
        /// <returns>Danno da gas tossico ridotto</returns>

        public float ReduceToxicGasDamage(float toxicDamage);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/MayaComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Maya, l'esploratrice della foresta primordiale.
    /// Contiene attributi e bonus specifici per questo personaggio, in particolare
    /// quelli legati alla sua abilità Richiamo della Natura e la sua affinità
    /// con l'ambiente naturale.
    /// </summary>

    public struct MayaComponent : IComponentData
    {
        public float NaturalRegeneration;
        public float PoisonResistance;
        public float ForestVision;
        public float WildlifeAffinity;
        public float HerbKnowledge;
        public float TreeClimbingAbility;
        public float StealthInNature;
        public float BushTraversalSpeed;
         <summary>
        /// Crea un nuovo componente Maya con valori di default
        /// </summary>
        /// <returns>Componente MayaComponent inizializzato</returns>

        public static MayaComponent Default();
         <summary>
        /// Versione potenziata di Maya (livello medio)
        /// </summary>

        public static MayaComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Maya (fine gioco)
        /// </summary>

        public static MayaComponent Master();
         <summary>
        /// Calcola il bonus di guarigione basato sulla conoscenza delle erbe
        /// </summary>
        /// <param name="baseHealAmount">Quantità base di guarigione</param>
        /// <returns>Quantità di guarigione potenziata</returns>

        public float ApplyHerbKnowledgeBonus(float baseHealAmount);
         <summary>
        /// Calcola la riduzione del danno da veleno
        /// </summary>
        /// <param name="poisonDamage">Danno da veleno base</param>
        /// <returns>Danno da veleno ridotto</returns>

        public float ReducePoisonDamage(float poisonDamage);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/PlayerDataComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente che memorizza i dati comuni a tutti i personaggi giocabili.
    /// Contiene informazioni generali come il tipo di personaggio, il livello di sbloccamento,
    /// e le statistiche base condivise tra tutti i personaggi.
    /// </summary>

    public struct PlayerDataComponent : IComponentData
    {
        public CharacterType Type;
        public FixedString64Bytes Name;
        public int UnlockLevel;
        public bool IsUnlocked;
        public int ExperienceLevel;
        public int CurrentExperience;
        public int ExperienceToNextLevel;
        public float StatMultiplier;
        public int FragmentID;
        public int FragmentPowerLevel;
        public WorldType NativeWorldType;
         <summary>
        /// Costruttore di base per un personaggio
        /// </summary>
        /// <param name="type">Tipo di personaggio</param>
        /// <param name="name">Nome del personaggio</param>
        /// <param name="worldType">Tipo di mondo associato</param>
        /// <returns>Un nuovo componente PlayerData inizializzato</returns>

        public static PlayerDataComponent Create(CharacterType type, string name, WorldType worldType);
         <summary>
        /// Aggiunge esperienza al personaggio e gestisce l'aumento di livello
        /// </summary>
        /// <param name="expAmount">Quantità di esperienza guadagnata</param>
        /// <returns>True se il personaggio è salito di livello, false altrimenti</returns>

        public bool AddExperience(int expAmount);
         <summary>
        /// Aumenta il livello di potere del frammento
        /// </summary>
        /// <returns>True se il potenziamento è stato applicato, false se già al massimo</returns>

        public bool UpgradeFragment();
    }
     <summary>
    /// Tipi di personaggi disponibili nel gioco
    /// </summary>

    public enum CharacterType
    {
        Alex = 0,
        Maya = 1,
        Kai = 2,
        Ember = 3,
        Marina = 4,
        Neo = 5
    }
     <summary>
    /// Tipi di mondo nel gioco
    /// </summary>

    public enum WorldType
    {
        None = 0,
        Urban = 1,
        Forest = 2,
        Tundra = 3,
        Volcano = 4,
        Abyss = 5,
        Virtual = 6
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/KaiComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Kai, l'alpinista della tundra eterna.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Aura di Calore
    /// e la sua resistenza agli ambienti freddi.
    /// </summary>

    public struct KaiComponent : IComponentData
    {
        public float ColdResistance;
        public float IceGrip;
        public float StaminaBonus;
        public float ClimbingAbility;
        public float IceAnalysis;
        public float AvalancheAwareness;
        public float BlizzardVision;
        public float HeatRetention;
         <summary>
        /// Crea un nuovo componente Kai con valori di default
        /// </summary>
        /// <returns>Componente KaiComponent inizializzato</returns>

        public static KaiComponent Default();
         <summary>
        /// Versione potenziata di Kai (livello medio)
        /// </summary>

        public static KaiComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Kai (fine gioco)
        /// </summary>

        public static KaiComponent Master();
         <summary>
        /// Calcola la riduzione del danno da freddo
        /// </summary>
        /// <param name="coldDamage">Danno da freddo base</param>
        /// <returns>Danno da freddo ridotto</returns>

        public float ReduceColdDamage(float coldDamage);
         <summary>
        /// Calcola il modificatore di scivolamento su ghiaccio
        /// </summary>
        /// <param name="baseSlipperiness">Scivolosità base della superficie</param>
        /// <returns>Scivolosità ridotta</returns>

        public float CalculateIceSlip(float baseSlipperiness);
         <summary>
        /// Verifica se Kai rileva ghiaccio debole
        /// </summary>
        /// <returns>True se rileva un punto debole, false altrimenti</returns>

        public bool DetectWeakIce();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/MarinaComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Marina, la biologa degli abissi inesplorati.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Bolla d'Aria
    /// e la sua adattabilità agli ambienti acquatici.
    /// </summary>

    public struct MarinaComponent : IComponentData
    {
        public float SwimSpeed;
        public float WaterBreathing;
        public float PressureResistance;
        public float UnderwaterVision;
        public float ElectricResistance;
        public float MarineEmpathy;
        public float UnderwaterAgility;
        public float ToxinResistance;
         <summary>
        /// Crea un nuovo componente Marina con valori di default
        /// </summary>
        /// <returns>Componente MarinaComponent inizializzato</returns>

        public static MarinaComponent Default();
         <summary>
        /// Versione potenziata di Marina (livello medio)
        /// </summary>

        public static MarinaComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Marina (fine gioco)
        /// </summary>

        public static MarinaComponent Master();
         <summary>
        /// Calcola la velocità di nuoto effettiva basata sulle condizioni
        /// </summary>
        /// <param name="baseSpeed">Velocità base di movimento</param>
        /// <param name="waterDensity">Densità dell'acqua (1.0 = normale)</param>
        /// <returns>Velocità di nuoto calcolata</returns>

        public float CalculateSwimSpeed(float baseSpeed, float waterDensity);
         <summary>
        /// Calcola il tasso di consumo di ossigeno
        /// </summary>
        /// <param name="baseConsumption">Consumo base di ossigeno</param>
        /// <param name="depth">Profondità attuale (influenza il consumo)</param>
        /// <returns>Tasso di consumo ossigeno ridotto</returns>

        public float CalculateOxygenConsumption(float baseConsumption, float depth);
         <summary>
        /// Calcola la riduzione del danno da pressione
        /// </summary>
        /// <param name="pressureDamage">Danno da pressione base</param>
        /// <returns>Danno da pressione ridotto</returns>

        public float ReducePressureDamage(float pressureDamage);
         <summary>
        /// Calcola la riduzione del danno elettrico
        /// </summary>
        /// <param name="electricDamage">Danno elettrico base</param>
        /// <returns>Danno elettrico ridotto</returns>

        public float ReduceElectricDamage(float electricDamage);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/AlexComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Alex, il corriere urbano.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare legati alla sua abilità Scatto Urbano e la sua
    /// maestria nell'ambiente urbano.
    /// </summary>

    public struct AlexComponent : IComponentData
    {
        public float UrbanParkourBonus;
        public float SlideSpeedBonus;
        public bool WallRunEnabled;
        public float MaxWallRunTime;
        public float WallRunTimeRemaining;
        public bool RailGrindEnabled;
        public float RailGrindSpeedBonus;
        public float UrbanJumpBonus;
        public bool DoubleJumpEnabled;
        public float UrbanDashCooldownReduction;
        public float UrbanObstacleDamageReduction;
        public float ObstacleBreakThroughBonus;
        public float UrbanNightVisionBonus;
         <summary>
        /// Crea un nuovo componente Alex con valori di default
        /// </summary>
        /// <returns>Componente AlexComponent inizializzato</returns>

        public static AlexComponent Default();
         <summary>
        /// Versione potenziata di Alex (livello medio)
        /// </summary>

        public static AlexComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Alex (fine gioco)
        /// </summary>

        public static AlexComponent Master();
         <summary>
        /// Ripristina il tempo di wall-run al massimo
        /// </summary>

        public void ResetWallRunTime();
         <summary>
        /// Consuma tempo di wall-run
        /// </summary>
        /// <param name="deltaTime">Tempo trascorso dall'ultimo frame</param>
        /// <returns>True se il wall-run è ancora attivo, false se il tempo è esaurito</returns>

        public bool ConsumeWallRunTime(float deltaTime);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/NeoComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Neo, l'hacker della realtà virtuale.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Glitch Controllato
    /// e la sua capacità di manipolare l'ambiente digitale.
    /// </summary>

    public struct NeoComponent : IComponentData
    {
        public float CodeSight;
        public float DataCorruptionResistance;
        public float GlitchManipulation;
        public float HackingEfficiency;
        public float FirewallBypass;
        public float SystemRestoration;
        public float DataTransferSpeed;
        public float MalwareImmunity;
         <summary>
        /// Crea un nuovo componente Neo con valori di default
        /// </summary>
        /// <returns>Componente NeoComponent inizializzato</returns>

        public static NeoComponent Default();
         <summary>
        /// Versione potenziata di Neo (livello medio)
        /// </summary>

        public static NeoComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Neo (fine gioco)
        /// </summary>

        public static NeoComponent Master();
         <summary>
        /// Calcola la probabilità di individuare un glitch nascosto
        /// </summary>
        /// <param name="glitchHiddenFactor">Fattore di occultamento del glitch (0-1)</param>
        /// <returns>True se il glitch è individuato, false altrimenti</returns>

        public bool DetectHiddenGlitch(float glitchHiddenFactor);
         <summary>
        /// Calcola la riduzione del danno da corruzione dati
        /// </summary>
        /// <param name="corruptionDamage">Danno da corruzione base</param>
        /// <returns>Danno da corruzione ridotto</returns>

        public float ReduceCorruptionDamage(float corruptionDamage);
         <summary>
        /// Calcola la probabilità di bypassare un firewall
        /// </summary>
        /// <param name="firewallStrength">Forza del firewall (0-1)</param>
        /// <returns>True se il bypass ha successo, false altrimenti</returns>

        public bool BypassFirewall(float firewallStrength);
         <summary>
        /// Calcola la velocità effettiva nei data stream
        /// </summary>
        /// <param name="baseSpeed">Velocità base di movimento</param>
        /// <returns>Velocità potenziata nei data stream</returns>

        public float CalculateDataStreamSpeed(float baseSpeed);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/EnemyComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct EnemyComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/DroneComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct DroneComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/MidBossComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct MidBossComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/AIStateComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct AIStateComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/AttackComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct AttackComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/PatrolComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct PatrolComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/BossComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct BossComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/GameplayEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// 
    /// </summary>

    public partial class GameplayEventHandler : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/DamageEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// 
    /// </summary>

    public partial class DamageEventHandler : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/CollisionEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// 
    /// </summary>

    public partial class CollisionEventHandler : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/UIEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// 
    /// </summary>

    public partial class UIEventHandler : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/LevelCompletedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct LevelCompletedEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/CollisionEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct CollisionEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/ObstacleInteractionEvent.cs

namespace RunawayHeroes.ECS.Events.EventDefinitions
{
     <summary>
    /// Evento per l'attraversamento della lava
    /// </summary>

    public struct LavaWalkingEvent : IComponentData
    {
        public Entity EntityID;
        public float3 Position;
    }
     <summary>
    /// Evento per l'inizio del teletrasporto tramite Glitch
    /// </summary>

    public struct GlitchTeleportStartEvent : IComponentData
    {
        public Entity EntityID;
        public float3 StartPosition;
        public float3 TargetPosition;
        public Entity BarrierEntity;
    }
     <summary>
    /// Evento per la fine del teletrasporto tramite Glitch
    /// </summary>

    public struct GlitchTeleportEndEvent : IComponentData
    {
        public Entity EntityID;
        public float3 FinalPosition;
    }
     <summary>
    /// Evento per la repulsione di un nemico
    /// </summary>

    public struct EnemyRepulsionEvent : IComponentData
    {
        public Entity EnemyEntity;
        public Entity SourceEntity;
        public float RepulsionForce;
        public float3 Direction;
    }
     <summary>
    /// Evento per lo scioglimento completo di un ostacolo di ghiaccio
    /// </summary>

    public struct IceMeltedEvent : IComponentData
    {
        public Entity SourceEntity;
        public Entity IceEntity;
        public float3 Position;
        public float Size;
    }
     <summary>
    /// Evento per l'interazione con superfici scivolose
    /// </summary>

    public struct SlipInteractionEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity SurfaceEntity;
        public float EffectiveSlipFactor;
        public bool IsNegated;
    }
     <summary>
    /// Evento per l'interazione con correnti (aria/acqua)
    /// </summary>

    public struct CurrentInteractionEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity CurrentEntity;
        public float EffectiveForce;
        public float3 Direction;
        public bool IsNegated;
    }
     <summary>
    /// Evento per l'interazione con zone prive di ossigeno
    /// </summary>

    public struct OxygenInteractionEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity NoOxygenZoneEntity;
        public float RemainingOxygen;
        public bool IsNegated;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/FragmentCollectedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct FragmentCollectedEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/CharacterSwitchEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct CharacterSwitchEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/FocusTimeEvents.cs

namespace RunawayHeroes.ECS.Events.EventDefinitions
{
     <summary>
    /// Evento generato quando il Focus Time viene attivato
    /// </summary>

    public struct FocusTimeActivatedEvent : IComponentData
    {
        public Entity EntityActivated;
        public float Duration;
        public float TimeScale;
    }
     <summary>
    /// Evento generato quando il Focus Time viene disattivato
    /// </summary>

    public struct FocusTimeDeactivatedEvent : IComponentData
    {
        public Entity EntityDeactivated;
        public float CooldownRemaining;
    }
     <summary>
    /// Evento generato quando il Focus Time è pronto dopo un cooldown
    /// </summary>

    public struct FocusTimeReadyEvent : IComponentData
    {
        public Entity EntityReady;
    }
     <summary>
    /// Evento generato quando l'energia del Focus Time è completamente ricaricata
    /// </summary>

    public struct FocusTimeFullEnergyEvent : IComponentData
    {
        public Entity EntityWithFullEnergy;
    }
     <summary>
    /// Evento generato quando un oggetto viene aggiunto a uno slot del Focus Time
    /// </summary>

    public struct ItemAddedToSlotEvent : IComponentData
    {
        public Entity UserEntity;
        public Entity ItemEntity;
        public int SlotIndex;
    }
     <summary>
    /// Evento generato quando un oggetto viene utilizzato durante il Focus Time
    /// </summary>

    public struct ItemUsedEvent : IComponentData
    {
        public Entity UserEntity;
        public Entity ItemEntity;
        public int SlotIndex;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/MomentEvents.cs

namespace RunawayHeroes.ECS.Events.EventDefinitions
{
     <summary>
    /// Evento generato quando un personaggio inizia a saltare
    /// </summary>

    public struct JumpStartedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float JumpForce;
        public int RemainingJumps;
        public float3 JumpPosition;
    }
     <summary>
    /// Evento generato quando un personaggio atterra
    /// </summary>

    public struct LandingEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float LandingVelocity;
        public float3 LandingPosition;
        public bool IsHardLanding;
    }
     <summary>
    /// Evento generato quando un personaggio inizia a scivolare
    /// </summary>

    public struct SlideStartedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float Duration;
        public float3 StartPosition;
        public float InitialSpeed;
    }
     <summary>
    /// Evento generato quando un personaggio termina una scivolata
    /// </summary>

    public struct SlideEndedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float3 EndPosition;
        public float SlideDistance;
        public float ActualDuration;
    }
     <summary>
    /// Evento generato quando un personaggio inizia a muoversi
    /// </summary>

    public struct MovementStartedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float3 StartPosition;
        public float3 InitialDirection;
    }
     <summary>
    /// Evento generato quando un personaggio smette di muoversi
    /// </summary>

    public struct MovementStoppedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float3 StopPosition;
        public float3 FinalVelocity;
    }
     <summary>
    /// Evento generato quando cambia lo stato di animazione
    /// </summary>

    public struct AnimationStateChangedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public MovementAnimationState State;
        public float Speed;
        public float BlendFactor;
    }
     <summary>
    /// Evento generato quando il personaggio urta un ostacolo
    /// </summary>

    public struct ObstacleHitEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity ObstacleEntity;
        public float3 ImpactPosition;
        public float3 ImpactNormal;
        public float ImpactVelocity;
        public float DamageAmount;
    }
     <summary>
    /// Enumerazione degli stati di animazione per il movimento
    /// </summary>

    public enum MovementAnimationState
    {
        Idle = 0,
        Run = 1,
        Jump = 2,
        Fall = 3,
        Slide = 4,
        Land = 5,
        Hit = 6,
        Ability = 7
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/AbilityActivatedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un'abilità viene attivata
    /// </summary>

    public struct AbilityActivatedEvent : IComponentData
    {
        public Entity EntityID;
        public AbilityType AbilityType;
        public float3 Position;
        public float Duration;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/EnemyDefeatedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct EnemyDefeatedEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/CheckpointReachedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct CheckpointReachedEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/DamageEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct DamageEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/FocusTimeUISystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce l'interfaccia utente per il Focus Time,
    /// visualizzando la barra di energia, il cooldown e l'interfaccia radiale per gli oggetti.
    /// </summary>

    public partial class FocusTimeUISystem : SystemBase
    {
        private RectTransform _focusTimeEnergyBar;
        private RectTransform _focusTimeCooldownIndicator;
        private GameObject _radialMenuContainer;
        private RectTransform[] _itemSlots;
        private GameObject _timeScaleEffect;
        private float _pulseAnimationTime;
        private const float PULSE_SPEED;
        private const float PULSE_AMPLITUDE;
        private EntityQuery _playerFocusTimeQuery;
        protected override void OnCreate();
        protected override void OnStartRunning();
        protected override void OnUpdate();
        private void PlayFocusTimeActivationEffects();
        private void PlayFocusTimeDeactivationEffects();
        private void PlayFocusTimeReadyEffects();
        private void PlayItemUsedEffects(int slotIndex);
        private System.Collections.IEnumerator ResetSlotScale(int slotIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/UIMessageSystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce la visualizzazione dei messaggi UI nel gioco,
    /// inclusi i messaggi di istruzione del tutorial, notifiche e avvisi.
    /// </summary>

    public partial class UIMessageSystem : ISystem
    {
        private GameObject _messagePanel;
        private TextMeshProUGUI _messageText;
        private Animator _messageAnimator;
        private Image _backgroundImage;
        private readonly Color[] _messageTypeColors;
        private bool _isMessageVisible;
        private float _messageTimer;
        private Entity _currentMessageEntity;
        private Queue<Entity> _messageQueue;
        private const float FADE_IN_TIME;
        private const float FADE_OUT_TIME;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnStartRunning(SystemState state);
         <summary>
        /// Crea dinamicamente un pannello per i messaggi se non esiste già
        /// </summary>

        private void CreateMessagePanelDynamically(Transform parentTransform);
        public void OnUpdate(SystemState state);
         <summary>
        /// Processa nuovi messaggi aggiunti al sistema
        /// </summary>

        private void ProcessNewMessages(SystemState state);
         <summary>
        /// Aggiorna lo stato del messaggio correntemente visualizzato
        /// </summary>

        private void UpdateCurrentMessage(SystemState state);
         <summary>
        /// Mostra il prossimo messaggio nella coda
        /// </summary>

        private void ShowNextMessage(SystemState state);
         <summary>
        /// Processa eventi relativi ai messaggi
        /// </summary>

        private void ProcessMessageEvents(SystemState state);
         <summary>
        /// Mostra il pannello dei messaggi con animazione
        /// </summary>

        private void ShowMessage();
         <summary>
        /// Nasconde il pannello dei messaggi con animazione
        /// </summary>

        private void HideCurrentMessage();
        private System.Collections.IEnumerator FadeIn(CanvasGroup canvasGroup);
        private System.Collections.IEnumerator FadeOut(CanvasGroup canvasGroup, GameObject panel);
        private System.Collections.IEnumerator DisableAfterDelay(GameObject obj, float delay);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/ObjectiveFeedbackSystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce il feedback visivo per gli obiettivi tutorial.
    /// Mostra gli obiettivi correnti, aggiorna l'interfaccia e fornisce feedback al completamento.
    /// </summary>

    public partial class ObjectiveFeedbackSystem : SystemBase
    {
        private GameObject _objectivesPanel;
        private RectTransform _objectivesContainer;
        private Dictionary<int, GameObject> _activeObjectiveItems;
        private GameObject _objectiveItemPrefab;
        private EntityQuery _activeObjectivesQuery;
        protected override void OnCreate();
        protected override void OnStartRunning();
        protected override void OnUpdate();
         <summary>
        /// Inizializza i riferimenti all'interfaccia utente
        /// </summary>

        private void InitializeUIReferences();
         <summary>
        /// Crea dinamicamente un pannello per gli obiettivi
        /// </summary>

        private void CreateObjectivesPanelDynamically();
         <summary>
        /// Crea un prefab base per gli elementi obiettivo
        /// </summary>

        private GameObject CreateObjectiveItemPrefab();
         <summary>
        /// Aggiorna il pannello degli obiettivi
        /// </summary>

        private void UpdateObjectivesPanel();
         <summary>
        /// Crea un nuovo elemento UI per un obiettivo
        /// </summary>

        private GameObject CreateObjectiveItem(ObjectiveComponent objective, ObjectiveProgressComponent progress);
         <summary>
        /// Aggiorna i dati di un elemento obiettivo esistente
        /// </summary>

        private void UpdateObjectiveItem(GameObject itemObj, ObjectiveComponent objective, ObjectiveProgressComponent progress);
         <summary>
        /// Processa eventi di completamento obiettivi
        /// </summary>

        private void ProcessObjectiveCompletionEvents();
         <summary>
        /// Processa eventi di progresso obiettivi
        /// </summary>

        private void ProcessObjectiveProgressEvents();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/ResonanceUISystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce l'interfaccia utente per la Risonanza dei Frammenti,
    /// permettendo al giocatore di cambiare personaggio durante il gameplay.
    /// </summary>

    public partial class ResonanceUISystem : SystemBase
    {
        private GameObject _resonanceButton;
        private GameObject _characterMenu;
        private Button[] _characterButtons;
        private Image[] _characterButtonImages;
        private Image _resonanceButtonImage;
        private Image _cooldownOverlay;
        private GameObject _resonanceWaveEffect;
        private GameObject _resonanceUnlockEffect;
        private Sprite[] _characterSprites;
        private Text _resonanceLevelText;
        private Animator _menuAnimator;
        private bool _isMenuOpen;
        private float _menuCloseTimer;
        private float _waveEffectTimer;
        private float _unlockEffectTimer;
        private EntityQuery _resonanceQuery;
        protected override void OnCreate();
        protected override void OnStartRunning();
        protected override void OnUpdate();
         <summary>
        /// Aggiorna l'overlay del cooldown
        /// </summary>

        private void UpdateCooldownOverlay(FragmentResonanceComponent resonance);
         <summary>
        /// Aggiorna il testo del livello di risonanza
        /// </summary>

        private void UpdateResonanceLevel(FragmentResonanceComponent resonance);
         <summary>
        /// Aggiorna i timer per le animazioni
        /// </summary>

        private void UpdateTimers(float deltaTime);
         <summary>
        /// Aggiorna l'icona del personaggio attivo nel pulsante principale
        /// </summary>

        private void UpdateActiveCharacterIcon(FragmentResonanceComponent resonance);
         <summary>
        /// Aggiorna le icone e lo stato dei personaggi nel menu
        /// </summary>

        private void UpdateCharacterMenu(FragmentResonanceComponent resonance);
         <summary>
        /// Ottiene l'indice del personaggio attivo
        /// </summary>

        private int GetActiveCharacterIndex(FragmentResonanceComponent resonance);
         <summary>
        /// Attiva/disattiva il menu dei personaggi
        /// </summary>

        private void ToggleCharacterMenu();
         <summary>
        /// Gestisce la selezione di un personaggio
        /// </summary>

        private void OnCharacterSelected(int characterIndex);
         <summary>
        /// Mostra l'effetto per lo sblocco di un nuovo personaggio
        /// </summary>

        public void PlayUnlockEffect(int characterIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/RenderSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema responsabile del rendering delle entità nel mondo di gioco,
    /// gestendo la sincronizzazione tra componenti ECS e rappresentazione visiva.
    /// Gestisce aspetti come materiali, mesh, effetti visivi e visibilità delle entità.
    /// </summary>

    public partial class RenderSystem : SystemBase
    {
         <summary>
        /// Inizializza il sistema di rendering, configurando eventuali risorse grafiche condivise,
        /// shader, e query per le entità che necessitano di rendering.
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Aggiorna la rappresentazione visiva di tutte le entità con componenti di rendering,
        /// sincronizzando le loro proprietà grafiche con lo stato attuale dei componenti ECS.
        /// Gestisce ottimizzazioni come culling e level of detail.
        /// </summary>

        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/PhysicsSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema che gestisce la simulazione fisica di base per tutte le entità con componenti fisici.
    /// Si occupa di applicare gravità, aggiornare velocità e posizioni e gestire collisioni semplici.
    /// </summary>

    public partial class PhysicsSystem : SystemBase
    {
        private EntityQuery _physicsQuery;
         <summary>
        /// Inizializza il sistema e definisce le query per le entità
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Aggiorna la simulazione fisica per tutte le entità rilevanti ad ogni frame
        /// </summary>

        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/EntityLifecycleSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema che gestisce il ciclo di vita delle entità nel mondo di gioco.
    /// Responsabile della creazione, distruzione e gestione dello stato di attivazione
    /// delle entità in base a criteri come distanza dalla telecamera, tempo di vita,
    /// o eventi di gioco.
    /// </summary>

    public partial class EntityLifecycleSystem : SystemBase
    {
         <summary>
        /// Inizializza il sistema di gestione del ciclo di vita delle entità e 
        /// configura le query necessarie.
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Gestisce la creazione, distruzione e lo stato di attivazione delle entità
        /// in base a vari criteri come distanza, tempo di vita, o eventi specifici.
        /// </summary>

        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/CollisionSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema responsabile della rilevazione e gestione delle collisioni tra entità nel gioco.
    /// Integra il sistema di fisica di Unity con l'architettura ECS, gestendo interazioni
    /// tra giocatori, nemici, proiettili, ostacoli e altri elementi interattivi.
    /// </summary>

    public partial class CollisionSystem : SystemBase
    {
         <summary>
        /// Inizializza il sistema di collisione, configurando le strutture dati necessarie
        /// per la gestione efficiente delle collisioni e registrando eventuali callback.
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Rileva e gestisce le collisioni tra entità ad ogni frame, generando eventi
        /// appropriati e applicando effetti fisici come rimbalzi, danneggiamenti o trigger.
        /// Ottimizza il processo utilizzando tecniche di broad e narrow phase.
        /// </summary>

        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/TransformSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema responsabile della sincronizzazione tra TransformComponent personalizzati e 
    /// il sistema di trasformazione nativo di Unity DOTS. Gestisce posizione, rotazione e scala
    /// delle entità nel mondo di gioco.
    /// </summary>

    public partial class TransformSystem : SystemBase
    {
         <summary>
        /// Inizializza il sistema di trasformazione, configurando eventuali query di entità
        /// o dipendenze con altri sistemi.
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Aggiorna la trasformazione di tutte le entità che hanno sia un TransformComponent
        /// che le necessarie componenti di trasformazione native di Unity DOTS (come Translation,
        /// Rotation, e NonUniformScale).
        /// </summary>

        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/HitboxSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// 
    /// </summary>

    public partial class HitboxSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/KnockbackSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// 
    /// </summary>

    public partial class KnockbackSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/DamageSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// 
    /// </summary>

    public partial class DamageSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/HealthSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// 
    /// </summary>

    public partial class HealthSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Input/InputSystem.cs

namespace RunawayHeroes.ECS.Systems.Input
{
     <summary>
    /// Sistema che gestisce l'input del giocatore, elaborando i comandi
    /// da tastiera, touch o controller e aggiornando l'InputComponent.
    /// </summary>

    public partial struct InputSystem : ISystem
    {
        private EntityQuery _inputQuery;
         <summary>
        /// Inizializza il sistema e definisce le query per le entità
        /// </summary>

        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna gli input ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per aggiornare gli input del giocatore
    /// </summary>

    public partial struct UpdatePlayerInputJob : IJobEntity
    {
        public bool JumpPressed;
        public bool SlidePressed;
        public bool FocusTimePressed;
        public bool AbilityPressed;
        public bool CharacterSwitchPressed;
        public bool IsMovementEnabled;
        public float LateralMovement;
        public float2 MoveDirection;
        public bool TouchActive;
        public float2 TouchPosition;
        public float TouchDuration;
         <summary>
        /// Aggiorna il componente di input per ogni entità giocatore
        /// </summary>

        public void Execute(InputComponent input);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Input/TouchInputSystem.cs

namespace RunawayHeroes.ECS.Systems.Input
{
     <summary>
    /// 
    /// </summary>

    public partial class TouchInputSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Input/GestureRecognitionSystem.cs

namespace RunawayHeroes.ECS.Systems.Input
{
     <summary>
    /// 
    /// </summary>

    public partial class GestureRecognitionSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/ObstacleSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// 
    /// </summary>

    public partial class ObstacleSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RandomLevelGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce la generazione procedurale di livelli randomizzati
    /// in base ai parametri definiti in RandomLevelConfigComponent
    /// </summary>

    public partial struct RandomLevelGenerationSystem : ISystem
    {
        private EntityQuery _configQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per processare le configurazioni di livelli casuali
    /// </summary>

    public partial struct ProcessRandomLevelConfigsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, RandomLevelConfigComponent config, LocalTransform transform);
         <summary>
        /// Genera un livello procedurale basato sulla configurazione specificata
        /// </summary>

        private void GenerateLevel(Entity configEntity, int entityInQueryIndex, RandomLevelConfigComponent config, LocalTransform transform, Unity.Mathematics.Random random, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Crea una nuova stanza nell'ambito del livello generato
        /// </summary>

        private Entity CreateRoom(int entityInQueryIndex, RoomType type, bool isStartRoom, bool isEndRoom, Entity levelEntity, EntityCommandBuffer.ParallelWriter commandBuffer);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/LevelGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema base per la generazione di livelli che coordina sia la generazione predefinita
    /// che quella procedurale per runner
    /// </summary>

    public partial struct LevelGenerationSystem : ISystem
    {
        private EntityQuery _levelQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         <summary>
        /// Crea un'entità con configurazione per la generazione di un livello runner casuale
        /// </summary>
        /// <param name="theme">Tema del mondo da generare</param>
        /// <param name="levelLength">Lunghezza del livello in metri</param>
        /// <param name="seed">Seed per la generazione casuale</param>
        /// <param name="isTutorial">Indica se il livello è un tutorial (difficoltà ridotta)</param>

        public Entity CreateRunnerLevelRequest(SystemState state, WorldTheme theme, int levelLength, int seed, bool isTutorial);
         <summary>
        /// Ottiene un tema complementare per creare varietà nei livelli
        /// </summary>

        private static WorldTheme GetComplementaryTheme(WorldTheme primaryTheme);
    }
     <summary>
    /// Job per processare le richieste di generazione livelli predefiniti
    /// </summary>

    public partial struct ProcessLevelGenerationRequestsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, LevelComponent level, LocalTransform transform);
         <summary>
        /// Genera un livello predefinito in base ai dati di configurazione
        /// </summary>

        private void GeneratePredefinedLevel(Entity levelEntity, int entityInQueryIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/CheckpointSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// 
    /// </summary>

    public partial class CheckpointSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/ThematicObstacleGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile della generazione di ostacoli tematici nei segmenti di percorso
    /// </summary>

    public partial class ThematicObstacleGenerationSystem : SystemBase
    {
        private Unity.Mathematics.Random _random;
        private uint _seed;
        protected override void OnCreate();
        protected override void OnUpdate();
         <summary>
        /// Genera ostacoli tematici per un segmento di percorso
        /// </summary>

        private void GenerateThematicObstacles(int entityInQueryIndex, Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, ObstacleSpawnConfigComponent config, EntityCommandBuffer.ParallelWriter commandBuffer, Unity.Mathematics.Random random);
         <summary>
        /// Seleziona un codice di ostacolo appropriato per il tema e la difficoltà
        /// </summary>

        private string SelectObstacleForTheme(WorldTheme theme, int difficultyLevel, bool isTutorial, ObstacleSpawnConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Determina il tipo di contenuto del segmento in base al codice dell'ostacolo
        /// </summary>

        private SegmentContentType DetermineContentTypeFromObstacleCode(string obstacleCode);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/ObstacleSystemGroup.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che raggruppa tutti i sistemi relativi agli ostacoli
    /// </summary>

    public class ObstacleSystemGroup : ComponentSystemGroup
    {
        protected override void OnCreate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/EnvironmentalEffectSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// 
    /// </summary>

    public partial class EnvironmentalEffectSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/SegmentContentGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile della generazione dei contenuti (ostacoli, nemici, ecc.) in un segmento di percorso
    /// </summary>

    public partial class SegmentContentGenerationSystem : SystemBase
    {
        private Unity.Mathematics.Random _random;
        private uint _seed;
        protected override void OnCreate();
        protected override void OnUpdate();
         <summary>
        /// Genera ostacoli all'interno di un segmento
        /// </summary>

        private void GenerateObstacles(int entityInQueryIndex, Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, ObstacleSpawnConfigComponent config, EntityCommandBuffer.ParallelWriter commandBuffer, Unity.Mathematics.Random random);
         <summary>
        /// Aggiunge tag speciali agli ostacoli in base al tema del segmento
        /// </summary>

        private void AddSpecialObstacleTags(int entityInQueryIndex, Entity obstacleEntity, WorldTheme theme, ObstacleSpawnConfigComponent config, EntityCommandBuffer.ParallelWriter commandBuffer, Unity.Mathematics.Random random);
         <summary>
        /// Genera nemici all'interno di un segmento
        /// </summary>

        private void GenerateEnemies(int entityInQueryIndex, Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, EnemySpawnConfigComponent config, EntityCommandBuffer.ParallelWriter commandBuffer, Unity.Mathematics.Random random);
         <summary>
        /// Genera un singolo nemico nella posizione specificata
        /// </summary>

        private void SpawnEnemy(int entityInQueryIndex, Entity segmentEntity, float3 position, WorldTheme theme, DynamicBuffer<SegmentContentBuffer> contentBuffer, EnemySpawnConfigComponent config, EntityCommandBuffer.ParallelWriter commandBuffer, Unity.Mathematics.Random random);
         <summary>
        /// Genera collezionabili all'interno di un segmento
        /// </summary>

        private void GenerateCollectibles(int entityInQueryIndex, Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, EntityCommandBuffer.ParallelWriter commandBuffer, Unity.Mathematics.Random random);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RoomConnectionSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce la creazione e il collegamento di doorway tra le stanze
    /// </summary>

    public partial class RoomConnectionSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
         <summary>
        /// Crea una nuova doorway per una stanza nella direzione specificata
        /// </summary>

        private void CreateDoorway(int entityInQueryIndex, Entity roomEntity, DynamicBuffer<RoomDoorwayBuffer> doorways, DoorwayDirection direction, EntityCommandBuffer.ParallelWriter commandBuffer);
    }
     <summary>
    /// Tag component per identificare le stanze che richiedono una connessione
    /// </summary>

    public struct RequiresConnectionTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/HazardSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// 
    /// </summary>

    public partial class HazardSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RoomPopulationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile del popolamento delle stanze con nemici, collezionabili e ostacoli
    /// </summary>

    public partial struct RoomPopulationSystem : ISystem
    {
        private uint _seed;
        private EntityQuery _roomQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per popolare le stanze con contenuto
    /// </summary>

    public partial struct PopulateRoomsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public uint Seed;
        public void Execute(Entity roomEntity, int entityInQueryIndex, RoomComponent room);
         <summary>
        /// Popola una stanza con nemici, collezionabili e ostacoli in base alle probabilità specificate
        /// </summary>

        private void PopulateRoom(int entityInQueryIndex, Entity roomEntity, RoomComponent room, float enemyProbability, float collectibleProbability, float obstacleProbability, Unity.Mathematics.Random random);
         <summary>
        /// Crea un nemico nella stanza specificata
        /// </summary>

        private void CreateEnemy(int entityInQueryIndex, Entity roomEntity, RoomComponent room, Unity.Mathematics.Random random);
         <summary>
        /// Crea un oggetto collezionabile nella stanza specificata
        /// </summary>

        private void CreateCollectible(int entityInQueryIndex, Entity roomEntity, RoomComponent room, Unity.Mathematics.Random random);
         <summary>
        /// Crea un ostacolo nella stanza specificata
        /// </summary>

        private void CreateObstacle(int entityInQueryIndex, Entity roomEntity, RoomComponent room, Unity.Mathematics.Random random);
    }
     <summary>
    /// Tag component per identificare le stanze già popolate
    /// </summary>

    public struct RoomPopulatedTag : IComponentData
    {
         ref RoomComponent room;
         ref RoomComponent ;
         float enemyProbability;
         float ;
         float collectibleProbability;
         float ;
         float obstacleProbability;
         float ;
         ref EntityCommandBuffer.ParallelWriter commandBuffer;
         ref EntityCommandBuffer.ParallelWriter Unity;
         Mathematics.Random random;
         int roomArea;
         int maxEntities;
         int numEnemies;
    }
     <summary>
    /// Tag component per identificare le stanze già popolate
    /// </summary>

    public struct RoomPopulatedTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/DynamicSegmentLoadingSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce il caricamento dinamico dei segmenti del percorso
    /// man mano che il giocatore avanza nel livello
    /// </summary>

    public partial struct DynamicSegmentLoadingSystem : ISystem
    {
        private const float ACTIVATION_DISTANCE;
        private const float DEACTIVATION_DISTANCE;
        public float3 PlayerPosition;
        public float ActivationDistance;
        public float DeactivationDistance;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity segmentEntity, int chunkIndexInQuery, PathSegmentComponent segment);
    }
    private partial struct ManageSegmentActivationJob : IJobEntity
    {
        public float3 PlayerPosition;
        public float ActivationDistance;
        public float DeactivationDistance;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
         void Execute(Entity segmentEntity, int chunkIndexInQuery, PathSegmentComponent segment);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RunnerLevelGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile della generazione procedurale dei livelli per il gioco runner
    /// </summary>

    public partial struct RunnerLevelGenerationSystem : ISystem
    {
        private const float DEFAULT_SEGMENT_LENGTH;
        private EntityQuery _levelConfigQuery;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public EntityManager EntityManager;
        private const float DEFAULT_SEGMENT_LENGTH;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int entityInQueryIndex, RunnerLevelConfigComponent config, LocalTransform transform);
         <summary>
        /// Genera l'entità principale del livello
        /// </summary>

        private Entity GenerateLevel(int entityInQueryIndex, RunnerLevelConfigComponent config, int numSegments, LocalTransform transform, Unity.Mathematics.Random random);
         <summary>
        /// Genera i segmenti del percorso per il livello
        /// </summary>

        private void GeneratePathSegments(int entityInQueryIndex, Entity levelEntity, int numSegments, RunnerLevelConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Determina il tipo di segmento in base alla posizione e alla varietà richiesta
        /// </summary>

        private SegmentType DetermineSegmentType(int index, int totalSegments, float varietyFactor, Unity.Mathematics.Random random);
         <summary>
        /// Crea un segmento di percorso
        /// </summary>

        private Entity CreatePathSegment(int entityInQueryIndex, Entity levelEntity, int segmentIndex, int difficultyLevel, SegmentType type, WorldTheme theme, bool isActive, Entity prevSegment, Unity.Mathematics.Random random);
    }
     <summary>
    /// Job per elaborare le richieste di generazione livello
    /// </summary>

    public partial struct ProcessRunnerLevelRequestsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public EntityManager EntityManager;
        private const float DEFAULT_SEGMENT_LENGTH;
         void Execute(Entity entity, int entityInQueryIndex, RunnerLevelConfigComponent config, LocalTransform transform);
         <summary>
        /// Genera l'entità principale del livello
        /// </summary>

        private Entity GenerateLevel(int entityInQueryIndex, RunnerLevelConfigComponent config, int numSegments, LocalTransform transform, Unity.Mathematics.Random random);
         <summary>
        /// Genera i segmenti del percorso per il livello
        /// </summary>

        private void GeneratePathSegments(int entityInQueryIndex, Entity levelEntity, int numSegments, RunnerLevelConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Determina il tipo di segmento in base alla posizione e alla varietà richiesta
        /// </summary>

        private SegmentType DetermineSegmentType(int index, int totalSegments, float varietyFactor, Unity.Mathematics.Random random);
         <summary>
        /// Crea un segmento di percorso
        /// </summary>

        private Entity CreatePathSegment(int entityInQueryIndex, Entity levelEntity, int segmentIndex, int difficultyLevel, SegmentType type, WorldTheme theme, bool isActive, Entity prevSegment, Unity.Mathematics.Random random);
    }
     <summary>
/// Tag per indicare che un segmento richiede la generazione dei contenuti
/// </summary>

    public struct RequiresContentGenerationTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/UrbanDashSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Scatto Urbano" di Alex.
    /// Si occupa dell'attivazione, della durata e degli effetti dell'abilità,
    /// inclusi velocità aumentata, invulnerabilità e capacità di sfondare ostacoli.
    /// </summary>

    public partial struct UrbanDashSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int entityIndexInQuery, UrbanDashAbilityComponent urbanDash, MovementComponent movement, HealthComponent health, PhysicsComponent physics, AbilityInputComponent abilityInput, TransformComponent transform, AlexComponent alexComponent);
    }
     <summary>
        /// Job responsabile dell'aggiornamento dell'abilità "Scatto Urbano"
        /// </summary>

    private partial struct UpdateUrbanDashJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int entityIndexInQuery, UrbanDashAbilityComponent urbanDash, MovementComponent movement, HealthComponent health, PhysicsComponent physics, AbilityInputComponent abilityInput, TransformComponent transform, AlexComponent alexComponent);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/FireproofBodySystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Corpo Ignifugo" di Ember.
    /// Si occupa della trasformazione in forma ignea che permette
    /// di attraversare la lava e resistere al calore estremo.
    /// </summary>

    public partial struct FireproofBodySystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _lavaQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Componente per l'effetto visivo del corpo ignifugo
    /// </summary>

    public struct FireBodyVisualComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Duration;
        public float RemainingTime;
    }
     <summary>
    /// Tag per identificare le zone di lava
    /// </summary>

    public struct LavaTag : IComponentData
    {
    }
     <summary>
    /// Evento per l'attraversamento della lava
    /// </summary>

    public struct LavaWalkingEvent : IComponentData
    {
        public Entity EntityID;
        public float3 Position;
    }
     <summary>
    /// Job per elaborare l'abilità Fireproof Body
    /// </summary>

    public partial struct FireproofBodyJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> LavaHazards;
        public NativeArray<float3> LavaPositions;
        public NativeArray<float> LavaRadii;
        public NativeArray<bool> HasRadiusData;
        public void Execute(Entity entity, int entityInQueryIndex, FireproofBodyAbilityComponent fireproofBody, HealthComponent health, AbilityInputComponent abilityInput, TransformComponent transform, EmberComponent emberComponent);
    }
     <summary>
    /// Job per aggiornare le visualizzazioni del corpo ignifugo
    /// </summary>

    public partial struct FireBodyVisualUpdateJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<TransformComponent> TransformLookup;
        public void Execute(int chunkIndexInQuery, Entity entity, FireBodyVisualComponent fireVisual, TransformComponent transform);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/FragmentResonanceSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce la meccanica "Risonanza dei Frammenti", che permette
    /// ai giocatori di cambiare personaggio istantaneamente durante il gameplay.
    /// </summary>

    public partial struct FragmentResonanceSystem : ISystem
    {
        private EntityQuery _resonanceQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public void OnCreate(SystemState state);
         void Execute(Entity entity, int chunkIndexInQuery, FragmentResonanceComponent resonance, FocusTimeComponent focusTime, HealthComponent health, ResonanceInputComponent input, TransformComponent transform);
        public void OnUpdate(SystemState state);
    }
    public partial struct FragmentResonanceJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
         void Execute(Entity entity, int chunkIndexInQuery, FragmentResonanceComponent resonance, FocusTimeComponent focusTime, HealthComponent health, ResonanceInputComponent input, TransformComponent transform);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/NatureCallSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Richiamo della Natura" di Maya.
    /// Si occupa dell'evocazione di animali alleati temporanei che
    /// distraggono i nemici.
    /// </summary>

    public partial struct NatureCallSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _enemyQuery;
        private EntityQuery _allyQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Componente che definisce un alleato naturale evocato da Maya
    /// </summary>

    public struct NatureAllyComponent : IComponentData
    {
        public Entity TargetEnemy;
        public Entity OwnerEntity;
        public float Duration;
        public float RemainingTime;
    }
     <summary>
    /// Tag per identificare le entità che devono essere distrutte
    /// </summary>

    public struct DisableEntityTag : IComponentData
    {
    }
     <summary>
    /// Job per processare l'abilità NatureCall
    /// </summary>

    public struct NatureCallAbilityJob
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityQuery EnemyQuery;
        public IntPtr EntityManagerPtr;
        public EntityTypeHandle EntityTypeHandle;
        public void Run(EntityManager entityManager, EntityQuery query);
    }
     <summary>
    /// Job per il comportamento base degli alleati naturali
    /// </summary>

    public partial struct NatureAllyBehaviorJob : IJobEntity
    {
        public float DeltaTime;
        public float GameTime;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int entityInQueryIndex, NatureAllyComponent ally, TransformComponent transform);
    }
     <summary>
    /// Job per l'interazione degli alleati con i target nemici
    /// </summary>

    public struct NatureAllyTargetInteractionJob
    {
        public float DeltaTime;
        public float GameTime;
        public IntPtr EntityManagerPtr;
        public void Run(EntityManager entityManager, EntityQuery query);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/ControlledGlitchSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Glitch Controllato" di Neo.
    /// Si occupa della deformazione temporanea della realtà che permette
    /// di attraversare barriere digitali.
    /// </summary>

    public partial struct ControlledGlitchSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _barrierQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Tag per identificare le barriere digitali
    /// </summary>

    public struct DigitalBarrierTag : IComponentData
    {
    }
     <summary>
    /// Evento per l'inizio del teletrasporto
    /// </summary>

    public struct GlitchTeleportStartEvent : IComponentData
    {
        public Entity EntityID;
        public float3 StartPosition;
        public float3 TargetPosition;
        public Entity BarrierEntity;
    }
     <summary>
    /// Evento per la fine del teletrasporto
    /// </summary>

    public struct GlitchTeleportEndEvent : IComponentData
    {
        public Entity EntityID;
        public float3 FinalPosition;
    }
     <summary>
    /// Job per gestire l'abilità di Glitch Controllato
    /// </summary>

    public partial struct ControlledGlitchJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> Barriers;
        public NativeArray<float3> BarrierPositions;
        public void Execute(Entity entity, int entityInQueryIndex, ControlledGlitchAbilityComponent glitch, TransformComponent transform, PhysicsComponent physics, AbilityInputComponent abilityInput, NeoComponent neoComponent);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/AbilitySystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema base per la gestione delle abilità dei personaggi.
    /// Si occupa della ricezione degli input e del routing verso i sistemi
    /// specifici di ciascuna abilità.
    /// </summary>

    public partial struct AbilitySystem : ISystem
    {
        private EntityQuery _inputQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Enumerazione dei tipi di abilità disponibili
    /// </summary>

    public enum AbilityType
    {
        None = 0,
        UrbanDash = 1,
        NatureCall = 2,
        HeatAura = 3,
        FireproofBody = 4,
        AirBubble = 5,
        ControlledGlitch = 6
    }
     <summary>
    /// Evento generato quando un'abilità termina
    /// </summary>

    public struct AbilityEndedEvent : IComponentData
    {
        public Entity EntityID;
        public AbilityType AbilityType;
    }
     <summary>
    /// Evento generato quando un'abilità è pronta (cooldown terminato)
    /// </summary>

    public struct AbilityReadyEvent : IComponentData
    {
        public Entity EntityID;
        public AbilityType AbilityType;
    }
     <summary>
    /// Job per elaborare gli input di abilità
    /// </summary>

    public partial struct AbilityInputProcessorJob : IJobEntity
    {
         void Execute(Entity entity, AbilityInputComponent abilityInput, InputComponent input, PlayerDataComponent playerData);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/AirBubbleSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
    public partial struct AirBubbleSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _underwaterEnemyQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> UnderwaterEnemies;
        public NativeArray<float3> EnemyPositions;
        public NativeArray<PhysicsComponent> EnemyPhysics;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityManager EntityManager;
        public void OnCreate(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleAbilityComponent airBubble, AbilityInputComponent abilityInput, TransformComponent transform, MarinaComponent marinaComponent);
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleVisualComponent bubbleVisual, TransformComponent transform);
    }
    private partial struct AirBubbleUpdateJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> UnderwaterEnemies;
        public NativeArray<float3> EnemyPositions;
        public NativeArray<PhysicsComponent> EnemyPhysics;
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleAbilityComponent airBubble, AbilityInputComponent abilityInput, TransformComponent transform, MarinaComponent marinaComponent);
    }
    private partial struct AirBubbleVisualUpdateJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityManager EntityManager;
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleVisualComponent bubbleVisual, TransformComponent transform);
    }
    public struct AirBubbleVisualComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Radius;
        public float Duration;
        public float RemainingTime;
    }
    public struct UnderwaterTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/HeatAuraSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Aura di Calore" di Kai.
    /// Si occupa della generazione di un campo di calore che scioglie
    /// il ghiaccio e protegge dal freddo.
    /// </summary>

    public partial struct HeatAuraSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _iceObstacleQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Componente per l'effetto visivo dell'aura di calore
    /// </summary>

    public struct HeatAuraVisualComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Radius;
        public float Duration;
        public float RemainingTime;
    }
     <summary>
    /// Tag per identificare gli ostacoli di ghiaccio
    /// </summary>

    public struct IceObstacleTag : IComponentData
    {
    }
     <summary>
    /// Componente per tracciare l'integrità del ghiaccio
    /// </summary>

    public struct IceIntegrityComponent : IComponentData
    {
        public float MaxIntegrity;
        public float CurrentIntegrity;
    }
     <summary>
    /// Componente per l'effetto visivo di scioglimento del ghiaccio
    /// </summary>

    public struct IceMeltEffectComponent : IComponentData
    {
        public float3 Position;
        public float Size;
    }
     <summary>
    /// Job per elaborare l'abilità Heat Aura
    /// </summary>

    public partial struct HeatAuraProcessingJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> IceObstacles;
        public NativeArray<float3> ObstaclePositions;
        public NativeArray<float> ObstacleScales;
        public NativeArray<IceIntegrityComponent> IceIntegrities;
        public NativeArray<bool> HasIntegrity;
        public void Execute(Entity entity, int entityInQueryIndex, HeatAuraAbilityComponent heatAura, AbilityInputComponent abilityInput, TransformComponent transform, KaiComponent kaiComponent);
        public void OnDestroy();
    }
     <summary>
    /// Job per aggiornare le visualizzazioni dell'aura di calore
    /// </summary>

    public struct HeatAuraVisualUpdateJob
    {
        public float DeltaTime;
        public EntityManager EntityManager;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Run(EntityManager entityManager, EntityQuery query);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/FocusTimeSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce la meccanica del "Focus Time", permettendo al giocatore di
    /// rallentare il tempo per prendere decisioni strategiche e utilizzare oggetti.
    /// </summary>

    public partial struct FocusTimeSystem : ISystem
    {
        private EntityQuery _focusTimeQuery;
        private Entity _timeManagerEntity;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public NativeReference<bool> AnyFocusTimeActive;
        public void OnCreate(SystemState state);
         void Execute(Entity entity, int chunkIndexInQuery, FocusTimeComponent focusTime, FocusTimeInputComponent input);
        public void OnUpdate(SystemState state);
    }
    public partial struct FocusTimeProcessorJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public NativeReference<bool> AnyFocusTimeActive;
         void Execute(Entity entity, int chunkIndexInQuery, FocusTimeComponent focusTime, FocusTimeInputComponent input);
    }
     <summary>
    /// Componente che gestisce la scala del tempo globale
    /// </summary>

    public struct TimeScaleComponent : IComponentData
    {
        public float Scale;
    }
     <summary>
    /// Tag per identificare l'entità manager del tempo
    /// </summary>

    public struct TimeManagerTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/SlideSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce la meccanica di scivolata del giocatore.
    /// Si occupa di avviare le scivolate in risposta all'input, gestire la durata
    /// e gli effetti collaterali come l'altezza ridotta per passare sotto gli ostacoli.
    /// </summary>

    public partial struct SlideSystem : ISystem
    {
        private EntityQuery _slidableEntitiesQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, SlideInputComponent slideInput);
    }
    private partial struct SlideProcessorJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, SlideInputComponent slideInput);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/JumpSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce il salto del giocatore in risposta all'input.
    /// Si occupa di avviare i salti, gestire i salti multipli e coordinare
    /// con il sistema di fisica per applicare le forze appropriate.
    /// </summary>

    public partial struct JumpSystem : ISystem
    {
        private EntityQuery _jumpableEntitiesQuery;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, JumpInputComponent jumpInput);
    }
    private partial struct JumpProcessorJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, JumpInputComponent jumpInput);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/ObstacleInteractionSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Tag per identificare superfici scivolose
    /// </summary>

    public struct SlipperyTag : IComponentData
    {
    }
     <summary>
    /// Sistema che gestisce le interazioni speciali tra i personaggi e gli ostacoli in base alle loro abilità.
    /// Estende le funzionalità di base dell'ObstacleCollisionSystem per supportare l'interazione con tutti i tipi di ostacoli
    /// in base alle abilità dei vari personaggi.
    /// </summary>

    public partial struct ObstacleInteractionSystem : ISystem
    {
        private EntityQuery _playerQuery;
        private EntityQuery _obstacleQuery;
        private EntityQuery _specialObstaclesQuery;
        private const float INTERACTION_RADIUS;
        private const float MELT_RATE;
        private const float BARRIER_PENETRATION_DISTANCE;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public ComponentLookup<SlipperyTag> SlipperyTagLookup;
        public NativeArray<Entity> SpecialObstacles;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public float InteractionRadius;
        public float MeltRate;
        public float BarrierPenetrationDistance;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity playerEntity, int chunkIndexInQuery, TransformComponent playerTransform, PhysicsComponent physics);
         <summary>
        /// Gestisce l'interazione con gli ostacoli di lava per Ember
        /// </summary>

        private static void HandleLavaInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Gestisce l'interazione di scioglimento del ghiaccio per Kai
        /// </summary>

        private static void HandleIceMeltingInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, float auraRadius, EntityCommandBuffer.ParallelWriter commandBuffer, float deltaTime);
         <summary>
        /// Gestisce l'interazione con le barriere digitali per Neo
        /// </summary>

        private static void HandleDigitalBarrierInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, float glitchDistance, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Gestisce l'interazione con l'ambiente sottomarino per Marina
        /// </summary>

        private static void HandleUnderwaterInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, float bubbleRadius, float repelForce, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Gestisce l'interazione con superfici scivolose per tutti i personaggi
        /// </summary>

        private static void HandleSlipperyInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, bool hasHeatAura, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Verifica se un'entità contiene una certa abilità e se è attiva
        /// </summary>

        private static bool HasActiveAbility(Entity entity, ComponentLookup<T> lookup);
    }
    private partial struct SpecialObstacleInteractionJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public ComponentLookup<SlipperyTag> SlipperyTagLookup;
        public NativeArray<Entity> SpecialObstacles;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public float InteractionRadius;
        public float MeltRate;
        public float BarrierPenetrationDistance;
        public void Execute(Entity playerEntity, int chunkIndexInQuery, TransformComponent playerTransform, PhysicsComponent physics);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/ObstacleCollisionSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce le collisioni tra il giocatore e gli ostacoli.
    /// Rileva collisioni, genera eventi appropriati e applica gli effetti delle collisioni.
    /// </summary>

    public partial struct ObstacleCollisionSystem : ISystem
    {
        private EntityQuery _playerQuery;
        private EntityQuery _obstacleQuery;
        private const float OBSTACLE_DAMAGE_MULTIPLIER;
        private const float MIN_IMPACT_VELOCITY;
        private const float SMALL_OBSTACLE_THRESHOLD;
        private const float PLAYER_RADIUS;
        public NativeArray<Entity> Obstacles;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float PlayerRadius;
        public float ObstacleDamageMultiplier;
        public float MinImpactVelocity;
        public float SmallObstacleThreshold;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity playerEntity, int entityInQueryIndex, HealthComponent health, TransformComponent transform, PhysicsComponent physics, MovementComponent movement);
         <summary>
            /// Verifica se c'è una collisione tra due entità basata su posizione e raggio
            /// </summary>

        private bool CheckCollision(float3 posA, float3 posB, float radiusA, float radiusB);
         <summary>
            /// Calcola la posizione di impatto tra due entità
            /// </summary>

        private float3 CalculateImpactPosition(float3 posA, float3 posB);
    }
    private partial struct ProcessCollisionsJob : IJobEntity
    {
        public NativeArray<Entity> Obstacles;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float PlayerRadius;
        public float ObstacleDamageMultiplier;
        public float MinImpactVelocity;
        public float SmallObstacleThreshold;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public void Execute(Entity playerEntity, int entityInQueryIndex, HealthComponent health, TransformComponent transform, PhysicsComponent physics, MovementComponent movement);
         <summary>
            /// Verifica se c'è una collisione tra due entità basata su posizione e raggio
            /// </summary>

        private bool CheckCollision(float3 posA, float3 posB, float radiusA, float radiusB);
         <summary>
            /// Calcola la posizione di impatto tra due entità
            /// </summary>

        private float3 CalculateImpactPosition(float3 posA, float3 posB);
    }
     <summary>
    /// Evento generato quando il giocatore sfonda un ostacolo
    /// </summary>

    public struct ObstacleBreakThroughEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity ObstacleEntity;
        public float3 BreakThroughPosition;
    }
     <summary>
    /// Tipi di danno che possono essere applicati
    /// </summary>

    public enum DamageType
    {
        Obstacle = 0,
        Fall = 1,
        Enemy = 2,
        Hazard = 3,
        StatusEffect = 4
    }
     <summary>
    /// Evento generico di danno
    /// </summary>

    public struct DamageEvent : IComponentData
    {
        public Entity TargetEntity;
        public Entity SourceEntity;
        public float DamageAmount;
        public DamageType DamageType;
        public float3 ImpactPosition;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/NavigationSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// 
    /// </summary>

    public partial class NavigationSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/ObstacleAvoidanceSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// 
    /// </summary>

    public partial class ObstacleAvoidanceSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/PlayerMovementSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce il movimento del giocatore in base all'input ricevuto.
    /// Elabora la corsa automatica, i movimenti laterali, e coordina con altri sistemi
    /// come salto e scivolata.
    /// </summary>

    public partial struct PlayerMovementSystem : ISystem
    {
        private const float LANE_WIDTH;
        private const float MAX_LANE_OFFSET;
        private const float GROUND_LEVEL;
        private const float GRAVITY_MULTIPLIER;
        private const float GROUND_CHECK_DISTANCE;
        private EntityQuery _playerQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float LaneWidth;
        public float MaxLaneOffset;
        public float GroundLevel;
        public float GravityMultiplier;
        public float GroundCheckDistance;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity entity, int entityInQueryIndex, TransformComponent transform, PhysicsComponent physics, MovementComponent movement, InputComponent input);
    }
    private partial struct PlayerMovementJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float LaneWidth;
        public float MaxLaneOffset;
        public float GroundLevel;
        public float GravityMultiplier;
        public float GroundCheckDistance;
        public void Execute(Entity entity, int entityInQueryIndex, TransformComponent transform, PhysicsComponent physics, MovementComponent movement, InputComponent input);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/PatrolSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// 
    /// </summary>

    public partial class PatrolSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/AttackPatternSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// 
    /// </summary>

    public partial class AttackPatternSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/EnemyAISystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// 
    /// </summary>

    public partial class EnemyAISystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/BossPhasesSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// 
    /// </summary>

    public partial class BossPhasesSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/PursuitSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// 
    /// </summary>

    public partial class PursuitSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/TutorialProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema specializzato che gestisce la progressione del giocatore attraverso i tutorial.
    /// Si occupa dell'apprendimento delle meccaniche di base e dello sblocco sequenziale dei tutorial.
    /// </summary>

    public partial class TutorialProgressionSystem : SystemBase
    {
        private EntityQuery _tutorialLevelQuery;
        private EntityQuery _tutorialProgressQuery;
        private EntityQuery _playerQuery;
        private EntityQuery _playerProgressionQuery;
        private bool _initializationComplete;
        private RunawayHeroes.Runtime.Levels.TutorialLevelInitializer _tutorialManager;
        private int _totalAvailableTutorials;
        private const float TUTORIAL_COMPLETION_THRESHOLD;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Cerca e crea riferimenti a runtime
        /// </summary>

        protected override void OnStartRunning();
         <summary>
        /// Aggiorna il sistema di progressione tutorial
        /// </summary>

        protected override void OnUpdate();
         <summary>
        /// Verifica se il giocatore ha completato un tutorial percorrendo la distanza necessaria
        /// </summary>

        private void CheckTutorialCompletionByDistance();
         <summary>
        /// Inizializza i dati di progressione se non esistono già
        /// </summary>

        private void InitializeProgressionData();
         <summary>
        /// Ottiene o crea l'entità di progressione tutorial
        /// </summary>

        private Entity GetOrCreateTutorialProgressionEntity();
         <summary>
        /// Crea un messaggio UI per il completamento tutorial
        /// </summary>

        private void CreateTutorialCompletionMessage(EntityCommandBuffer commandBuffer, bool allCompleted);
         <summary>
        /// Genera un evento di avanzamento progressione
        /// </summary>

        private void GenerateProgressionAdvancementEvent(EntityCommandBuffer commandBuffer, byte progressionType, int primaryIndex, int secondaryIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/FocusTimeItemDetectionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che rileva oggetti collezionabili nel raggio del giocatore durante il Focus Time
    /// e li segnala come disponibili per l'aggiunta agli slot.
    /// </summary>

    public partial struct FocusTimeItemDetectionSystem : ISystem
    {
        private EntityQuery _playerQuery;
        private EntityQuery _collectibleQuery;
        private const float FOCUS_TIME_DETECTION_RADIUS;
        public void OnCreate(SystemState state);
        public void OnUpdate(SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/WorldProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema specializzato che gestisce la progressione del giocatore attraverso i vari mondi di gioco.
    /// Si occupa dello sblocco dei mondi, della raccolta dei frammenti e della progressione narrativa.
    /// </summary>

    public partial class WorldProgressionSystem : SystemBase
    {
        private EntityQuery _playerProgressionQuery;
        private EntityQuery _worldProgressionQuery;
        private EntityQuery _activeWorldQuery;
        private bool _initializationComplete;
        private readonly int[] _worldCharacterMapping;
        private readonly string[] _worldNames;
        private const int TOTAL_WORLDS;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Aggiorna il sistema di progressione dei mondi
        /// </summary>

        protected override void OnUpdate();
         <summary>
        /// Processa eventi di completamento tutorial per sbloccare il primo mondo
        /// </summary>

        private void ProcessTutorialCompletionEvents(EntityCommandBuffer commandBuffer);
         <summary>
        /// Processa eventi di completamento mondo
        /// </summary>

        private void ProcessWorldCompletionEvents(EntityCommandBuffer commandBuffer);
         <summary>
        /// Processa eventi di raccolta frammenti
        /// </summary>

        private void ProcessFragmentCollectionEvents(EntityCommandBuffer commandBuffer);
         <summary>
        /// Aggiorna lo stato globale di progressione
        /// </summary>

        private void UpdateGlobalProgressionState();
         <summary>
        /// Inizializza i dati di progressione dei mondi se non esistono già
        /// </summary>

        private void InitializeWorldProgressionData();
         <summary>
        /// Ottiene o crea un'entità di progressione per un mondo specifico
        /// </summary>

        private Entity GetOrCreateWorldProgressionEntity(int worldIndex);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un mondo
        /// </summary>

        private void CreateWorldUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex);
         <summary>
        /// Crea un messaggio UI per la raccolta di un frammento
        /// </summary>

        private void CreateFragmentCollectionMessage(EntityCommandBuffer commandBuffer, int fragmentIndex);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un personaggio
        /// </summary>

        private void CreateCharacterUnlockMessage(EntityCommandBuffer commandBuffer, int characterIndex);
         <summary>
        /// Ottiene il numero totale di stelle disponibili in un mondo
        /// </summary>

        private int GetTotalStarsForWorld(int worldIndex);
         <summary>
        /// Ottiene il nome di un frammento in base all'indice
        /// </summary>

        private string GetFragmentName(int fragmentIndex);
         <summary>
        /// Ottiene il nome di un personaggio in base all'indice
        /// </summary>

        private string GetCharacterName(int characterIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/LevelProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema specializzato che gestisce la progressione del giocatore all'interno dei singoli livelli.
    /// Si occupa del tracking delle stelle, collezionabili e obiettivi bonus.
    /// </summary>

    public partial struct LevelProgressionSystem : ISystem
    {
        private EntityQuery _playerProgressionQuery;
        private EntityQuery _worldProgressionQuery;
        private EntityQuery _levelProgressionQuery;
        private EntityQuery _activeLevelQuery;
        private bool _initializationComplete;
        private int _currentSessionScore;
        private int _currentSessionCollectibles;
        private int _currentSessionTreasures;
        private float _currentSessionStartTime;
        private bool _bonusObjectiveCompleted;
        private int _activeWorldIndex;
        private int _activeLevelIndex;
        private const float TIME_FOR_THREE_STARS;
        private const float TIME_FOR_TWO_STARS;
        private const float TIME_FOR_ONE_STAR;
        private const int COLLECTIBLES_PER_LEVEL;
        private const int TREASURES_PER_LEVEL;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Inizializza la sessione corrente
        /// </summary>

        public void OnStartRunning(SystemState state);
         <summary>
        /// Aggiorna il sistema di progressione dei livelli
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Reimposta i contatori per una nuova sessione di gioco
        /// </summary>

        private void ResetSessionCounters();
         <summary>
        /// Identifica il livello attualmente attivo
        /// </summary>

        private void IdentifyActiveLevel(SystemState state);
         <summary>
        /// Processa eventi di completamento livello
        /// </summary>

        private void ProcessLevelCompletionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Processa eventi di raccolta oggetti
        /// </summary>

        private void ProcessCollectionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Processa eventi di completamento obiettivi
        /// </summary>

        private void ProcessObjectiveCompletionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Calcola il numero di stelle guadagnate in base al tempo di completamento
        /// </summary>

        private byte CalculateStars(float completionTime, byte existingStars);
         <summary>
        /// Aggiorna la progressione del mondo per un livello completato
        /// </summary>

        private void UpdateWorldProgressionForLevel(int worldIndex, int levelIndex, byte starsEarned, bool bonusObjectiveCompleted, SystemState state);
         <summary>
        /// Aggiorna la progressione del mondo per un obiettivo bonus completato
        /// </summary>

        private void UpdateWorldProgressionForBonusObjective(int worldIndex, SystemState state);
         <summary>
        /// Sblocca il livello successivo se esiste
        /// </summary>

        private void UnlockNextLevel(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex, SystemState state);
         <summary>
        /// Aggiorna il progresso globale basato sui livelli e mondi
        /// </summary>

        private void UpdateGlobalProgress(SystemState state);
         <summary>
        /// Inizializza i dati di progressione
        /// </summary>

        private void InitializeLevelProgressionData(SystemState state);
         <summary>
        /// Ottiene o crea un'entità di progressione livello
        /// </summary>

        private Entity GetOrCreateLevelProgressionEntity(int worldIndex, int levelIndex, SystemState state);
         <summary>
        /// Crea un messaggio UI per il completamento di un livello
        /// </summary>

        private void CreateLevelCompletionMessage(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex, byte starsEarned, bool isNewBest);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un livello
        /// </summary>

        private void CreateLevelUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex);
         <summary>
        /// Verifica se un mondo è stato completato al 100%
        /// </summary>

        private bool IsWorldFullyCompleted(WorldProgressionComponent worldProgress);
         <summary>
        /// Ottiene il numero massimo di livelli per un mondo
        /// </summary>

        private int GetMaxLevelsForWorld(int worldIndex);
         <summary>
        /// Ottiene il nome di un mondo in base all'indice
        /// </summary>

        private string GetWorldName(int worldIndex);
         <summary>
        /// Ottiene le stelle già assegnate a un livello
        /// </summary>

        private int GetStarsForLevel(int worldIndex, int levelIndex, SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/ScoreSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// 
    /// </summary>

    public partial class ScoreSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/ProgressionEventSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema centralizzato che gestisce gli eventi di progressione per la comunicazione tra sistemi.
    /// Si occupa di propagare eventi tra i diversi livelli di progressione (tutorial, mondo, livello).
    /// </summary>

    public partial class ProgressionEventSystem : SystemBase
    {
        private EntityQuery _playerProgressionQuery;
        private EntityQuery _progressionEventsQuery;
        private EntityQuery _unlockEventsQuery;
        private AudioManager _audioManager;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Cerca e ottiene riferimenti
        /// </summary>

        protected override void OnStartRunning();
         <summary>
        /// Aggiorna il sistema di eventi progressione
        /// </summary>

        protected override void OnUpdate();
         <summary>
        /// Processa eventi di avanzamento progressione
        /// </summary>

        private void ProcessProgressionAdvancementEvents(EntityCommandBuffer commandBuffer);
         <summary>
        /// Processa eventi di sblocco
        /// </summary>

        private void ProcessUnlockEvents(EntityCommandBuffer commandBuffer);
         <summary>
        /// Notifica avanzamento tutorial al sistema mondo
        /// </summary>

        private void NotifyWorldOfTutorialAdvancement(EntityCommandBuffer commandBuffer, int tutorialIndex);
         <summary>
        /// Notifica avanzamento mondo ai livelli
        /// </summary>

        private void NotifyLevelsOfWorldAdvancement(EntityCommandBuffer commandBuffer, int worldIndex);
         <summary>
        /// Notifica avanzamento livello al sistema mondo
        /// </summary>

        private void NotifyWorldOfLevelAdvancement(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex);
         <summary>
        /// Aggiorna PlayerPrefs per un evento di avanzamento
        /// </summary>

        private void UpdatePlayerPrefs(ProgressionAdvancementEvent progressionEvent);
         <summary>
        /// Aggiorna PlayerPrefs per un evento di sblocco
        /// </summary>

        private void UpdatePlayerPrefsForUnlock(string prefix, int index);
         <summary>
        /// Riproduce audio appropriato per eventi di progressione
        /// </summary>

        private void PlayProgressionAudio(ProgressionAdvancementEvent progressionEvent);
         <summary>
        /// Riproduce audio appropriato per eventi di sblocco
        /// </summary>

        private void PlayUnlockAudio(string unlockType);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un mondo
        /// </summary>

        private void CreateWorldUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un livello
        /// </summary>

        private void CreateLevelUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex);
         <summary>
        /// Ottiene il numero massimo di livelli per un mondo
        /// </summary>

        private int GetMaxLevelsForWorld(int worldIndex);
         <summary>
        /// Ottiene il nome di un mondo in base all'indice
        /// </summary>

        private string GetWorldName(int worldIndex);
         <summary>
        /// Ottiene l'indice personaggio da sbloccare per un mondo
        /// </summary>

        private int GetCharacterIndexForWorld(int worldIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/ProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce la progressione del giocatore attraverso i tutorial e i livelli.
    /// Monitora il completamento degli obiettivi e trigger eventi di progressione.
    /// </summary>

    public partial class ProgressionSystem : SystemBase
    {
        private EntityQuery _tutorialLevelQuery;
        private EntityQuery _tutorialProgressQuery;
        private EntityQuery _playerQuery;
        private bool _initializationComplete;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        protected override void OnCreate();
         <summary>
        /// Aggiorna il sistema di progressione
        /// </summary>

        protected override void OnUpdate();
         <summary>
        /// Verifica il raggiungimento degli obiettivi tutorial
        /// </summary>

        private void CheckTutorialObjectives();
         <summary>
        /// Aggiorna i timer per gli scenari attivati
        /// </summary>

        private void UpdateScenarioTimers();
         <summary>
        /// Inizializza i dati di progressione se non esistono già
        /// </summary>

        private void InitializeProgressionData();
         <summary>
        /// Ottiene o crea l'entità di progressione
        /// </summary>

        private Entity GetOrCreateProgressionEntity();
         <summary>
        /// Crea un messaggio UI per il completamento
        /// </summary>

        private void CreateCompletionMessage(EntityCommandBuffer commandBuffer, bool allCompleted);
    }
     <summary>
    /// Sistema per la gestione degli obiettivi specifici
    /// </summary>

    public partial class ObjectiveSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
         <summary>
        /// Coroutine per avanzare al prossimo tutorial dopo un ritardo
        /// </summary>

        private System.Collections.IEnumerator DelayedTutorialAdvance(RunawayHeroes.Runtime.Levels.TutorialLevelInitializer tutorialManager, float delay);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/DifficultySystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce la difficoltà progressiva del gioco, sia all'interno di un livello
    /// che tra diversi mondi tematici. Si occupa di regolare parametri di difficoltà in base
    /// al progresso del giocatore e al tema del mondo corrente.
    /// </summary>

    public partial class DifficultySystem : SystemBase
    {
        private EntityQuery _worldConfigQuery;
        private const float DEFAULT_DIFFICULTY_UPDATE_INTERVAL;
        private float _timeSinceLastUpdate;
        protected override void OnCreate();
        protected override void OnUpdate();
         <summary>
        /// Crea una configurazione di difficoltà predefinita nel mondo
        /// </summary>

        private void CreateDefaultWorldDifficultyConfig();
         <summary>
        /// Applica modificatori di difficoltà a tutti i nemici in base alla difficoltà del segmento
        /// </summary>

        private void ApplyDifficultyToEnemies();
         <summary>
        /// Applica modificatori di difficoltà a tutti gli ostacoli in base alla difficoltà del segmento
        /// </summary>

        private void ApplyDifficultyToObstacles();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/PowerupSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// 
    /// </summary>

    public partial class PowerupSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/CollectibleSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// 
    /// </summary>

    public partial class CollectibleSystem : SystemBase
    {
        protected override void OnCreate();
        protected override void OnUpdate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/TutorialGuidanceSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce l'avanzamento del tutorial e la generazione degli scenari didattici
    /// </summary>

    public partial struct TutorialGuidanceSystem : ISystem
    {
        private EntityQuery _activePlayerQuery;
        private EntityQuery _scenarioQuery;
        private const float LANE_WIDTH;
        private const float LEFT_POSITION;
        private const float CENTER_POSITION;
        private const float RIGHT_POSITION;
        private uint _seed;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per controllare e attivare scenari tutorial
    /// </summary>

    public partial struct CheckScenarioTriggerJob : IJobEntity
    {
        public float3 PlayerPosition;
        public EntityCommandBuffer.ParallelWriter ECB;
        public uint Seed;
        public float LaneWidth;
        public float LeftPosition;
        public float CenterPosition;
        public float RightPosition;
        public void Execute(Entity entity, int entityInQueryIndex, TutorialScenarioComponent scenario, DynamicBuffer<TutorialObstacleBuffer> obstacleBuffer);
         <summary>
        /// Genera gli ostacoli per uno scenario di tutorial
        /// </summary>

        private void SpawnObstaclesForScenario(int entityInQueryIndex, TutorialScenarioComponent scenario, DynamicBuffer<TutorialObstacleBuffer> obstacleBuffer);
         <summary>
        /// Genera ostacoli per un tutorial con impostazioni avanzate
        /// </summary>

        private void SpawnTutorialObstaclesAdvanced(int entityInQueryIndex, float startZ, float spacing, bool randomPlacement, TutorialObstacleBuffer obstacleSetup);
         <summary>
        /// Crea un'entità ostacolo utilizzando il factory
        /// </summary>

        private Entity SpawnObstacle(int entityInQueryIndex, string obstacleCode, float3 position, float height, float scale);
    }
     <summary>
    /// Componente che identifica uno scenario tutorial
    /// </summary>

    public struct TutorialScenarioComponent : IComponentData
    {
        public FixedString64Bytes Name;
        public float DistanceFromStart;
        public FixedString128Bytes InstructionMessage;
        public float MessageDuration;
        public bool RandomPlacement;
        public float ObstacleSpacing;
        public float StartOffset;
    }
     <summary>
    /// Buffer per gli ostacoli di un tutorial
    /// </summary>

    public struct TutorialObstacleBuffer : IBufferElementData
    {
        public FixedString32Bytes ObstacleCode;
        public int Count;
        public byte Placement;
        public bool RandomizeHeight;
        public float2 HeightRange;
        public bool RandomizeScale;
        public float2 ScaleRange;
        public float StartOffset;
    }
     <summary>
    /// Tag per gli scenari tutorial già attivati
    /// </summary>

    public struct TriggeredTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare i livelli tutorial
    /// </summary>

    public struct TutorialLevelTag : IComponentData
    {
        public int CurrentSequence;
        public bool Completed;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/ColosalYeti.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class ColosalYeti
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/CorruptedAI.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class CorruptedAI
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Ember.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Ember
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/SpiritGuardian.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class SpiritGuardian
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/MutantKraken.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class MutantKraken
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/MagmaElemental.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class MagmaElemental
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Marina.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Marina
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Kai.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Kai
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/CyborgSecurity.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class CyborgSecurity
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Maya.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Maya
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Alex.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Alex
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Neo.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Neo
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/PlayerArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class PlayerArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/ObstacleArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class ObstacleArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/CollectibleArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class CollectibleArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/EnemyArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class EnemyArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/CollectibleFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class CollectibleFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/FXFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class FXFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/PlayerFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// Factory che crea entità per i personaggi giocabili.
    /// Implementa metodi per creare i 6 protagonisti con configurazioni appropriate.
    /// </summary>

    public static class PlayerFactory
    {
         <summary>
        /// Crea un'entità giocatore con componenti base
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale del giocatore</param>
        /// <returns>Entità player creata</returns>

        public static Entity CreatePlayer(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Alex, il corriere urbano
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Alex creata</returns>

        public static Entity CreateAlex(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Maya, l'esploratrice della foresta
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Maya creata</returns>

        public static Entity CreateMaya(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Kai, l'alpinista della tundra
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Kai creata</returns>

        public static Entity CreateKai(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Ember, la sopravvissuta del vulcano
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Ember creata</returns>

        public static Entity CreateEmber(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Marina, la biologa degli abissi
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Marina creata</returns>

        public static Entity CreateMarina(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Neo, l'hacker della realtà virtuale
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Neo creata</returns>

        public static Entity CreateNeo(EntityManager entityManager, float3 position);
         <summary>
        /// Crea tutti i personaggi per testing
        /// </summary>
        /// <param name="entityManager">EntityManager per creare le entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Array delle entità create</returns>

        public static Entity[] CreateAllCharacters(EntityManager entityManager, float3 position);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/WorldEntityFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class WorldEntityFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/EnemyFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class EnemyFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/BossFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class BossFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/TundraObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli della tundra specifici del tema Tundra
    /// </summary>

     <summary>
    /// Tag di ostacolo della tundra per raggruppamento
    /// </summary>

    public struct TundraObstacleTag : IComponentData
    {
    }
     <summary>
    /// T01: Muro di ghiaccio - Richiede salto o scivolata
    /// </summary>

    public struct T01_IceWall : IComponentData
    {
        public float Thickness;
        public float Integrity;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T02: Blocco di ghiaccio - Richiede salto
    /// </summary>

    public struct T02_IceBlock : IComponentData
    {
        public bool IsBreakable;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T03: Superficie ghiacciata - Causa scivolamento
    /// </summary>

    public struct T03_IcySurface : IComponentData
    {
        public float SlipperinessFactor;
        public float Length;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T04: Stalattiti di ghiaccio - Cadono quando ci si avvicina
    /// </summary>

    public struct T04_IceStalactite : IComponentData
    {
        public float FallDelay;
        public float TriggerDistance;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T05: Geyser gelato - Erutta periodicamente causando danno da gelo
    /// </summary>

    public struct T05_FrostGeyser : IComponentData
    {
        public float EruptionInterval;
        public float EruptionDuration;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T06: Valanga - Richiede reazione rapida
    /// </summary>

    public struct T06_Avalanche : IComponentData
    {
        public float Speed;
        public float Width;
        public float WarningTime;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T07: Ponte di ghiaccio - Si rompe dopo un po'
    /// </summary>

    public struct T07_IceBridge : IComponentData
    {
        public float BreakTime;
        public float Integrity;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T08: Vento gelido - Spinge il giocatore e causa danno da freddo
    /// </summary>

    public struct T08_FreezingWind : IComponentData
    {
        public float Force;
        public float Direction;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/ObstacleTypeComponent.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Componente di base che definisce il tipo di ostacolo
    /// </summary>

    public struct ObstacleTypeComponent : IComponentData
    {
        public ushort ObstacleID;
        public ObstacleCategory Category;
        public bool IsUniversal;
        public bool IsUrbanObstacle;
        public bool IsForestObstacle;
        public bool IsTundraObstacle;
        public bool IsVolcanoObstacle;
        public bool IsAbyssObstacle;
        public bool IsVirtualObstacle;
        public float Height;
        public float Width;
        public float Depth;
        public bool RequiresJump;
        public bool RequiresSlide;
        public bool RequiresSideStep;
        public byte DifficultyLevel;
        public bool IsBreakable;
        public bool IsSlippery;
        public bool IsToxic;
        public bool IsLava;
        public bool IsIce;
        public bool IsDigital;
        public bool IsUnderwater;
        public string GetIDPrefix();
        public static ObstacleTypeComponent CreateUniversal(ushort id, ObstacleCategory category, float height, float width, float depth);
    }
     <summary>
    /// Enumerazione delle categorie di ostacoli
    /// </summary>

    public enum ObstacleCategory
    {
        None = 0,
        SmallBarrier = 1,
        LargeBarrier = 2,
        Gap = 3,
        HangingObject = 4,
        MovingObstacle = 5,
        GroundHazard = 6,
        SpecialBarrier = 7,
        Vehicle = 8,
        NaturalObstacle = 9,
        ElectronicObstacle = 10,
        WaterObstacle = 11,
        FireObstacle = 12,
        IceObstacle = 13,
        DigitalObstacle = 14
    }
     <summary>
    /// Componente tag per ostacoli universali
    /// </summary>

    public struct UniversalObstacleTag : IComponentData
    {
        public ushort ObstacleID;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/VolcanoObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli vulcanici specifici del tema Volcano
    /// </summary>

     <summary>
    /// Tag di ostacolo vulcanico per raggruppamento
    /// </summary>

    public struct VolcanoObstacleTag : IComponentData
    {
    }
     <summary>
    /// V01: Pozza di lava - Causa danno continuo
    /// </summary>

    public struct V01_LavaPool : IComponentData
    {
        public float Temperature;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V02: Geyser di lava - Erutta periodicamente
    /// </summary>

    public struct V02_LavaGeyser : IComponentData
    {
        public float EruptionInterval;
        public float EruptionDuration;
        public float Height;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V03: Roccia vulcanica - Richiede salto o scivolata
    /// </summary>

    public struct V03_VolcanicRock : IComponentData
    {
        public bool IsHot;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V04: Parete di fiamme - Richiede salto speciale
    /// </summary>

    public struct V04_FireWall : IComponentData
    {
        public float Width;
        public float Height;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V05: Bomba vulcanica - Esplode dopo un po'
    /// </summary>

    public struct V05_VolcanicBomb : IComponentData
    {
        public float ExplosionDelay;
        public float ExplosionRadius;
        public float DamageAmount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V06: Cenere vulcanica - Riduce la visibilità
    /// </summary>

    public struct V06_VolcanicAsh : IComponentData
    {
        public float Density;
        public float Length;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V07: Flusso piroclastico - Avanza rapidamente
    /// </summary>

    public struct V07_PyroclasticFlow : IComponentData
    {
        public float Speed;
        public float Width;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V08: Terreno instabile - Si sgretola dopo un po'
    /// </summary>

    public struct V08_UnstableGround : IComponentData
    {
        public float BreakTime;
        public float WarningTime;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/UrbanObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli urbani specifici del tema City
    /// </summary>

     <summary>
    /// Tag di ostacolo urbano per raggruppamento
    /// </summary>

    public struct UrbanObstacleTag : IComponentData
    {
    }
     <summary>
    /// C01: Auto danneggiata - Richiede salto o scivolata
    /// </summary>

    public struct C01_Car : IComponentData
    {
        public byte CarType;
        public bool IsCrashed;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C02: Furgone danneggiato - Richiede salto alto o aggiramento
    /// </summary>

    public struct C02_Van : IComponentData
    {
        public bool IsTipped;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C03: Drone di sorveglianza - Si muove in pattern prevedibili
    /// </summary>

    public struct C03_SurveillanceDrone : IComponentData
    {
        public float MovementSpeed;
        public float DetectionRadius;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C04: Barricata di polizia - Richiede salto o scivolata
    /// </summary>

    public struct C04_PoliceBarricade : IComponentData
    {
        public bool HasFlashingLights;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C05: Idrante rotto - Crea getto d'acqua che spinge lateralmente
    /// </summary>

    public struct C05_FireHydrant : IComponentData
    {
        public float WaterForce;
        public bool IsSpraying;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C06: Veicolo fuori controllo - Si muove attraverso il percorso
    /// </summary>

    public struct C06_RunawayCar : IComponentData
    {
        public float Speed;
        public byte VehicleType;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C07: Cantiere stradale - Combinazione di coni e barriere
    /// </summary>

    public struct C07_RoadConstruction : IComponentData
    {
        public byte ConstructionType;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C08: Insegna al neon caduta - Può essere elettrificata
    /// </summary>

    public struct C08_FallenNeonSign : IComponentData
    {
        public bool IsElectrified;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/UniversalObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli universali che appaiono in tutti i temi
    /// </summary>

     <summary>
    /// U01: Barriera bassa - Richiede salto
    /// </summary>

    public struct U01_LowBarrier : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U02: Barriera alta - Richiede scivolata
    /// </summary>

    public struct U02_HighBarrier : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U03: Gap/Buco - Richiede salto lungo
    /// </summary>

    public struct U03_Gap : IComponentData
    {
        public float Width;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U04: Ostacolo laterale - Richiede passo laterale
    /// </summary>

    public struct U04_SideObstacle : IComponentData
    {
        public bool IsLeftSide;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U05: Oggetto sospeso - Richiede scivolata
    /// </summary>

    public struct U05_HangingObject : IComponentData
    {
        public float Height;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U06: Barriera doppia - Richiede salto e scivolata in sequenza
    /// </summary>

    public struct U06_DoubleBarrier : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U07: Spuntoni a terra - Richiede salto
    /// </summary>

    public struct U07_FloorSpikes : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U08: Contenitore di energia - Può essere distrutto
    /// </summary>

    public struct U08_PowerContainer : IComponentData
    {
        public float Energy;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/AbyssObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli abissali specifici del tema Abyss
    /// </summary>

     <summary>
    /// Tag di ostacolo abissale per raggruppamento
    /// </summary>

    public struct AbyssObstacleTag : IComponentData
    {
    }
     <summary>
    /// A01: Sezione subacquea - Richiede nuoto e gestione dell'ossigeno
    /// </summary>

    public struct A01_UnderwaterSection : IComponentData
    {
        public float Length;
        public float Depth;
        public float CurrentStrength;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A02: Corrente abissale - Spinge in una direzione
    /// </summary>

    public struct A02_AbyssalCurrent : IComponentData
    {
        public float Strength;
        public float Direction;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A03: Tentacoli oscillanti - Richiede movimento preciso
    /// </summary>

    public struct A03_SwingingTentacles : IComponentData
    {
        public float SwingFrequency;
        public float SwingAmplitude;
        public int TentacleCount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A04: Alga avviluppante - Rallenta il movimento
    /// </summary>

    public struct A04_TanglingSeaweed : IComponentData
    {
        public float SlowFactor;
        public float BreakForce;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A05: Medusa abissale - Emette scariche elettriche
    /// </summary>

    public struct A05_AbyssalJellyfish : IComponentData
    {
        public float StingRadius;
        public float DamageAmount;
        public float MoveSpeed;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A06: Bolla di gas tossico - Riduce l'ossigeno
    /// </summary>

    public struct A06_ToxicGasBubble : IComponentData
    {
        public float Size;
        public float ToxicityLevel;
        public float ExpansionRate;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A07: Voragine abissale - Richiede salto lungo
    /// </summary>

    public struct A07_AbyssalChasm : IComponentData
    {
        public float Width;
        public float Depth;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A08: Spruzzo di inchiostro - Riduce la visibilità
    /// </summary>

    public struct A08_InkSpray : IComponentData
    {
        public float BlindnessDuration;
        public float BlindnessIntensity;
        public float Radius;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/ForestObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli forestali specifici del tema Forest
    /// </summary>

     <summary>
    /// Tag di ostacolo forestale per raggruppamento
    /// </summary>

    public struct ForestObstacleTag : IComponentData
    {
    }
     <summary>
    /// F01: Tronco caduto - Richiede salto
    /// </summary>

    public struct F01_FallenLog : IComponentData
    {
        public float Length;
        public byte RottenLevel;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F02: Albero caduto - Richiede salto grande
    /// </summary>

    public struct F02_FallenTree : IComponentData
    {
        public bool HasBranches;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F03: Radici sporgenti - Richiede salto
    /// </summary>

    public struct F03_ProtrudingRoots : IComponentData
    {
        public float Height;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F04: Pianta velenosa - Causa danno continuo se toccata
    /// </summary>

    public struct F04_PoisonousPlant : IComponentData
    {
        public float ToxicityLevel;
        public float EffectRadius;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F05: Liane pendenti - Richiede scivolata
    /// </summary>

    public struct F05_HangingVines : IComponentData
    {
        public float Length;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F06: Nido di vespe - Attiva sciame se avvicinato
    /// </summary>

    public struct F06_WaspNest : IComponentData
    {
        public float ActivationDistance;
        public int WaspCount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F07: Fossa di fango - Rallenta il movimento
    /// </summary>

    public struct F07_MudPit : IComponentData
    {
        public float SlowFactor;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F08: Tronco oscillante - Si muove da lato a lato
    /// </summary>

    public struct F08_SwingingLog : IComponentData
    {
        public float SwingSpeed;
        public float SwingRange;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/ObstacleCatalog.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Catalogo statico di tutti gli ostacoli per tema
    /// </summary>

    public static class ObstacleCatalog
    {
        private static Dictionary<string, ObstacleTypeComponent> _obstaclesByCode;
         <summary>
        /// Inizializza il catalogo se non è già stato fatto
        /// </summary>

        private static void InitializeIfNeeded();
         <summary>
        /// Ottiene un ostacolo in base al codice (es. "U01", "C03", ecc.)
        /// </summary>

        public static ObstacleTypeComponent GetObstacleByCode(string code);
         <summary>
        /// Ottiene ostacoli casuali per un tema specifico, filtrati per livello di difficoltà
        /// </summary>

        public static List<ObstacleTypeComponent> GetRandomObstaclesForTheme(WorldTheme theme, int count, int minDifficulty, int maxDifficulty, Unity.Mathematics.Random random);
        private static void RegisterUniversalObstacles();
        private static void RegisterUrbanObstacles();
        private static void RegisterForestObstacles();
        private static void RegisterTundraObstacles();
        private static void RegisterVolcanoObstacles();
        private static void RegisterAbyssObstacles();
        private static void RegisterVirtualObstacles();
        private static void RegisterObstacle(string code, ObstacleTypeComponent obstacle);
    }
     <summary>
    /// Factory per la creazione di ostacoli in base al tipo
    /// </summary>

    public static class ObstacleFactory
    {
         <summary>
        /// Crea un'entità ostacolo basata sul codice
        /// </summary>

        public static Entity CreateObstacle(EntityCommandBuffer commandBuffer, string obstacleCode, float3 position, quaternion rotation, float scale);
         <summary>
        /// Aggiunge i componenti specifici in base al codice dell'ostacolo
        /// </summary>

        private static void AddObstacleSpecificComponents(EntityCommandBuffer commandBuffer, Entity entity, string obstacleCode);
         <summary>
        /// Aggiunge i tag specifici per tema dell'ostacolo
        /// </summary>

        private static void AddThemeSpecificTags(EntityCommandBuffer commandBuffer, Entity entity, ObstacleTypeComponent obstacleType);
        private static void AddCityObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddForestObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddTundraObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddVolcanoObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddAbyssObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddVirtualObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/VirtualObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli virtuali specifici del tema Virtual
    /// </summary>

     <summary>
    /// Tag di ostacolo virtuale per raggruppamento
    /// </summary>

    public struct VirtualObstacleTag : IComponentData
    {
    }
     <summary>
    /// D01: Barriera di dati - Richiede salto o glitch
    /// </summary>

    public struct D01_DataBarrier : IComponentData
    {
        public float Height;
        public float Integrity;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D02: Firewall - Causa danno continuo
    /// </summary>

    public struct D02_Firewall : IComponentData
    {
        public float DamagePerSecond;
        public float Width;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D03: Blocco di corruzione - Cambia forma periodicamente
    /// </summary>

    public struct D03_CorruptionBlock : IComponentData
    {
        public float MorphInterval;
        public byte MorphState;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D04: Glitch spaziale - Teletrasporta il giocatore
    /// </summary>

    public struct D04_SpatialGlitch : IComponentData
    {
        public float TeleportDistance;
        public byte TeleportDirection;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D05: Picco di dati - Richiede salto
    /// </summary>

    public struct D05_DataSpike : IComponentData
    {
        public float Height;
        public float Damage;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D06: Virus attivo - Si muove verso il giocatore
    /// </summary>

    public struct D06_ActiveVirus : IComponentData
    {
        public float MoveSpeed;
        public float DetectionRadius;
        public float DamageAmount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D07: Campo di deformazione - Inverte i controlli
    /// </summary>

    public struct D07_DistortionField : IComponentData
    {
        public float Duration;
        public float Radius;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D08: Matrice di codice - Si ricompone in diversi pattern
    /// </summary>

    public struct D08_CodeMatrix : IComponentData
    {
        public byte PatternIndex;
        public float ShiftInterval;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/Group/MovementSystemGroup.cs

namespace RunawayHeroes.ECS.Systems.Movement.Group
{
     <summary>
    /// Gruppo di sistemi che gestisce tutti gli aspetti del movimento.
    /// </summary>

    public partial class MovementSystemGroup : ComponentSystemGroup
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/Group/GameplaySystemGroup.cs

namespace RunawayHeroes.ECS.Systems.Gameplay.Group
{
     <summary>
    /// Gruppo di sistemi che gestisce tutti gli aspetti del gameplay.
    /// Include progressione, tutorial, meccaniche di gioco principali.
    /// </summary>

    public partial class GameplaySystemGroup : ComponentSystemGroup
    {
    }
}


