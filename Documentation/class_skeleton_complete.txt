# Runaway Heroes - Skeleton delle Classi
# Generato il: 10/05/2025 22:23:58
# Questo file contiene definizioni complete di classi, inclusi attributi, campi, proprietà, metodi ed eventi.

## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Authoring/ObstacleAuthoringComponents.cs

namespace RunawayHeroes.Authoring
{
     <summary>
    /// Base class per i componenti di authoring degli ostacoli.
    /// Fornisce funzionalità comuni per tutti i tipi di ostacoli.
    /// </summary>

    public abstract class BaseObstacleAuthoring : MonoBehaviour
    {
        public float height;
        public float width;
        public float collisionRadius;
        public float strength;
        public float damageValue;
        public bool isDestructible;
        public ObstaclePreset preset;
         <summary>
        /// Applica i valori predefiniti in base al preset selezionato
        /// </summary>

        public virtual void ApplyPreset();
    }
     <summary>
    /// Presets predefiniti per la configurazione rapida degli ostacoli
    /// </summary>

    public enum ObstaclePreset
    {
        Custom,
        Small,
        Medium,
        Large
    }
     <summary>
    /// Componente di authoring per ostacoli standard senza tag speciali
    /// </summary>

    public class StandardObstacleAuthoring : BaseObstacleAuthoring
    {
    }
     <summary>
    /// Baker per ostacoli standard
    /// </summary>

    public class StandardObstacleBaker : Baker<StandardObstacleAuthoring>
    {
        public override void Bake(StandardObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per ostacoli di lava (Ember può attraversarli con Corpo Ignifugo)
    /// </summary>

    public class LavaObstacleAuthoring : BaseObstacleAuthoring
    {
        public float damagePerSecond;
    }
     <summary>
    /// Baker per ostacoli di lava
    /// </summary>

    public class LavaObstacleBaker : Baker<LavaObstacleAuthoring>
    {
        public override void Bake(LavaObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per ostacoli di ghiaccio (Kai può scioglierli con Aura di Calore)
    /// </summary>

    public class IceObstacleAuthoring : BaseObstacleAuthoring
    {
        public float maxIntegrity;
    }
     <summary>
    /// Baker per ostacoli di ghiaccio
    /// </summary>

    public class IceObstacleBaker : Baker<IceObstacleAuthoring>
    {
        public override void Bake(IceObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per superfici scivolose (Kai con Aura di Calore è immune)
    /// </summary>

    public class SlipperyObstacleAuthoring : BaseObstacleAuthoring
    {
        public float slipFactor;
    }
     <summary>
    /// Baker per superfici scivolose
    /// </summary>

    public class SlipperyObstacleBaker : Baker<SlipperyObstacleAuthoring>
    {
        public override void Bake(SlipperyObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per barriere digitali (Neo può attraversarle con Glitch Controllato)
    /// </summary>

    public class DigitalBarrierAuthoring : BaseObstacleAuthoring
    {
        public override void ApplyPreset();
    }
     <summary>
    /// Baker per barriere digitali
    /// </summary>

    public class DigitalBarrierBaker : Baker<DigitalBarrierAuthoring>
    {
        public override void Bake(DigitalBarrierAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per zone subacquee (Marina è avvantaggiata con Bolla d'Aria)
    /// </summary>

    public class UnderwaterObstacleAuthoring : BaseObstacleAuthoring
    {
        public bool requiresOxygen;
        public float currentStrength;
        public Vector3 currentDirection;
    }
     <summary>
    /// Baker per zone subacquee
    /// </summary>

    public class UnderwaterObstacleBaker : Baker<UnderwaterObstacleAuthoring>
    {
        public override void Bake(UnderwaterObstacleAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per correnti d'aria (utilizzate in vari mondi)
    /// </summary>

    public class AirCurrentAuthoring : BaseObstacleAuthoring
    {
        public float currentStrength;
        public Vector3 currentDirection;
    }
     <summary>
    /// Baker per correnti d'aria
    /// </summary>

    public class AirCurrentBaker : Baker<AirCurrentAuthoring>
    {
        public override void Bake(AirCurrentAuthoring authoring);
    }
     <summary>
    /// Componente di authoring per zone di gas tossico
    /// </summary>

    public class ToxicGasAuthoring : BaseObstacleAuthoring
    {
        public float damagePerSecond;
    }
     <summary>
    /// Baker per zone di gas tossico
    /// </summary>

    public class ToxicGasBaker : Baker<ToxicGasAuthoring>
    {
        public override void Bake(ToxicGasAuthoring authoring);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/TutorialScenarioEditor.cs



## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/TutorialSequenceEditor.cs

namespace RunawayHeroes.Editor
{
     <summary>
    /// Editor personalizzato per la configurazione della sequenza di tutorial
    /// </summary>

    public class TutorialSequenceEditor : UnityEditor.Editor
    {
        private bool _showTutorialSequence;
        private bool[] _showTutorialDetails;
        private bool _showScenarios;
        public override void OnInspectorGUI();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/TutorialTestHelper.cs

namespace RunawayHeroes.Editor
{
     <summary>
    /// Helper classe per testare il livello tutorial dall'editor
    /// </summary>

    public class TutorialTestHelper : EditorWindow
    {
        private TutorialLevelInitializer _tutorialInitializer;
        private bool _defaultSettings;
        private WorldTheme _selectedTheme;
        private int _tutorialLength;
        private int _seed;
        private Vector3 _playerStartPos;
        public static void ShowWindow();
        private void OnGUI();
         <summary>
        /// Crea un GameObject con l'inizializzatore del tutorial
        /// </summary>

        private void CreateTutorialManager();
         <summary>
        /// Genera un livello tutorial per il test
        /// </summary>

        private void GenerateTutorialLevel();
         <summary>
        /// Cancella il livello tutorial generato
        /// </summary>

        private void ClearTutorialLevel();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/ShopMenuController.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il menu del negozio che permette acquisti in-app
    /// e gestione del pass premium.
    /// </summary>

    public class ShopMenuController : MonoBehaviour
    {
        public string categoryName;
        public GameObject categoryPanel;
        public Button categoryButton;
        public string itemName;
        public string itemDescription;
        public Sprite itemIcon;
        public string itemId;
        public int price;
        public Button buyButton;
        public GameObject purchasedIndicator;
        [SerializeField] private List<ShopCategory> categories;
        [SerializeField] private List<ShopItem> items;
        [SerializeField] private Button premiumPassButton;
        [SerializeField] private TextMeshProUGUI premiumPassStatusText;
        [SerializeField] private GameObject premiumPassBenefitsPanel;
        [SerializeField] private TextMeshProUGUI coinsText;
        [SerializeField] private TextMeshProUGUI gemsText;
        [SerializeField] private Button backButton;
        [SerializeField] private Button addCoinsButton;
        [SerializeField] private Button addGemsButton;
        private GameObject currentCategoryPanel;
        private void Start();
        private void InitializeUI();
        private void InitializeCategories();
        private void InitializeShopItems();
        private void ShowCategory(int categoryIndex);
        private void PurchaseItem(ShopItem item);
        private void UpdatePremiumPassStatus();
        private void UpdateCurrencyDisplay();
        private bool IsItemPurchased(string itemId);
        private void OnBackButtonClicked();
        private void OnAddCoinsClicked();
        private void OnAddGemsClicked();
        private void OnPremiumPassClicked();
    }
    public class ShopCategory
    {
        public string categoryName;
        public GameObject categoryPanel;
        public Button categoryButton;
    }
    public class ShopItem
    {
        public string itemName;
        public string itemDescription;
        public Sprite itemIcon;
        public string itemId;
        public int price;
        public Button buyButton;
        public GameObject purchasedIndicator;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/TutorialMessagePanel.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il pannello dei messaggi di tutorial.
    /// Gestisce l'aspetto visivo e le animazioni del pannello.
    /// </summary>

    public class TutorialMessagePanel : MonoBehaviour
    {
        [SerializeField] private TextMeshProUGUI messageText;
        [SerializeField] private Image backgroundImage;
        [SerializeField] private Image iconImage;
        [SerializeField] private CanvasGroup canvasGroup;
        [SerializeField] private float fadeInTime;
        [SerializeField] private float fadeOutTime;
        [SerializeField] private AnimationCurve fadeCurve;
        [SerializeField] private Color tutorialColor;
        [SerializeField] private Color notificationColor;
        [SerializeField] private Color warningColor;
        [SerializeField] private Sprite[] typeIcons;
        private Animator _animator;
        private Coroutine _currentAnimation;
        private void Awake();
         <summary>
        /// Mostra il messaggio con il testo e il tipo specificati
        /// </summary>

        public void ShowMessage(string message, byte messageType);
         <summary>
        /// Nasconde il messaggio
        /// </summary>

        public void HideMessage();
         <summary>
        /// Animazione di fade in
        /// </summary>

        private IEnumerator FadeIn();
         <summary>
        /// Animazione di fade out
        /// </summary>

        private IEnumerator FadeOut();
         <summary>
        /// Disattiva il pannello dopo un ritardo
        /// </summary>

        private IEnumerator DisableAfterDelay(float delay);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/ArcadeMenuController.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il menu della modalità Arcade, che permette
    /// di rigiocare livelli già completati.
    /// </summary>

    public class ArcadeMenuController : MonoBehaviour
    {
        public string worldName;
        public Sprite worldIcon;
        public GameObject levelSelectionPanel;
        public List<LevelButton> levels;
        public string levelName;
        public string scenePath;
        public Button button;
        public Image completionStar;
        public TextMeshProUGUI highScoreText;
        [SerializeField] private List<WorldCategory> worlds;
        [SerializeField] private Transform worldButtonContainer;
        [SerializeField] private GameObject worldButtonPrefab;
        [SerializeField] private Button backButton;
        [SerializeField] private TextMeshProUGUI titleText;
        private GameObject currentPanel;
        private void Start();
        private void InitializeUI();
        private void InitializeWorldButtons();
        private void InitializeLevelButtons();
        private void ShowWorldSelection();
        private void OnWorldSelected(int worldIndex);
        private void OnLevelSelected(string scenePath);
        private void OnBackButtonClicked();
        private bool IsWorldUnlocked(int worldIndex);
        private bool IsLevelCompleted(string levelPath);
        private int GetLevelHighScore(string levelPath);
    }
    public class WorldCategory
    {
        public string worldName;
        public Sprite worldIcon;
        public GameObject levelSelectionPanel;
        public List<LevelButton> levels;
    }
    public class LevelButton
    {
        public string levelName;
        public string scenePath;
        public Button button;
        public Image completionStar;
        public TextMeshProUGUI highScoreText;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/MenuController.cs

namespace RunawayHeroes.Runtime.UI
{
     <summary>
    /// Controller per il menu principale, gestisce le interazioni specifiche
    /// e le animazioni del menu.
    /// </summary>

    public class MenuController : MonoBehaviour
    {
        [SerializeField] private GameObject menuBackground;
        [SerializeField] private GameObject logoElement;
        [SerializeField] private Button[] menuButtons;
        [SerializeField] private TextMeshProUGUI versionText;
        [SerializeField] private string versionNumber;
        [SerializeField] private Animator menuAnimator;
        private GameObject currentCharacterDisplay;
        private int currentCharacterIndex;
        private void Start();
        private void InitializeMenu();
        private void Update();
         <summary>
        /// Gestisce il pulsante back
        /// </summary>

        private void HandleBackButton();
         <summary>
        /// Riproduce un suono di clic per i pulsanti
        /// </summary>

        public void PlayButtonClickSound();
        private void OnDestroy();
    }
     <summary>
    /// Utility class per gestire il pulsante back (Android/iOS)
    /// </summary>

    public static class BackButtonHandler
    {
        public static void InvokeBackButton();
        public static event BackButtonEvent OnBackButtonPressed;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/UI/UITransitionManager.cs

namespace RunawayHeroes.Runtime.UI
{
    public class UITransitionManager : MonoBehaviour
    {
        [SerializeField] private Image transitionImage;
        [SerializeField] private float transitionDuration;
        private void Start();
        public void FadeIn(System.Action onComplete);
        public void FadeOut(System.Action onComplete);
        private IEnumerator FadeRoutine(float startAlpha, float endAlpha, float duration, System.Action onComplete);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/GameBootstrap.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// 
    /// </summary>

    public class GameBootstrap : MonoBehaviour
    {
        private void Start();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/ECSBootstrap.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// Sistema di bootstrap per l'inizializzazione dell'Entity Component System.
    /// Questo componente crea e registra tutti i sistemi ECS necessari per il gioco.
    /// </summary>

    public class ECSBootstrap : MonoBehaviour
    {
        private World _world;
        private bool _initialized;
         <summary>
        /// Inizializza il sistema ECS all'avvio del gioco
        /// </summary>

        private void Start();
         <summary>
        /// Crea e registra tutti i sistemi ECS necessari
        /// </summary>

        private void InitializeECS();
         <summary>
        /// Aggiunge i sistemi in modo sicuro, evitando dipendenze circolari
        /// </summary>

        private void AddSystemsSafely(List<Type> systems, SimulationSystemGroup simulationSystemGroup);
        private void AddCoreSystems(List<Type> systems);
        private void AddInputSystems(List<Type> systems);
        private void AddMovementSystems(List<Type> systems);
        private void AddAbilitySystems(List<Type> systems);
        private void AddCombatSystems(List<Type> systems);
        private void AddAISystems(List<Type> systems);
        private void AddGameplaySystems(List<Type> systems);
        private void AddWorldSystems(List<Type> systems);
        private void AddUISystems(List<Type> systems);
        private void AddEventHandlers(List<Type> systems);
         <summary>
        /// Pulisce le risorse quando il componente viene distrutto
        /// </summary>

        private void OnDestroy();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/TutorialObstacleInitializer.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// Inizializzatore che gestisce la creazione di scenari di ostacoli per i livelli tutorial.
    /// </summary>

    public class TutorialObstacleInitializer : MonoBehaviour
    {
        public string scenarioName;
        public ObstacleSetup[] obstacles;
        public float startPositionZ;
        public float endPositionZ;
        public ObstacleType type;
        public ObstaclePreset preset;
        public Vector3 position;
        public float rotation;
        public float damagePerSecond;
        public float maxIntegrity;
        public float slipFactor;
        public float currentStrength;
        public Vector3 currentDirection;
        public bool requiresOxygen;
        public float height;
        public float width;
        public float collisionRadius;
        public float strength;
        public float damageValue;
        public bool isDestructible;
        [SerializeField] private ScenarioSetup[] scenarios;
        [SerializeField] private bool showDebugGizmos;
        [SerializeField] private Color gizmoColor;
        private EntityManager _entityManager;
        private EntityArchetype _standardObstacleArchetype;
        private EntityArchetype _lavaObstacleArchetype;
        private EntityArchetype _iceObstacleArchetype;
        private EntityArchetype _slipperyObstacleArchetype;
        private EntityArchetype _digitalBarrierArchetype;
        private EntityArchetype _underwaterObstacleArchetype;
        private EntityArchetype _airCurrentArchetype;
        private EntityArchetype _toxicGasArchetype;
        private void Awake();
        private void Start();
        private void InitializeArchetypes();
        private void InitializeScenarios();
        private void InitializeScenario(ScenarioSetup scenario);
        private void CreateObstacle(ObstacleSetup setup);
        private void OnDrawGizmos();
    }
    public class ScenarioSetup
    {
        public string scenarioName;
        public ObstacleSetup[] obstacles;
        public float startPositionZ;
        public float endPositionZ;
    }
    public class ObstacleSetup
    {
        public ObstacleType type;
        public ObstaclePreset preset;
        public Vector3 position;
        public float rotation;
        public float damagePerSecond;
        public float maxIntegrity;
        public float slipFactor;
        public float currentStrength;
        public Vector3 currentDirection;
        public bool requiresOxygen;
        public float height;
        public float width;
        public float collisionRadius;
        public float strength;
        public float damageValue;
        public bool isDestructible;
    }
    public enum ObstacleType
    {
        Standard,
        Lava,
        Ice,
        Slippery,
        DigitalBarrier,
        Underwater,
        AirCurrent,
        ToxicGas
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bootstrap/WorldBootstrap.cs

namespace RunawayHeroes.Runtime.Bootstrap
{
     <summary>
    /// 
    /// </summary>

    public class WorldBootstrap : MonoBehaviour
    {
        private void Start();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Boot/BootSequence.cs

namespace RunawayHeroes.Runtime.Boot
{
    public class BootSequence : MonoBehaviour
    {
        [SerializeField] private CanvasGroup fadeOverlay;
        [SerializeField] private Image logoImage;
        [SerializeField] private RectTransform logoTransform;
        [SerializeField] private Text versionText;
        [SerializeField] private float logoDelay;
        [SerializeField] private float totalDuration;
        [SerializeField] private float fadeInDuration;
        [SerializeField] private float fadeOutDuration;
        [SerializeField] private bool initializeECS;
        [SerializeField] private string nextSceneName;
        [SerializeField] private string versionNumber;
        private bool _isInitialized;
        private void Awake();
        private void Start();
        private IEnumerator DelayedBootStart();
        private IEnumerator BootSequenceCoroutine();
        private void InitializeECSSystem();
        private IEnumerator AnimateLogo();
        private IEnumerator FadeCanvasGroup(CanvasGroup group, float startAlpha, float targetAlpha, float duration);
        private float BounceEaseOut(float t);
        public void ForceCompleteSequence();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/UnityCameraBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Bridge che collega la Camera di Unity con il sistema ECS.
    /// Permette al sistema ECS di controllare o essere informato sulla camera.
    /// </summary>

    public class UnityCameraBridge : MonoBehaviour
    {
        [SerializeField] private float followSpeed;
        [SerializeField] private float smoothTime;
        [SerializeField] private float lookAheadDistance;
        [SerializeField] private Vector3 offset;
        private Camera _camera;
        private Entity _cameraEntity;
        private EntityManager _entityManager;
        public override void Bake(UnityCameraBridge authoring);
        private void Awake();
        private void Start();
        private void LateUpdate();
    }
    public class CameraBridgeBaker : Baker<UnityCameraBridge>
    {
        public override void Bake(UnityCameraBridge authoring);
    }
     <summary>
    /// Tag per identificare l'entità camera
    /// </summary>

    public struct CameraTag : IComponentData
    {
    }
     <summary>
    /// Componente che memorizza le impostazioni della camera
    /// </summary>

    public struct CameraSettingsComponent : IComponentData
    {
        public float FollowSpeed;
        public float SmoothTime;
        public float LookAheadDistance;
        public float3 Offset;
    }
     <summary>
    /// Componente che tiene traccia del target della camera
    /// </summary>

    public struct CameraTargetComponent : IComponentData
    {
        public Entity TargetEntity;
        public bool IsFollowing;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/UnityPhysicsBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Bridge che collega il sistema di fisica di Unity con il sistema ECS.
    /// Permette di sincronizzare collisioni e forze tra i due sistemi.
    /// </summary>

    public class UnityPhysicsBridge : MonoBehaviour
    {
        [SerializeField] private float gravity;
        [SerializeField] private float mass;
        [SerializeField] private float friction;
        [SerializeField] private bool useGravity;
        [SerializeField] private LayerMask groundLayers;
        private Rigidbody _rigidbody;
        private Entity _physicsEntity;
        private EntityManager _entityManager;
        private bool _isGrounded;
        public override void Bake(UnityPhysicsBridge authoring);
        private void Awake();
        private void Start();
        private void FixedUpdate();
        private void CheckGrounded();
        private void OnCollisionEnter(Collision collision);
    }
    public class PhysicsBridgeBaker : Baker<UnityPhysicsBridge>
    {
        public override void Bake(UnityPhysicsBridge authoring);
    }
     <summary>
    /// Tag per identificare l'entità fisica
    /// </summary>

    public struct PhysicsTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/InputBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Componente bridge che collega il sistema di input di Unity con l'ECS.
    /// Questo componente deve essere aggiunto a un GameObject nella scena
    /// e si occupa di convertire gli input in componenti ECS.
    /// </summary>

    public class InputBridge : MonoBehaviour
    {
        public float lateralSensitivity;
        public float focusTimeActivationDuration;
        public bool enableKeyboardControls;
        public bool enableTouchControls;
        private Touch? currentTouch;
        private float touchStartTime;
        private float lastLateralInput;
        private Entity _inputEntity;
        private EntityManager _entityManager;
        private EntityCommandBuffer _commandBuffer;
        public override void Bake(InputBridge authoring);
         <summary>
        /// Inizializza il bridge all'avvio
        /// </summary>

        private void Start();
         <summary>
        /// Aggiorna gli input ad ogni frame
        /// </summary>

        private void Update();
         <summary>
        /// Metodo chiamato quando il bridge viene abilitato
        /// </summary>

        private void OnEnable();
         <summary>
        /// Metodo chiamato quando il bridge viene disabilitato
        /// </summary>

        private void OnDisable();
         <summary>
        /// Implementazione di Unity per update visivi
        /// </summary>

        private void OnGUI();
        private void ProcessFocusTimeInput(Entity playerEntity);
        private void ProcessMovementInput(Entity playerEntity);
        private void ProcessJumpInput(Entity playerEntity);
        private void ProcessSlideInput(Entity playerEntity);
        private void ProcessAbilityInput(Entity playerEntity);
    }
    public class InputBridgeBaker : Baker<InputBridge>
    {
        public override void Bake(InputBridge authoring);
    }
     <summary>
    /// Componente tag per identificare l'entità InputBridge
    /// </summary>

    public struct InputBridgeTag : IComponentData
    {
    }
     <summary>
    /// Componente per memorizzare le impostazioni di input
    /// </summary>

    public struct InputSettingsComponent : IComponentData
    {
        public float LateralSensitivity;
        public float FocusTimeActivationDuration;
        public bool EnableKeyboardControls;
        public bool EnableTouchControls;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Bridge/PlayerBridge.cs

namespace RunawayHeroes.Runtime.Bridge
{
     <summary>
    /// Bridge che collega i GameObject del giocatore con il sistema ECS.
    /// Gestisce la conversione delle proprietà del giocatore in componenti ECS.
    /// </summary>

    public class PlayerBridge : MonoBehaviour
    {
        [SerializeField] private CharacterType characterType;
        [SerializeField] private float maxHealth;
        [SerializeField] private float movementSpeed;
        [SerializeField] private float jumpForce;
        public override void Bake(PlayerBridge authoring);
        private static WorldType GetWorldTypeFromCharacter(CharacterType characterType);
    }
    public class PlayerBridgeBaker : Baker<PlayerBridge>
    {
        public override void Bake(PlayerBridge authoring);
        private static WorldType GetWorldTypeFromCharacter(CharacterType characterType);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/LevelManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// 
    /// </summary>

    public class LevelManager : MonoBehaviour
    {
        public static LevelManager Instance { get; set; }
        private void Awake();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/AudioManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// Gestore centralizzato del sistema audio del gioco.
    /// Supporta effetti sonori, musica di sottofondo e transizioni audio.
    /// </summary>

    public class AudioManager : MonoBehaviour
    {
        public string name;
        public AudioClip clip;
        public float volume;
        public float pitch;
        public float spatialBlend;
        public bool loop;
        public AudioSource source;
        [SerializeField] private Sound[] sfxSounds;
        [SerializeField] private Sound[] musicSounds;
        [SerializeField] private AudioMixerGroup sfxMixerGroup;
        [SerializeField] private AudioMixerGroup musicMixerGroup;
        [SerializeField] private float masterVolume;
        [SerializeField] private float sfxVolume;
        [SerializeField] private float musicVolume;
        private Dictionary<string, Sound> _soundsDictionary;
        private string _currentMusic;
        public static AudioManager Instance { get; set; }
        private void Awake();
        private void InitializeSounds();
         <summary>
        /// Riproduce un effetto sonoro.
        /// </summary>
        /// <param name="soundName">Nome dell'effetto sonoro da riprodurre</param>

        public void PlaySound(string soundName);
         <summary>
        /// Riproduce un effetto sonoro una sola volta, anche se già in esecuzione.
        /// </summary>
        /// <param name="soundName">Nome dell'effetto sonoro da riprodurre</param>

        public void PlaySoundOneShot(string soundName);
         <summary>
        /// Riproduce un brano musicale con dissolvenza.
        /// </summary>
        /// <param name="musicName">Nome del brano musicale da riprodurre</param>
        /// <param name="fadeTime">Tempo di dissolvenza in secondi</param>

        public void PlayMusic(string musicName, float fadeTime);
         <summary>
        /// Interrompe un suono.
        /// </summary>
        /// <param name="soundName">Nome del suono da interrompere</param>

        public void StopSound(string soundName);
         <summary>
        /// Interrompe tutti i suoni.
        /// </summary>

        public void StopAllSounds();
         <summary>
        /// Mette in pausa tutti i suoni.
        /// </summary>

        public void PauseAllSounds();
         <summary>
        /// Riprende tutti i suoni in pausa.
        /// </summary>

        public void ResumeAllSounds();
         <summary>
        /// Imposta il volume master.
        /// </summary>
        /// <param name="volume">Volume da 0 a 1</param>

        public void SetMasterVolume(float volume);
         <summary>
        /// Imposta il volume degli effetti sonori.
        /// </summary>
        /// <param name="volume">Volume da 0 a 1</param>

        public void SetSFXVolume(float volume);
         <summary>
        /// Imposta il volume della musica.
        /// </summary>
        /// <param name="volume">Volume da 0 a 1</param>

        public void SetMusicVolume(float volume);
        private void UpdateAllVolumes();
        private void SaveVolumeSettings();
        private void LoadVolumeSettings();
        private System.Collections.IEnumerator FadeIn(AudioSource audioSource, float targetVolume, float duration);
        private System.Collections.IEnumerator FadeOut(AudioSource audioSource, float duration);
         <summary>
        /// Riproduce un effetto sonoro (alias per PlaySound).
        /// </summary>
        /// <param name="sfxName">Nome dell'effetto sonoro da riprodurre</param>

        public void PlaySFX(string sfxName);
    }
    public class Sound
    {
        public string name;
        public AudioClip clip;
        public float volume;
        public float pitch;
        public float spatialBlend;
        public bool loop;
        public AudioSource source;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/MainMenuManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// Manager specifico per il menu principale che estende la funzionalità
    /// del UIManager per gestire la navigazione tra livelli e altre interazioni
    /// specifiche del menu principale.
    /// </summary>

    public class MainMenuManager : MonoBehaviour
    {
        [SerializeField] private string mainMenuPanelName;
        [SerializeField] private string arcadeMenuPanelName;
        [SerializeField] private string shopMenuPanelName;
        [SerializeField] private string settingsPanelName;
        [SerializeField] private Button playButton;
        [SerializeField] private Button continueButton;
        [SerializeField] private Button arcadeButton;
        [SerializeField] private Button shopButton;
        [SerializeField] private Button settingsButton;
        [SerializeField] private UITransitionManager transitionManager;
        [SerializeField] private GameObject loadingPanel;
        [SerializeField] private float transitionTime;
        [SerializeField] private float uiManagerCheckDelay;
        private UIManager _uiManager;
        private bool _hasSaveGame;
        private bool _initialized;
        private void Start();
        private void TryInitialize();
        private IEnumerator RetryInitialization();
        private void InitializeUI();
         <summary>
        /// Carica una scena di gioco con effetto di transizione
        /// </summary>

        public void LoadGameScene(string sceneName);
        private System.Collections.IEnumerator LoadSceneAsync(string sceneName);
        private void OnPlayButtonClicked();
        private void OnContinueButtonClicked();
        private void OnArcadeButtonClicked();
        private void OnShopButtonClicked();
        private void OnSettingsButtonClicked();
        private System.Collections.IEnumerator LoadSceneCoroutine(string sceneName);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/UIManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// Gestore centralizzato del sistema UI del gioco.
    /// Controlla pannelli, schermate, transizioni e stati dell'interfaccia.
    /// </summary>

    public class UIManager : MonoBehaviour
    {
        public string name;
        public GameObject panel;
        public Animator animator;
        public bool activeAtStart;
        [SerializeField] private UIPanel[] panels;
        [SerializeField] private Animator transitionAnimator;
        [SerializeField] private float transitionTime;
        [SerializeField] private Button globalBackButton;
        [SerializeField] private GameObject loadingIndicator;
        private Dictionary<string, UIPanel> _panelsDictionary;
        private Stack<string> _panelHistory;
        private string _currentPanel;
        public static UIManager Instance { get; set; }
        private void Awake();
        private void InitializePanels();
         <summary>
        /// Apre un pannello UI specifico.
        /// </summary>
        /// <param name="panelName">Nome del pannello da aprire</param>
        /// <param name="addToHistory">Se true, il pannello corrente viene aggiunto alla cronologia</param>

        public void OpenPanel(string panelName, bool addToHistory);
         <summary>
        /// Torna al pannello precedente nella cronologia.
        /// </summary>

        public void BackToPreviousPanel();
         <summary>
        /// Chiude tutti i pannelli e apre il pannello specificato.
        /// </summary>
        /// <param name="panelName">Nome del pannello da aprire</param>

        public void SwitchToPanel(string panelName);
         <summary>
        /// Ritorna al menu principale resettando la cronologia.
        /// </summary>

        public void ReturnToMainMenu();
         <summary>
        /// Mostra l'indicatore di caricamento.
        /// </summary>
        /// <param name="show">True per mostrare, False per nascondere</param>

        public void ShowLoadingIndicator(bool show);
         <summary>
        /// Aggiorna un testo UI specifico.
        /// </summary>
        /// <param name="panelName">Nome del pannello contenente il testo</param>
        /// <param name="textName">Nome del componente di testo</param>
        /// <param name="value">Nuovo valore del testo</param>

        public void UpdateText(string panelName, string textName, string value);
         <summary>
        /// Aggiorna un'immagine UI specifica.
        /// </summary>
        /// <param name="panelName">Nome del pannello contenente l'immagine</param>
        /// <param name="imageName">Nome del componente di immagine</param>
        /// <param name="sprite">Nuovo sprite dell'immagine</param>

        public void UpdateImage(string panelName, string imageName, Sprite sprite);
         <summary>
        /// Verifica se un pannello specifico è attualmente attivo.
        /// </summary>
        /// <param name="panelName">Nome del pannello da verificare</param>
        /// <returns>True se il pannello è attivo, false altrimenti</returns>

        public bool IsPanelActive(string panelName);
         <summary>
        /// Ottiene il nome del pannello attualmente attivo.
        /// </summary>
        /// <returns>Nome del pannello attivo</returns>

        public string GetCurrentPanelName();
        private void ShowPanel(UIPanel panel);
        private void ClosePanel(UIPanel panel, bool animate);
        private System.Collections.IEnumerator DisablePanelDelayed(GameObject panel, float delay);
        private void StartTransition(System.Action onComplete);
        private System.Collections.IEnumerator InvokeAfterDelay(System.Action action, float delay);
    }
    public class UIPanel
    {
        public string name;
        public GameObject panel;
        public Animator animator;
        public bool activeAtStart;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Managers/GameManager.cs

namespace RunawayHeroes.Runtime.Managers
{
     <summary>
    /// 
    /// </summary>

    public class GameManager : MonoBehaviour
    {
        public static GameManager Instance { get; set; }
        private void Awake();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialManagerWindow.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Gestisce l'interfaccia utente per la selezione e avanzamento dei tutorial
    /// </summary>

    public class TutorialManagerWindow : MonoBehaviour
    {
        [SerializeField] private GameObject tutorialSelectionPanel;
        [SerializeField] private GameObject tutorialButtonPrefab;
        [SerializeField] private Transform tutorialButtonsContainer;
        [SerializeField] private Button backButton;
        [SerializeField] private TextMeshProUGUI titleText;
        [SerializeField] private TutorialLevelInitializer tutorialInitializer;
        private int _highestUnlockedTutorial;
        private void Start();
         <summary>
        /// Carica il progresso del tutorial
        /// </summary>

        private void LoadTutorialProgress();
         <summary>
        /// Inizializza l'UI dei tutorial
        /// </summary>

        private void InitializeUI();
         <summary>
        /// Avvia un tutorial specifico
        /// </summary>

        public void StartTutorial(int tutorialIndex);
         <summary>
        /// Coroutine per avviare il tutorial dopo un breve ritardo
        /// </summary>

        private IEnumerator StartTutorialWithDelay(int tutorialIndex);
         <summary>
        /// Gestisce il click sul pulsante back
        /// </summary>

        private void OnBackButtonClicked();
         <summary>
        /// Sblocca il prossimo tutorial nella sequenza
        /// </summary>

        public void UnlockNextTutorial();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialLevelInitializer.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Inizializzatore per i livelli tutorial, gestisce la configurazione degli scenari
    /// </summary>

    public class TutorialLevelInitializer : MonoBehaviour
    {
        public TutorialLevelData[] tutorialSequence;
        public bool showDebugGizmos;
        public int tutorialLevelIndex;
        public Vector3 playerStartPosition;
        private EntityManager _entityManager;
        private float _currentLevelLength;
        private Vector3 _startPosition;
        private void Awake();
        private void Start();
         <summary>
        /// Inizializza un livello tutorial con la sequenza definita
        /// </summary>

        public void InitializeTutorialLevel();
         <summary>
        /// Avanza alla prossima sequenza tutorial
        /// </summary>

        public void AdvanceToNextTutorialSequence();
         <summary>
        /// Configura gli scenari tutorial per una sequenza
        /// </summary>

        private void SetupTutorialScenarios(TutorialLevelData tutorial);
         <summary>
        /// Pulisce gli scenari tutorial precedenti
        /// </summary>

        private void CleanupPreviousScenarios();
         <summary>
        /// Visualizza gizmo per debug nel mondo
        /// </summary>

        private void OnDrawGizmos();
    }
     <summary>
    /// Temi di mondo disponibili
    /// </summary>

    public enum WorldTheme
    {
        Tutorial,
        City,
        Forest,
        Tundra,
        Volcano,
        Abyss,
        Virtual
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialScenario.cs

namespace RunawayHeroes.Gameplay
{
     <summary>
    /// Rappresenta uno scenario di insegnamento nel tutorial
    /// </summary>

    public struct TutorialScenario
    {
        public string name;
        public float distanceFromStart;
        public ObstacleSetup[] obstacles;
        public string instructionMessage;
        public float messageDuration;
        public bool randomPlacement;
        public float obstacleSpacing;
         <summary>
        /// Crea uno scenario di base per il tutorial
        /// </summary>

        public static TutorialScenario CreateBasic(string name, float distance, string message);
         <summary>
        /// Crea uno scenario per insegnare il salto
        /// </summary>

        public static TutorialScenario CreateJumpScenario(float distance);
         <summary>
        /// Crea uno scenario per insegnare la scivolata
        /// </summary>

        public static TutorialScenario CreateSlideScenario(float distance);
         <summary>
        /// Crea uno scenario per insegnare i movimenti laterali
        /// </summary>

        public static TutorialScenario CreateSideStepScenario(float distance);
         <summary>
        /// Crea uno scenario con diversi tipi di ostacoli per movimenti combinati
        /// </summary>

        public static TutorialScenario CreateCombinedMovesScenario(float distance);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialSceneSetup.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Componente che gestisce il setup iniziale della scena del tutorial
    /// </summary>

    public class TutorialSceneSetup : MonoBehaviour
    {
        public GameObject playerPrefab;
        public GameObject cameraPrefab;
        public Vector3 playerStartPosition;
        public int defaultCharacterId;
        public TutorialLevelInitializer tutorialInitializer;
        public bool loadMainMenuOnCompletion;
        private GameObject _player;
        private GameObject _camera;
        private void Awake();
        private void Start();
         <summary>
        /// Spawna il giocatore nella scena
        /// </summary>

        private void SpawnPlayer();
         <summary>
        /// Configura la telecamera per seguire il giocatore
        /// </summary>

        private void SetupCamera();
         <summary>
        /// Configura il personaggio selezionato
        /// </summary>

        private void SetupCharacter(int characterId);
         <summary>
        /// Registra la callback per il completamento del tutorial
        /// </summary>

        private void RegisterTutorialCompletionCallback();
        private void Update();
         <summary>
        /// Carica il prossimo tutorial o torna al menu principale
        /// </summary>

        private void LoadMainMenu();
         <summary>
        /// Carica il prossimo tutorial nella sequenza
        /// </summary>

        private void LoadNextTutorial();
    }
     <summary>
    /// Classe segnaposto per la telecamera che segue il giocatore
    /// In un gioco reale, questa sarebbe una implementazione completa
    /// </summary>

    public class CameraFollow : MonoBehaviour
    {
        public Transform target;
        public Vector3 offset;
        public float smoothSpeed;
        private void LateUpdate();
    }
     <summary>
    /// Classe segnaposto per il tracciamento del progresso del tutorial
    /// In un gioco reale, questa sarebbe gestita da un sistema più complesso
    /// </summary>

    public class ProgressTracker : MonoBehaviour
    {
        private bool _tutorialCompleted;
        private float _progressPercentage;
        public void SetProgress(float percentage);
        public bool IsTutorialCompleted();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/TutorialLevelSequence.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Definisce una sequenza di livelli tutorial con progressione di difficoltà
    /// </summary>

    public struct TutorialLevelData
    {
        public string description;
        public WorldTheme theme;
        public int length;
        public int difficulty;
        public float obstacleDensity;
        public float enemyDensity;
        public TutorialScenario[] scenarios;
    }
     <summary>
    /// Definisce uno scenario di insegnamento specifico in un livello tutorial
    /// </summary>

    public struct TutorialScenario
    {
        public string name;
        public float distanceFromStart;
        public ObstacleSetup[] obstacles;
        public string instructionMessage;
        public float messageDuration;
        public bool randomPlacement;
        public float obstacleSpacing;
    }
     <summary>
    /// Configurazione di un tipo di ostacolo per uno scenario tutorial
    /// </summary>

    public struct ObstacleSetup
    {
        public string obstacleCode;
        public int count;
        public ObstaclePlacement placement;
        public bool randomizeHeight;
        public Vector2 heightRange;
        public bool randomizeScale;
        public Vector2 scaleRange;
        public float startOffset;
    }
     <summary>
    /// Posizionamento laterale degli ostacoli
    /// </summary>

    public enum ObstaclePlacement
    {
        Center,
        Left,
        Right,
        Random,
        Pattern
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Characters/PlayerController.cs

namespace RunawayHeroes.Runtime.Characters
{
     <summary>
    /// Controllore del personaggio giocatore che funziona sia in gioco normale
    /// che nel tutorial
    /// </summary>

    public class PlayerController : MonoBehaviour
    {
        public float forwardSpeed;
        public float acceleration;
        public float maxSpeed;
        public float lateralSpeed;
        public float jumpForce;
        public float gravity;
        public int maxJumps;
        public float slideDuration;
        public float slideHeightReduction;
        public ParticleSystem runningEffect;
        public ParticleSystem jumpEffect;
        public ParticleSystem slideEffect;
        public Animator animator;
        private CharacterController _controller;
        private Entity _playerEntity;
        private EntityManager _entityManager;
        private Vector3 _moveDirection;
        private float _currentSpeed;
        private bool _isJumping;
        private bool _isSliding;
        private float _slideTimer;
        private int _jumpCount;
        private float _defaultHeight;
        private float _slidingHeight;
        private Vector3 _defaultCenter;
        private Vector3 _slidingCenter;
        private bool _isTutorial;
        private readonly int _animIsRunning;
        private readonly int _animIsJumping;
        private readonly int _animIsSliding;
        private readonly int _animRunSpeed;
        private void Awake();
        private void Start();
        private void Update();
         <summary>
        /// Gestisce l'input del giocatore
        /// </summary>

        private void HandleInput();
         <summary>
        /// Applica il movimento al character controller
        /// </summary>

        private void ApplyMovement();
         <summary>
        /// Aggiorna le animazioni del personaggio
        /// </summary>

        private void UpdateAnimation();
         <summary>
        /// Aggiorna gli effetti particellari
        /// </summary>

        private void UpdateEffects();
         <summary>
        /// Crea un'entità ECS per il player
        /// </summary>

        private void CreatePlayerEntity();
         <summary>
        /// Aggiorna l'entità ECS del giocatore
        /// </summary>

        private void UpdatePlayerEntity();
         <summary>
        /// Verifica se ci troviamo nella modalità tutorial
        /// </summary>

        private bool IsTutorialMode();
         <summary>
        /// Imposta un personaggio specifico
        /// </summary>

        public void SetCharacterId(int characterId);
    }
     <summary>
    /// Componente per il movimento del giocatore nell'ECS
    /// </summary>

    public struct PlayerMovementComponent : IComponentData
    {
        public float ForwardSpeed;
        public float LateralSpeed;
        public bool IsJumping;
        public bool IsSliding;
    }
     <summary>
    /// Componente per la trasformazione nell'ECS
    /// </summary>

    public struct TransformComponent : IComponentData
    {
        public Vector3 Position;
        public Quaternion Rotation;
        public Vector3 Scale;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Core/SystemGroups.cs

namespace RunawayHeroes.ECS.Core
{
     <summary>
    /// Gruppo di sistemi per la gestione delle trasformazioni e del movimento
    /// </summary>

    public partial class TransformSystemGroup : ComponentSystemGroup
    {
    }
     <summary>
    /// Gruppo di sistemi per la gestione degli input
    /// </summary>

    public partial class InputSystemGroup : ComponentSystemGroup
    {
    }
     <summary>
    /// Gruppo di sistemi per la gestione della fisica e delle collisioni
    /// </summary>

    public partial class PhysicsSystemGroup : ComponentSystemGroup
    {
    }
     <summary>
    /// Gruppo di sistemi per la gestione del movimento
    /// </summary>

    public partial class MovementSystemGroup : ComponentSystemGroup
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/EntityQueries.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class EntityQueries
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/ECSLogger.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class ECSLogger
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/ComponentExtensions.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// Classe di estensione che fornisce metodi di utilità per lavorare con componenti ECS.
    /// Offre funzionalità per semplificare operazioni comuni sui componenti come clonazione,
    /// conversione, ricerca, e manipolazione di valori.
    /// </summary>

    public static class ComponentExtensions
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/EntityDebugger.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class EntityDebugger
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Utilities/SystemUtilities.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// Classe di utilità che fornisce metodi e funzioni helper per l'implementazione
    /// e l'ottimizzazione dei sistemi ECS. Include strumenti per profiling, gestione 
    /// dei job, creazione di query ottimizzate e altre operazioni comuni.
    /// </summary>

    public static class SystemUtilities
    {
         <summary>
        /// Registra un job come dipendenza per un sistema con gestione degli errori.
        /// </summary>
        /// <param name="system">Sistema in cui registrare la dipendenza</param>
        /// <param name="jobHandle">Handle del job da registrare</param>
        /// <param name="jobName">Nome del job per scopi di diagnostica</param>
        /// <returns>Lo stesso jobHandle per consentire catene di chiamate</returns>

        public static Unity.Jobs.JobHandle RegisterJobDependency(SystemBase system, Unity.Jobs.JobHandle currentDependency, Unity.Jobs.JobHandle jobHandle, string jobName);
         <summary>
        /// Configura un timer per il profiling delle prestazioni di un sistema.
        /// </summary>
        /// <param name="system">Sistema da profilare</param>
        /// <param name="profileName">Nome identificativo per il profiler</param>
        /// <returns>Un oggetto IDisposable che alla Dispose ferma il timer</returns>

        public static System.IDisposable BeginSystemProfiling(SystemBase system, string profileName);
        public void Dispose();
         <summary>
        /// Verifica se un sistema deve essere aggiornato in base alla presenza di entità
        /// che corrispondono ai requisiti e altre condizioni opzionali.
        /// </summary>
        /// <param name="system">Sistema da verificare</param>
        /// <param name="query">Query da utilizzare per verificare la presenza di entità</param>
        /// <param name="additionalCondition">Condizione aggiuntiva opzionale</param>
        /// <returns>True se il sistema deve essere aggiornato, False altrimenti</returns>

        public static bool ShouldUpdateSystem(SystemBase system, EntityQuery query, System.Func<bool> additionalCondition);
    }
     <summary>
        /// Oggetto helper per gestire lo scope del profiler.
        /// </summary>

    private class ProfilerScope : System.IDisposable
    {
        public void Dispose();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/ECSCompatibility/WorldCompatibility.cs

namespace RunawayHeroes.Utilities.ECSCompatibility
{
     <summary>
    /// Classe di utilità che fornisce compatibilità tra diverse versioni di Unity DOTS.
    /// Implementa metodi di estensione per World per supportare proprietà mancanti.
    /// </summary>

    public static class RunawayWorldCompatibility
    {
        private static World _defaultGameObjectInjectionWorld;
        public static World DefaultGameObjectInjectionWorld { get; set; }
         <summary>
        /// Implementazione interna per ottenere il World predefinito.
        /// </summary>

        private static World DefaultGameObjectInjectionWorld_Internal();
    }
     <summary>
    /// Estensione per la classe World che aggiunge proprietà mancanti.
    /// </summary>

    public static class RunawayWorldExtensions
    {
        public static World DefaultGameObjectInjectionWorld { get; set; }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Extensions/StringExtensions.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class StringExtensions
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Extensions/VectorExtensions.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class VectorExtensions
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Helpers/MathHelper.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class MathHelper
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Helpers/StringHelper.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class StringHelper
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Utilities/Helpers/DebugHelper.cs

namespace RunawayHeroes.ECS.Utilities
{
     <summary>
    /// 
    /// </summary>

    public static class DebugHelper
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Gameplay/Obstacles/ObstacleSetup.cs

namespace RunawayHeroes.Gameplay
{
     <summary>
    /// Definisce i possibili posizionamenti per gli ostacoli
    /// </summary>

    public enum ObstaclePlacement
    {
        Center = 0,
        Left = 1,
        Right = 2,
        Random = 3,
        Pattern = 4
    }
     <summary>
    /// Configurazione per un tipo di ostacolo in uno scenario
    /// </summary>

    public struct ObstacleSetup
    {
        public string obstacleCode;
        public int count;
        public ObstaclePlacement placement;
        public bool randomizeHeight;
        public Vector2 heightRange;
        public bool randomizeScale;
        public Vector2 scaleRange;
        public float startOffset;
         <summary>
        /// Creazione di un'istanza base di ObstacleSetup
        /// </summary>

        public static ObstacleSetup CreateDefault();
         <summary>
        /// Creazione di un'istanza per ostacoli da saltare
        /// </summary>

        public static ObstacleSetup CreateJumpObstacles(string code, int count);
         <summary>
        /// Creazione di un'istanza per ostacoli da scivolare sotto
        /// </summary>

        public static ObstacleSetup CreateSlideObstacles(string code, int count);
         <summary>
        /// Creazione di un'istanza per ostacoli da evitare con spostamenti laterali
        /// </summary>

        public static ObstacleSetup CreateSideStepObstacles(string code, int count);
         <summary>
        /// Creazione di un'istanza per ostacoli casuali (livelli avanzati)
        /// </summary>

        public static ObstacleSetup CreateRandomObstacles(string code, int count);
         <summary>
        /// Override del metodo Equals per compatibilità con operatore ==
        /// </summary>

        public override bool Equals(object obj);
         <summary>
        /// Override del metodo GetHashCode per compatibilità con operatore ==
        /// </summary>

        public override int GetHashCode();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/EntityDebugWindow.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class EntityDebugWindow
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/SystemMonitorWindow.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class SystemMonitorWindow
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/DOTSVersionChecker.cs

    public class DOTSVersionChecker : EditorWindow
    {
        public static void ShowWindow();
        private void OnGUI();
        private void CheckDOTSVersions();
        private bool IsDOTSPackage(string packageName);
        private void CheckVersionCompatibility(Dictionary<string, string> packages);
    }


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/SystemDependencyAnalyzer.cs

namespace RunawayHeroes.Editor.ECSDebugger
{
    public class SystemDependencyAnalyzer : EditorWindow
    {
        private Vector2 scrollPosition;
        private bool showAllSystems;
        private bool showOnlyProblematic;
        private List<SystemInfo> systemInfos;
        private List<CyclicDependency> cyclicDependencies;
        public Type Type;
        public string Name;
        public string Group;
        public List<string> UpdateBefore;
        public List<string> UpdateAfter;
        public List<SystemInfo> DependenciesTo;
        public List<SystemInfo> DependenciesFrom;
        public List<SystemInfo> DependentsTo;
        public List<SystemInfo> DependentsFrom;
        public bool IsProblematic;
        public List<SystemInfo> Systems;
        public bool HasDependencies { ... }
        public bool HasDependents { ... }
        public static void ShowWindow();
        private void OnEnable();
        private void OnGUI();
        private void AnalyzeSystems();
        private void FindCyclicDependencies();
        private void FindCycles(SystemInfo start, SystemInfo current, HashSet<SystemInfo> visited, List<SystemInfo> path);
    }
    private class SystemInfo
    {
        public Type Type;
        public string Name;
        public string Group;
        public List<string> UpdateBefore;
        public List<string> UpdateAfter;
        public List<SystemInfo> DependenciesTo;
        public List<SystemInfo> DependenciesFrom;
        public List<SystemInfo> DependentsTo;
        public List<SystemInfo> DependentsFrom;
        public bool IsProblematic;
        public bool HasDependencies { ... }
        public bool HasDependents { ... }
    }
    private class CyclicDependency
    {
        public List<SystemInfo> Systems;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/ECSDebugger/SystemDebugger.cs

    public class SystemDebugger : MonoBehaviour
    {
         void Start();
    }


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/CustomInspectors/ComponentDataInspector.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class ComponentDataInspector
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/CustomInspectors/EntityInspector.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class EntityInspector
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/Validators/LevelValidatorEditor.cs



## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/Wizards/ECSSystemWizard.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class ECSSystemWizard
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Editor/Wizards/ECSComponentWizard.cs

namespace RunawayHeroes
{
     <summary>
    /// 
    /// </summary>

    public class ECSComponentWizard
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/Runtime/Levels/Validation/LevelValidator.cs

namespace RunawayHeroes.Runtime.Levels
{
     <summary>
    /// Sistema di validazione che verifica se un livello generato è completabile
    /// </summary>

    public class LevelValidator : MonoBehaviour
    {
        public float characterRadius;
        public float characterHeight;
        public float characterSlideHeight;
        public float maxJumpHeight;
        public int maxConsecutiveJumps;
        public float maxSideStepDistance;
        public bool showDebugVisualization;
        public bool generateDetailedReport;
        public TutorialLevelInitializer tutorialInitializer;
        private List<ValidationIssue> _validationIssues;
        private const float LANE_WIDTH;
        private const float LEFT_POSITION;
        private const float CENTER_POSITION;
        private const float RIGHT_POSITION;
         <summary>
        /// Esegue la validazione del livello tutorial configurato
        /// </summary>

        public ValidationResult ValidateLevel();
         <summary>
        /// Controlla se ci sono problemi critici che rendono il livello impossibile
        /// </summary>

        private bool HasCriticalIssues();
         <summary>
        /// Stampa il risultato della validazione nel log
        /// </summary>

        private void LogValidationResult(bool isValid);
         <summary>
        /// Valida tutte le sequenze tutorial
        /// </summary>

        private void ValidateTutorialSequences(TutorialLevelData[] sequences);
         <summary>
        /// Valida una sequenza tutorial specifica
        /// </summary>

        private void ValidateTutorialSequence(TutorialLevelData sequence, int sequenceIndex);
         <summary>
        /// Verifica combinazioni impossibili di ostacoli
        /// </summary>

        private void ValidateObstacleCombinations(TutorialScenario scenario);
         <summary>
        /// Verifica che non ci siano sovrapposizioni tra scenari
        /// </summary>

        private void CheckScenarioOverlaps(TutorialLevelData sequence);
         <summary>
        /// Stima la fine di uno scenario in base agli ostacoli presenti
        /// </summary>

        private float EstimateScenarioEnd(TutorialScenario scenario);
         <summary>
        /// Valida uno scenario specifico
        /// </summary>

        private void ValidateScenario(TutorialScenario scenario, TutorialLevelData sequence, int scenarioIndex);
         <summary>
        /// Verifica che la lunghezza della sequenza sia ragionevole
        /// </summary>

        private void ValidateSequenceLength(TutorialLevelData sequence);
         <summary>
        /// Valida una configurazione di ostacoli
        /// </summary>

        private void ValidateObstacleSetup(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica la presenza di collisioni tra diversi ostacoli nello stesso scenario
        /// </summary>

        private void CheckForObstacleCollisions(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica che gli ostacoli possano essere superati con le abilità disponibili
        /// </summary>

        private void CheckIfObstaclesCanBeTraversed(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica gli ostacoli da saltare
        /// </summary>

        private void CheckJumpObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica gli ostacoli da superare con scivolata
        /// </summary>

        private void CheckSlideObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica gli ostacoli da evitare con spostamenti laterali
        /// </summary>

        private void CheckSideObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica ostacoli speciali (lava, ghiaccio, barriere digitali, ecc.)
        /// </summary>

        private void CheckSpecialObstacles(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Verifica pattern complessi di ostacoli
        /// </summary>

        private void CheckComplexObstaclePatterns(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Esegue una simulazione semplificata del percorso per verificare se è possibile superare
        /// tutti gli ostacoli nella sequenza
        /// </summary>

        private void ScanObstacleCombination(TutorialScenario scenario);
         <summary>
        /// Verifica se esiste un percorso attraverso gli ostacoli presenti alle posizioni z specificate
        /// </summary>

        private bool CheckPathExistsAt(Dictionary<float, List<(float x, float y, float width, float height)>> obstacleMap, float z1, float z2);
         <summary>
        /// Verifica se una posizione x è bloccata dagli ostacoli
        /// </summary>

        private bool IsPositionBlocked(float x, List<(float min, float max)> blockedRanges);
         <summary>
        /// Popola la mappa degli ostacoli per uno specifico setup
        /// </summary>

        private void PopulateObstacleMap(Dictionary<float, List<(float x, float y, float width, float height)>> map, ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Determina il tipo di ostacolo in base al codice
        /// </summary>

        private ObstacleType DetermineObstacleType(string obstacleCode);
         <summary>
        /// Determina l'altezza predefinita di un ostacolo in base al codice
        /// </summary>

        private float DetermineDefaultObstacleHeight(string obstacleCode);
         <summary>
        /// Determina la larghezza predefinita di un ostacolo in base al codice
        /// </summary>

        private float DetermineDefaultObstacleWidth(string obstacleCode);
         <summary>
        /// Stima le posizioni degli ostacoli in base alla configurazione
        /// </summary>

        private List<(float x, float y, float z)> EstimateObstaclePositions(ObstacleSetup obstacleSetup, TutorialScenario scenario);
         <summary>
        /// Visualizza debug gizmo degli ostacoli e problemi
        /// </summary>

        private void OnDrawGizmos();
    }
     <summary>
    /// Rappresenta un problema di validazione
    /// </summary>

    public class ValidationIssue
    {
        public IssueType Type;
        public string Message;
        public string ScenarioName;
        public Vector3 Position;
    }
     <summary>
    /// Tipo di problema di validazione
    /// </summary>

    public enum IssueType
    {
        Critical,
        Warning
    }
     <summary>
    /// Risultato della validazione
    /// </summary>

    public class ValidationResult
    {
        public bool IsValid;
        public List<ValidationIssue> Issues;
    }
     <summary>
    /// Tipi di ostacoli
    /// </summary>

    public enum ObstacleType
    {
        Generic,
        JumpObstacle,
        SlideObstacle,
        SideObstacle,
        SpecialObstacle
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/UI/UIMessageComponent.cs

namespace RunawayHeroes.ECS.Components.UI
{
     <summary>
    /// Componente che rappresenta un messaggio UI da visualizzare.
    /// Utilizzato principalmente per i messaggi di istruzione del tutorial.
    /// </summary>

    public struct UIMessageComponent : IComponentData
    {
        public FixedString128Bytes Message;
        public float Duration;
        public float RemainingTime;
        public byte MessageType;
        public bool IsPersistent;
        public int MessageId;
    }
     <summary>
    /// Tag per identificare un messaggio attualmente visualizzato nell'UI
    /// </summary>

    public struct ActiveMessageTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare un messaggio in coda di visualizzazione
    /// </summary>

    public struct QueuedMessageTag : IComponentData
    {
        public int QueuePosition;
    }
     <summary>
    /// Evento generato quando un nuovo messaggio deve essere visualizzato
    /// </summary>

    public struct MessageShowEvent : IComponentData
    {
        public Entity MessageEntity;
    }
     <summary>
    /// Evento generato quando un messaggio deve essere nascosto
    /// </summary>

    public struct MessageHideEvent : IComponentData
    {
        public Entity MessageEntity;
        public bool Forced;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/CommonTags.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Tag per identificare le entità del giocatore
    /// </summary>

    public struct PlayerTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare le entità attive
    /// </summary>

    public struct ActiveTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/TagComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Componente per etichettare le entità con tag personalizzati.
    /// Permette di identificare facilmente il tipo o ruolo di un'entità.
    /// </summary>

    public struct TagComponent : IComponentData
    {
        public FixedString64Bytes Tag;
         <summary>
        /// Crea un nuovo TagComponent con il valore di tag specificato
        /// </summary>
        /// <param name="tag">Il valore del tag</param>
        /// <returns>Un nuovo TagComponent con il tag specificato</returns>

        public static TagComponent Create(string tag);
         <summary>
        /// Verifica se il tag corrisponde a quello specificato
        /// </summary>
        /// <param name="tagToCheck">Il tag da confrontare</param>
        /// <returns>True se i tag corrispondono, false altrimenti</returns>

        public bool HasTag(string tagToCheck);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/TransformComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Componente che memorizza la posizione, rotazione e scala di un'entità.
    /// Usato per entità che richiedono un posizionamento nello spazio 3D.
    /// </summary>

    public struct TransformComponent : IComponentData
    {
        public float3 Position;
        public quaternion Rotation;
        public float Scale;
         <summary>
        /// Crea un nuovo TransformComponent con valori predefiniti
        /// </summary>
        /// <returns>TransformComponent inizializzato con valori predefiniti</returns>

        public static TransformComponent Default();
         <summary>
        /// Crea un nuovo TransformComponent con una posizione specifica
        /// </summary>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>TransformComponent inizializzato con la posizione specificata</returns>

        public static TransformComponent WithPosition(float3 position);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/IdentityComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// 
    /// </summary>

    public struct IdentityComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/PhysicsComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// Componente che memorizza le proprietà fisiche di un'entità, come velocità, massa e accelerazione.
    /// Utilizzato per simulare movimenti e interazioni fisiche nel gioco.
    /// </summary>

    public struct PhysicsComponent : IComponentData
    {
        public float3 Velocity;
        public float3 AngularVelocity;
        public float3 Acceleration;
        public float Mass;
        public float Gravity;
        public float Friction;
        public bool UseGravity;
        public bool IsGrounded;
         <summary>
        /// Crea un nuovo PhysicsComponent con valori predefiniti
        /// </summary>
        /// <returns>PhysicsComponent inizializzato con valori predefiniti</returns>

        public static PhysicsComponent Default();
         <summary>
        /// Applica una forza all'entità, modificando la sua accelerazione in base alla massa
        /// </summary>
        /// <param name="force">Forza da applicare</param>
        /// <returns>Nuova accelerazione risultante</returns>

        public float3 ApplyForce(float3 force);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Core/RenderComponent.cs

namespace RunawayHeroes.ECS.Components.Core
{
     <summary>
    /// 
    /// </summary>

    public struct RenderComponent : IComponentData
    {
        public byte ModelVariant;
        public bool IsVisible;
        public float4 Color;
        public float Scale;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Combat/CombatTypes.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// Motivi per cui un danno può essere bloccato
    /// </summary>

    public enum BlockReason
    {
        Invulnerability = 0,
        Immunity = 1,
        Shield = 2,
        Dodge = 3,
        Parry = 4,
        AbilityBlock = 5
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Combat/DefenseComponent.cs

namespace RunawayHeroes.ECS.Components.Combat
{
     <summary>
    /// Componente che rappresenta le proprietà difensive di un'entità, includendo resistenze
    /// a diversi tipi di danno e capacità di protezione.
    /// </summary>

    public struct DefenseComponent : IComponentData
    {
        public float BaseDefense;
        public float CurrentDefense;
        public float PhysicalResistance;
        public float ElementalResistance;
        public float EnergyResistance;
         <summary>
        /// Crea un componente di difesa con valori predefiniti (nessuna resistenza)
        /// </summary>

        public static DefenseComponent CreateDefault();
         <summary>
        /// Crea un componente di difesa con resistenze bilanciate (10% a tutti i tipi di danno)
        /// </summary>

        public static DefenseComponent CreateBalanced();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Combat/CombatComponent.cs

namespace RunawayHeroes.ECS.Components.Combat
{
     <summary>
    /// Componente che rappresenta le proprietà offensive di un'entità, includendo il danno
    /// di base, bonus e modificatori per diversi tipi di attacco.
    /// </summary>

    public struct CombatComponent : IComponentData
    {
        public float BaseDamage;
        public float CurrentDamage;
        public float CriticalHitChance;
        public float CriticalHitMultiplier;
        public float AttackRange;
         <summary>
        /// Crea un componente di combattimento con valori predefiniti
        /// </summary>

        public static CombatComponent CreateDefault();
         <summary>
        /// Crea un componente di combattimento per un'entità da mischia
        /// </summary>

        public static CombatComponent CreateMelee(float baseDamage);
         <summary>
        /// Crea un componente di combattimento per un'entità a distanza
        /// </summary>

        public static CombatComponent CreateRanged(float baseDamage, float range);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Combat/ArmorComponent.cs

namespace RunawayHeroes.ECS.Components.Combat
{
     <summary>
    /// Componente che rappresenta l'armatura e le resistenze di un'entità
    /// </summary>

    public struct ArmorComponent : IComponentData
    {
        public float PhysicalDamageReduction;
        public float EnemyDamageReduction;
        public float HazardDamageReduction;
        public float FallDamageReduction;
        public float StatusEffectResistance;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/SlideInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input di scivolata per il personaggio.
    /// Viene aggiornato ogni frame dal sistema di input.
    /// </summary>

    public struct SlideInputComponent : IComponentData
    {
        public bool SlidePressed;
        public float SlideForceMultiplier;
        public float CustomSlideDuration;
         <summary>
        /// Resetta lo stato di input per evitare input duplicati
        /// </summary>

        public void Reset();
         <summary>
        /// Crea una nuova istanza con valori predefiniti
        /// </summary>
        /// <returns>Un nuovo SlideInputComponent con valori predefiniti</returns>

        public static SlideInputComponent Default();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/JumpInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input di salto per il personaggio.
    /// Viene aggiornato ogni frame dal sistema di input.
    /// </summary>

    public struct JumpInputComponent : IComponentData
    {
        public bool JumpPressed;
        public float JumpForceMultiplier;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/TouchInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che memorizza lo stato degli input touch per dispositivi mobili.
    /// Permette l'interazione attraverso tap, swipe e gesti multitouch.
    /// </summary>

    public struct TouchInputComponent : IComponentData
    {
        public bool IsTouching;
        public float2 TouchPosition;
        public float2 TouchStartPosition;
        public float2 TouchDelta;
        public float TouchDuration;
        public bool SwipeUp;
        public bool SwipeDown;
        public bool SwipeLeft;
        public bool SwipeRight;
        public bool Tap;
        public bool DoubleTap;
        public bool LongPress;
         <summary>
        /// Resetta gli stati di swipe e tap per evitare duplicazioni
        /// </summary>

        public void ResetGestures();
         <summary>
        /// Resetta completamente lo stato del touch
        /// </summary>

        public void ResetTouch();
         <summary>
        /// Crea una nuova istanza con valori predefiniti
        /// </summary>
        /// <returns>Un nuovo TouchInputComponent con valori predefiniti</returns>

        public static TouchInputComponent Default();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/InputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che memorizza tutti gli input del giocatore in un dato frame.
    /// Centralizza gli input provenienti da touch, tasti, o altri controlli,
    /// convertendoli in uno stato coerente per i sistemi di movimento e abilità.
    /// </summary>

    public struct InputComponent : IComponentData
    {
        public float LateralMovement;
        public float2 MoveDirection;
        public bool IsMovementEnabled;
        public bool JumpPressed;
        public bool SlidePressed;
        public bool FocusTimePressed;
        public bool AbilityPressed;
        public bool CharacterSwitchPressed;
        public float2 TouchPosition;
        public bool TouchActive;
        public float TouchDuration;
         <summary>
        /// Crea un nuovo InputComponent con valori predefiniti
        /// </summary>
        /// <returns>InputComponent inizializzato con tutti gli input a zero/false</returns>

        public static InputComponent Default();
         <summary>
        /// Resetta tutti gli input "premuti" a false, mantenendo solo gli stati analogici
        /// </summary>

        public void ResetPressedInputs();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/AbilityInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input relativo all'attivazione di abilità speciali.
    /// Tiene traccia dei comandi per attivare le abilità uniche di ogni personaggio.
    /// </summary>

    public struct AbilityInputComponent : IComponentData
    {
        public bool ActivateAbility;
        public float2 TargetPosition;
        public AbilityType CurrentAbilityType;
         <summary>
        /// Resetta lo stato di input per evitare input duplicati
        /// </summary>

        public void Reset();
         <summary>
        /// Crea una nuova istanza con valori predefiniti
        /// </summary>
        /// <returns>Un nuovo AbilityInputComponent con valori predefiniti</returns>

        public static AbilityInputComponent Default();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/ResonanceInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input relativo alla Risonanza dei Frammenti,
    /// permettendo al giocatore di cambiare personaggio durante il gameplay.
    /// </summary>

    public struct ResonanceInputComponent : IComponentData
    {
        public int SwitchToCharacterIndex;
        public bool NewCharacterUnlocked;
        public Entity NewCharacterEntity;
        public bool ResonanceLevelUp;
        public int NewResonanceLevel;
         <summary>
        /// Crea un nuovo ResonanceInputComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti</returns>

        public static ResonanceInputComponent Default();
         <summary>
        /// Reimposta gli input a singolo frame per evitare input ripetuti
        /// </summary>

        public void Reset();
         <summary>
        /// Imposta la richiesta di cambio personaggio
        /// </summary>
        /// <param name="characterIndex">Indice del personaggio da attivare</param>

        public void RequestCharacterSwitch(int characterIndex);
         <summary>
        /// Imposta un nuovo personaggio sbloccato
        /// </summary>
        /// <param name="character">Entità del personaggio sbloccato</param>

        public void UnlockNewCharacter(Entity character);
         <summary>
        /// Richiede un aumento di livello per la Risonanza
        /// </summary>
        /// <param name="newLevel">Nuovo livello di Risonanza</param>

        public void UpgradeResonance(int newLevel);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Input/FocusTimeInputComponent.cs

namespace RunawayHeroes.ECS.Components.Input
{
     <summary>
    /// Componente che gestisce l'input relativo al sistema Focus Time,
    /// includendo l'attivazione/disattivazione e la selezione di oggetti.
    /// </summary>

    public struct FocusTimeInputComponent : IComponentData
    {
        public bool ActivateFocusTime;
        public bool DeactivateFocusTime;
        public int SelectedItemIndex;
        public bool NewItemDetected;
        public Entity NewItemEntity;
        public float2 FocusPointerPosition;
        public float ActivationHoldTime;
         <summary>
        /// Crea un nuovo FocusTimeInputComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti</returns>

        public static FocusTimeInputComponent Default();
         <summary>
        /// Reimposta gli input a singolo frame per evitare input ripetuti
        /// </summary>

        public void Reset();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/SpawnPointComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct SpawnPointComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/WorldIdentifierComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct WorldIdentifierComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/ObstacleSpawnConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce le configurazioni per lo spawn di ostacoli in un segmento
    /// </summary>

    public struct ObstacleSpawnConfigComponent : IComponentData
    {
        public float DensityFactor;
        public int MinObstacles;
        public int MaxObstacles;
        public float SmallObstacleProbability;
        public float MediumObstacleProbability;
        public float LargeObstacleProbability;
        public float CityObstacleWeight;
        public float ForestObstacleWeight;
        public float TundraObstacleWeight;
        public float VolcanoObstacleWeight;
        public float AbyssObstacleWeight;
        public float VirtualObstacleWeight;
        public float LavaObstacleProbability;
        public float IceObstacleProbability;
        public float DigitalBarrierProbability;
        public float UnderwaterProbability;
        public float SlipperyProbability;
        public float ToxicGroundProbability;
        public float CurrentProbability;
        public float SpecialHazardDensity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RoomTemplateComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce un template di stanza utilizzabile nella generazione procedurale
    /// </summary>

    public struct RoomTemplateComponent : IComponentData
    {
        public int TemplateID;
        public int2 Size;
        public int MinDoorways;
        public int MaxDoorways;
        public RoomType Type;
        public int Difficulty;
        public bool IsStartRoom;
        public bool IsEndRoom;
        public bool RequiresSpecificAbility;
        public int RequiredAbilityType;
    }
     <summary>
    /// Enumerazione che definisce i possibili tipi di stanza
    /// </summary>

    public enum RoomType
    {
        Standard,
        Treasure,
        Challenge,
        Boss,
        Secret,
        Checkpoint,
        Puzzle,
        Hub
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RoomComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che rappresenta una stanza generata all'interno di un livello
    /// </summary>

    public struct RoomComponent : IComponentData
    {
        public float3 Position;
        public quaternion Rotation;
        public int2 GridPosition;
        public int2 Size;
        public int TemplateID;
        public Entity LevelEntity;
        public RoomState State;
        public bool IsVisited;
        public bool IsMapped;
        public bool ContainsCollectibles;
        public bool ContainsEnemies;
    }
     <summary>
    /// Enumerazione che definisce i possibili stati di una stanza
    /// </summary>

    public enum RoomState
    {
        Inactive,
        Active,
        Cleared,
        Locked,
        Secret
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/LevelComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct LevelComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RoomDoorwayBuffer.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Buffer element component che contiene i riferimenti alle doorway di una stanza
    /// </summary>

    public struct RoomDoorwayBuffer : IBufferElementData
    {
        public Entity DoorwayEntity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RandomLevelConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce la configurazione per la generazione di livelli randomizzati
    /// </summary>

    public struct RandomLevelConfigComponent : IComponentData
    {
        public int MinRooms;
        public int MaxRooms;
        public int MinRoomSize;
        public int MaxRoomSize;
        public int CorridorWidth;
        public float BranchingProbability;
        public int Seed;
        public int WorldTheme;
        public bool UseLoops;
        public bool EnsureConnectivity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/DoorwayComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce un punto di connessione tra stanze
    /// </summary>

    public struct DoorwayComponent : IComponentData
    {
        public float3 Position;
        public quaternion Rotation;
        public DoorwayDirection Direction;
        public Entity SourceRoom;
        public Entity TargetRoom;
        public DoorwayType Type;
        public bool IsConnected;
        public bool IsLocked;
        public int KeyID;
    }
     <summary>
    /// Enumerazione che definisce i possibili tipi di doorway
    /// </summary>

    public enum DoorwayType
    {
        Standard,
        OneWay,
        Hidden,
        Boss,
        Challenge,
        AbilityGated,
        KeyGated
    }
     <summary>
    /// Enumerazione che definisce le possibili direzioni di una doorway
    /// </summary>

    public enum DoorwayDirection
    {
        North,
        East,
        South,
        West,
        Up,
        Down
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/EnemySpawnConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce le configurazioni per lo spawn di nemici in un segmento
    /// </summary>

    public struct EnemySpawnConfigComponent : IComponentData
    {
        public float DensityFactor;
        public int MinEnemies;
        public int MaxEnemies;
        public float DroneProbability;
        public float PatrolProbability;
        public float AmbushProbability;
        public float CityEnemyWeight;
        public float ForestEnemyWeight;
        public float TundraEnemyWeight;
        public float VolcanoEnemyWeight;
        public float AbyssEnemyWeight;
        public float VirtualEnemyWeight;
        public float MidBossProbability;
        public float BossProbability;
        public float GroupSpawnProbability;
        public int MinGroupSize;
        public int MaxGroupSize;
        public float EliteEnemyProbability;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/CheckpointComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct CheckpointComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/RunnerLevelConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce la configurazione per la generazione di livelli runner
    /// </summary>

    public struct RunnerLevelConfigComponent : IComponentData
    {
        public int LevelLength;
        public int MinSegments;
        public int MaxSegments;
        public int Seed;
        public int StartDifficulty;
        public int EndDifficulty;
        public float DifficultyRamp;
        public float ObstacleDensity;
        public float EnemyDensity;
        public float CollectibleDensity;
        public WorldTheme PrimaryTheme;
        public WorldTheme SecondaryTheme;
        public float ThemeBlendFactor;
        public bool GenerateCheckpoints;
        public bool DynamicDifficulty;
        public float SegmentVarietyFactor;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/WorldDifficultyConfigComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce la configurazione di difficoltà per ciascun tema di mondo.
    /// Consente di scalare la difficoltà in modo appropriato per ogni ambiente di gioco.
    /// </summary>

    public struct WorldDifficultyConfigComponent : IComponentData
    {
        public int TutorialBaseDifficulty;
        public int CityBaseDifficulty;
        public int ForestBaseDifficulty;
        public int TundraBaseDifficulty;
        public int VolcanoBaseDifficulty;
        public int AbyssBaseDifficulty;
        public int VirtualBaseDifficulty;
        public float TutorialObstacleDensityScale;
        public float CityObstacleDensityScale;
        public float ForestObstacleDensityScale;
        public float TundraObstacleDensityScale;
        public float VolcanoObstacleDensityScale;
        public float AbyssObstacleDensityScale;
        public float VirtualObstacleDensityScale;
        public float TutorialEnemyDensityScale;
        public float CityEnemyDensityScale;
        public float ForestEnemyDensityScale;
        public float TundraEnemyDensityScale;
        public float VolcanoEnemyDensityScale;
        public float AbyssEnemyDensityScale;
        public float VirtualEnemyDensityScale;
        public float TutorialDifficultyRampScale;
        public float CityDifficultyRampScale;
        public float ForestDifficultyRampScale;
        public float TundraDifficultyRampScale;
        public float VolcanoDifficultyRampScale;
        public float AbyssDifficultyRampScale;
        public float VirtualDifficultyRampScale;
        public bool EnableTutorialSafezones;
        public float SpecialHazardReductionInTutorial;
         <summary>
        /// Restituisce la difficoltà di base per un tema specifico
        /// </summary>

        public int GetBaseDifficultyForTheme(WorldTheme theme);
         <summary>
        /// Restituisce il fattore di scala della densità degli ostacoli per un tema specifico
        /// </summary>

        public float GetObstacleDensityScaleForTheme(WorldTheme theme, bool isTutorial);
         <summary>
        /// Restituisce il fattore di scala della densità dei nemici per un tema specifico
        /// </summary>

        public float GetEnemyDensityScaleForTheme(WorldTheme theme, bool isTutorial);
         <summary>
        /// Restituisce il fattore di scala del ramp (incremento) della difficoltà per un tema specifico
        /// </summary>

        public float GetDifficultyRampScaleForTheme(WorldTheme theme, bool isTutorial);
         <summary>
        /// Crea una configurazione di difficoltà con valori predefiniti
        /// </summary>

        public static WorldDifficultyConfigComponent CreateDefault();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/HazardComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che rappresenta una zona pericolosa nell'ambiente di gioco.
    /// Può essere lava, tossine, radiazioni o altri elementi dannosi per il giocatore.
    /// </summary>

    public struct HazardComponent : IComponentData
    {
        public HazardType Type;
        public float DamagePerSecond;
        public float Radius;
        public bool IsContinuousDamage;
        public StatusEffectType StatusEffect;
        public float StatusEffectDuration;
        public float StatusEffectIntensity;
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona di lava
        /// </summary>

        public static HazardComponent CreateLavaHazard(float radius, float damagePerSecond);
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona tossica
        /// </summary>

        public static HazardComponent CreateToxicHazard(float radius, float damagePerSecond);
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona elettrificata
        /// </summary>

        public static HazardComponent CreateElectrifiedHazard(float radius, float damagePerSecond);
         <summary>
        /// Crea un HazardComponent con valori predefiniti per una zona fredda
        /// </summary>

        public static HazardComponent CreateColdHazard(float radius, float damagePerSecond);
    }
     <summary>
    /// Tipi di pericoli ambientali
    /// </summary>

    public enum HazardType
    {
        None = 0,
        Lava = 1,
        Toxic = 2,
        Electric = 3,
        Cold = 4,
        Void = 5,
        Digital = 6,
        Crushing = 7
    }
     <summary>
    /// Tipi di effetti di status che possono essere applicati da pericoli
    /// </summary>

    public enum StatusEffectType
    {
        None = 0,
        Burning = 1,
        Poisoned = 2,
        Slowed = 3,
        Stunned = 4,
        Frozen = 5,
        Confused = 6,
        Weakened = 7
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/SegmentContentBuffer.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Buffer per memorizzare i riferimenti agli elementi (ostacoli, nemici, ecc.) di un segmento
    /// </summary>

    public struct SegmentContentBuffer : IBufferElementData
    {
        public Entity ContentEntity;
        public SegmentContentType Type;
    }
     <summary>
    /// Tipi di contenuto che possono essere presenti in un segmento
    /// </summary>

    public enum SegmentContentType
    {
        Obstacle,
        SmallObstacle,
        MediumObstacle,
        LargeObstacle,
        Enemy,
        Drone,
        Patrol,
        MidBoss,
        Boss,
        Collectible,
        PowerUp,
        Checkpoint,
        EnvironmentHazard,
        Decoration
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/PathSegmentComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che definisce un segmento di percorso in un livello runner
    /// </summary>

    public struct PathSegmentComponent : IComponentData
    {
        public float3 StartPosition;
        public float3 EndPosition;
        public quaternion Rotation;
        public float Length;
        public float Width;
        public SegmentType Type;
        public int SegmentIndex;
        public int DifficultyLevel;
        public WorldTheme Theme;
        public bool IsActive;
        public bool IsGenerated;
        public Entity NextSegment;
    }
     <summary>
    /// Enumerazione dei tipi di segmenti di percorso
    /// </summary>

    public enum SegmentType
    {
        Straight,
        Uphill,
        Downhill,
        Curve,
        Jump,
        Narrow,
        Wide,
        Hazard,
        Checkpoint,
        Challenge
    }
     <summary>
    /// Enumerazione dei temi di mondo disponibili
    /// </summary>

    public enum WorldTheme
    {
        City,
        Forest,
        Tundra,
        Volcano,
        Abyss,
        Virtual
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/PathComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// 
    /// </summary>

    public struct PathComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/PathSegmentBuffer.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Buffer per memorizzare i riferimenti ai segmenti di percorso in un livello
    /// </summary>

    public struct PathSegmentBuffer : IBufferElementData
    {
        public Entity SegmentEntity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/SegmentReferenceComponent.cs

namespace RunawayHeroes.ECS.Components.World
{
     <summary>
    /// Componente che fornisce un riferimento a un segmento di percorso.
    /// Utilizzato per collegare entità (nemici, ostacoli, ecc.) ai segmenti di livello a cui appartengono.
    /// </summary>

    public struct SegmentReferenceComponent : IComponentData
    {
        public Entity SegmentEntity;
        public int SegmentID;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/UrbanDashAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Scatto Urbano" di Alex.
    /// Consente un'accelerazione improvvisa con invulnerabilità temporanea
    /// e la capacità di sfondare piccoli ostacoli.
    /// </summary>

    public struct UrbanDashAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float SpeedMultiplier;
        public float InitialBoost;
        public bool IsActive;
        public float BreakThroughForce;
        public bool IsAvailable { ... }
         <summary>
        /// Crea una nuova istanza di UrbanDashAbilityComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti per Alex</returns>

        public static UrbanDashAbilityComponent Default();
         <summary>
        /// Attiva l'abilità se disponibile
        /// </summary>
        /// <returns>True se l'abilità è stata attivata, false altrimenti</returns>

        public bool Activate();
         <summary>
        /// Disattiva l'abilità e avvia il cooldown
        /// </summary>

        public void Deactivate();
         <summary>
        /// Aggiorna i timer dell'abilità
        /// </summary>
        /// <param name="deltaTime">Il tempo trascorso dall'ultimo aggiornamento in secondi</param>
        /// <returns>True se lo stato dell'abilità è cambiato (attivata/disattivata), false altrimenti</returns>

        public bool Update(float deltaTime);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/FireproofBodyAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Corpo Ignifugo" di Ember.
    /// Trasformazione in forma ignea che permette di attraversare la lava.
    /// </summary>

    public struct FireproofBodyAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float HeatAura;
        public bool LavaWalkingActive;
        public bool IsActive;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/HeatAuraAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Aura di Calore" di Kai.
    /// Crea un campo che scioglie il ghiaccio e protegge dal freddo.
    /// </summary>

    public struct HeatAuraAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float AuraRadius;
        public float MeltIceRate;
        public bool IsActive;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/NatureCallAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Richiamo della Natura" di Maya.
    /// Evoca animali alleati temporanei che distraggono i nemici.
    /// </summary>

    public struct NatureCallAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public int MaxAllies;
        public float AllySummonRadius;
        public float AllyDistractDuration;
        public bool IsActive;
        public FixedList32Bytes<Entity> CurrentAllies;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/ControlledGlitchAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Glitch Controllato" di Neo.
    /// Deforma brevemente la realtà, permettendo di attraversare barriere digitali.
    /// </summary>

    public struct ControlledGlitchAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float GlitchDistance;
        public bool BarrierPenetration;
        public bool IsActive;
        public bool TeleportStarted;
        public bool GlitchCompleted;
        public float3 StartPosition;
        public float3 TargetPosition;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/AbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// 
    /// </summary>

    public struct AbilityComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Abilities/AirBubbleAbilityComponent.cs

namespace RunawayHeroes.ECS.Components.Abilities
{
     <summary>
    /// Componente che rappresenta l'abilità "Bolla d'Aria" di Marina.
    /// Crea una bolla protettiva che fornisce ossigeno e respinge nemici acquatici.
    /// </summary>

    public struct AirBubbleAbilityComponent : IComponentData
    {
        public float Duration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float BubbleRadius;
        public float RepelForce;
        public bool IsActive;
        public bool IsAvailable { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ObjectiveComponents.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che rappresenta un obiettivo specifico da completare nel tutorial
    /// </summary>

    public struct ObjectiveComponent : IComponentData
    {
        public byte ObjectiveType;
        public int RequiredValue;
        public int CurrentProgress;
        public int ScenarioId;
        public FixedString128Bytes Description;
        public bool IsCompleted;
        public bool IsOptional;
    }
     <summary>
    /// Tag per indicare un obiettivo attualmente attivo
    /// </summary>

    public struct ActiveObjectiveTag : IComponentData
    {
    }
     <summary>
    /// Componente per tracciare il progresso numerico di un obiettivo
    /// </summary>

    public struct ObjectiveProgressComponent : IComponentData
    {
        public int Count;
        public int MaxCount;
        public float StartTime;
        public float TimeLimit;
    }
     <summary>
    /// Evento generato quando un obiettivo viene completato
    /// </summary>

    public struct ObjectiveCompletedEvent : IComponentData
    {
        public Entity ObjectiveEntity;
        public byte ObjectiveType;
        public int ScenarioId;
        public bool WasRequired;
    }
     <summary>
    /// Evento generato quando si verifica un progresso in un obiettivo
    /// </summary>

    public struct ObjectiveProgressEvent : IComponentData
    {
        public Entity ObjectiveEntity;
        public int PreviousValue;
        public int NewValue;
        public int RequiredValue;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ObstacleTagCompatibility.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/FocusTimeComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce la meccanica del "Focus Time" che permette
    /// al giocatore di rallentare il tempo per prendere decisioni strategiche
    /// e selezionare oggetti durante l'azione frenetica.
    /// </summary>

    public struct FocusTimeComponent : IComponentData
    {
        public float MaxDuration;
        public float RemainingTime;
        public float Cooldown;
        public float CooldownRemaining;
        public float TimeScale;
        public bool IsActive;
        public float MaxEnergy;
        public float CurrentEnergy;
        public float EnergyConsumptionRate;
        public float EnergyRechargeRate;
        public int MaxItemSlots;
        public FixedList128Bytes<Entity> ItemSlots;
        public bool IsAvailable { ... }
        public float EnergyPercentage { ... }
         <summary>
        /// Crea un nuovo FocusTimeComponent con valori predefiniti
        /// </summary>
        /// <returns>Componente inizializzato con valori predefiniti</returns>

        public static FocusTimeComponent Default();
         <summary>
        /// Attiva il Focus Time se disponibile
        /// </summary>
        /// <returns>True se il Focus Time è stato attivato, false altrimenti</returns>

        public bool Activate();
         <summary>
        /// Disattiva il Focus Time e avvia il cooldown
        /// </summary>
        /// <param name="applyFullCooldown">Se true, applica l'intero cooldown, altrimenti un cooldown proporzionale al tempo utilizzato</param>

        public void Deactivate(bool applyFullCooldown);
         <summary>
        /// Aggiorna i timer e l'energia del Focus Time
        /// </summary>
        /// <param name="deltaTime">Il tempo trascorso dall'ultimo aggiornamento in secondi</param>
        /// <returns>True se lo stato del Focus Time è cambiato, false altrimenti</returns>

        public bool Update(float deltaTime);
         <summary>
        /// Aggiunge un oggetto a uno slot vuoto del Focus Time
        /// </summary>
        /// <param name="item">L'entità oggetto da aggiungere</param>
        /// <returns>L'indice dello slot assegnato, o -1 se non è stato possibile aggiungere l'oggetto</returns>

        public int AddItem(Entity item);
         <summary>
        /// Rimuove un oggetto dagli slot del Focus Time
        /// </summary>
        /// <param name="slotIndex">L'indice dello slot da cui rimuovere l'oggetto</param>
        /// <returns>L'entità oggetto rimossa, o Entity.Null se lo slot era già vuoto</returns>

        public Entity RemoveItem(int slotIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/TutorialComponents.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Informazioni aggiuntive sul livello tutorial
    /// </summary>

    public struct TutorialLevelInfoComponent : IComponentData
    {
        public FixedString128Bytes Description;
        public int Difficulty;
        public bool IsLastTutorial;
    }
     <summary>
    /// Buffer di scenari di insegnamento per un livello tutorial
    /// </summary>

    public struct TutorialScenarioBuffer : IBufferElementData
    {
        public FixedString64Bytes Name;
        public float DistanceFromStart;
        public FixedString128Bytes InstructionMessage;
        public float MessageDuration;
        public bool Triggered;
        public bool RandomPlacement;
        public float ObstacleSpacing;
    }
     <summary>
    /// Buffer per gli ostacoli in uno scenario di insegnamento
    /// </summary>

    public struct TutorialObstacleBuffer : IBufferElementData
    {
        public FixedString32Bytes ObstacleCode;
        public int Count;
        public byte Placement;
        public bool RandomizeHeight;
        public float2 HeightRange;
        public bool RandomizeScale;
        public float2 ScaleRange;
        public float StartOffset;
    }
     <summary>
    /// Riferimento allo scenario di insegnamento
    /// </summary>

    public struct ScenarioReference : IComponentData
    {
        public Entity TutorialLevelEntity;
        public int ScenarioIndex;
    }
     <summary>
    /// Componente per tracciare il progresso del giocatore nei tutorial
    /// </summary>

    public struct TutorialProgressComponent : IComponentData
    {
        public int CompletedTutorialCount;
        public int HighestUnlockedTutorial;
        public bool TutorialsCompleted;
    }
     <summary>
    /// Tag interno per identificare il completamento di un livello tutorial
    /// </summary>

    public struct TutorialCompletionTag : IComponentData
    {
        public int CompletedTutorialIndex;
    }
     <summary>
    /// Evento generato quando viene completato un tutorial
    /// </summary>

    public struct TutorialFinishedEvent : IComponentData
    {
        public int CompletedTutorialIndex;
        public bool AllTutorialsCompleted;
        public int NextTutorialToUnlock;
    }
     <summary>
    /// Tag per identificare uno scenario di insegnamento che è pronto per essere attivato
    /// </summary>

    public struct ScenarioActivationTag : IComponentData
    {
        public Entity ScenarioEntity;
        public int ScenarioIndex;
        public float ActivationTime;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/EnvironmentalEffectComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// 
    /// </summary>

    public struct EnvironmentalEffectComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/CollectibleComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// 
    /// </summary>

    public struct CollectibleComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/FragmentResonanceComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce la meccanica "Risonanza dei Frammenti",
    /// permettendo ai giocatori di cambiare personaggio istantaneamente durante il gameplay.
    /// </summary>

    public struct FragmentResonanceComponent : IComponentData
    {
        public Entity ActiveCharacter;
        public FixedList128Bytes<Entity> UnlockedCharacters;
        public int CharacterCount;
        public bool IsUnlocked;
        public int ResonanceLevel;
        public float Cooldown;
        public float CooldownRemaining;
        public float FocusTimeCost;
        public float InvulnerabilityDuration;
        public float EnergyWaveRadius;
        public float EnergyWaveDamage;
        public bool IsAvailable { ... }
         <summary>
        /// Crea un nuovo componente FragmentResonance con valori di default
        /// </summary>
        /// <param name="initialCharacter">Personaggio iniziale (Alex)</param>
        /// <returns>Componente inizializzato</returns>

        public static FragmentResonanceComponent Default(Entity initialCharacter);
         <summary>
        /// Aggiorna i timer della Risonanza
        /// </summary>
        /// <param name="deltaTime">Tempo trascorso dall'ultimo frame</param>
        /// <returns>True se lo stato è cambiato (cooldown completato), false altrimenti</returns>

        public bool Update(float deltaTime);
         <summary>
        /// Cambia il personaggio attivo
        /// </summary>
        /// <param name="characterIndex">Indice del personaggio da attivare</param>
        /// <returns>True se il cambio è riuscito, false altrimenti</returns>

        public bool SwitchCharacter(int characterIndex);
         <summary>
        /// Aggiunge un nuovo personaggio alla Risonanza
        /// </summary>
        /// <param name="characterEntity">Entità del personaggio da aggiungere</param>
        /// <returns>True se il personaggio è stato aggiunto, false se già presente o lista piena</returns>

        public bool AddCharacter(Entity characterEntity);
         <summary>
        /// Ottiene i bonus ambientali in base al tipo di mondo e al carattere fornito
        /// </summary>
        /// <param name="worldType">Il tipo di mondo corrente</param>
        /// <param name="characterType">Il tipo di carattere</param>
        /// <returns>Struttura contenente i bonus applicabili</returns>

        public EnvironmentalBonus GetEnvironmentalBonus(WorldType worldType, CharacterType characterType);
         <summary>
        /// Riduce il cooldown della Risonanza tramite oggetti o abilità
        /// </summary>
        /// <param name="reductionAmount">Quantità di riduzione in secondi</param>

        public void ReduceCooldown(float reductionAmount);
    }
     <summary>
    /// Struttura che definisce i bonus ambientali applicati durante la Risonanza
    /// </summary>

    public struct EnvironmentalBonus
    {
        public float SpeedBonus;
        public float JumpBonus;
        public float HealingEfficiency;
        public float ElementalResistance;
        public float CooldownReduction;
    }
     <summary>
    /// Evento generato quando un personaggio viene cambiato con la Risonanza
    /// </summary>

    public struct CharacterSwitchedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity PreviousCharacter;
        public Entity NewCharacter;
        public float3 Position;
        public float3 Velocity;
        public WorldType WorldType;
        public EnvironmentalBonus AppliedBonus;
    }
     <summary>
    /// Evento generato quando un personaggio viene sbloccato
    /// </summary>

    public struct CharacterUnlockedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity UnlockedCharacter;
        public int TotalCharacters;
    }
     <summary>
    /// Evento generato quando la Risonanza viene sbloccata
    /// </summary>

    public struct ResonanceUnlockedEvent : IComponentData
    {
        public Entity PlayerEntity;
    }
     <summary>
    /// Evento generato quando il livello di Risonanza aumenta
    /// </summary>

    public struct ResonanceUpgradedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public int PreviousLevel;
        public int NewLevel;
    }
     <summary>
    /// Evento generato quando la Risonanza è di nuovo disponibile dopo il cooldown
    /// </summary>

    public struct ResonanceReadyEvent : IComponentData
    {
        public Entity PlayerEntity;
    }
     <summary>
    /// Evento generato quando l'onda di energia della Risonanza viene emessa
    /// </summary>

    public struct EnergyWaveEvent : IComponentData
    {
        public float3 Origin;
        public float Radius;
        public float Damage;
        public Entity SourceEntity;
    }
     <summary>
    /// Evento generato quando si attivano abilità combinate (Risonanza Totale)
    /// </summary>

    public struct CombinedAbilitiesEvent : IComponentData
    {
        public Entity PrimaryCharacter;
        public Entity SecondaryCharacter;
        public float Duration;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/HealthComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce la salute di un'entità, inclusi punti vita attuali, massimi,
    /// stato di invulnerabilità e rigenerazione. Utilizzato sia per il giocatore che per i nemici.
    /// </summary>

    public struct HealthComponent : IComponentData
    {
        public float CurrentHealth;
        public float MaxHealth;
        public bool IsInvulnerable;
        public float InvulnerabilityTime;
        public float InvulnerabilityTimer;
        public bool HasAutoRegen;
        public float RegenRate;
        public float RegenDelay;
        public float TimeSinceLastDamage;
        public bool IsRegenerating;
        public bool HasShield;
        public float CurrentShield;
        public float MaxShield;
        public bool HasShieldAutoRegen;
        public float ShieldRegenRate;
        public float ShieldRegenDelay;
        public float TimeSinceLastShieldDamage;
        public bool IsDead { ... }
        public float HealthPercentage { ... }
        public float ShieldPercentage { ... }
         <summary>
        /// Crea un nuovo HealthComponent con valori predefiniti
        /// </summary>
        /// <param name="maxHealth">Punti vita massimi</param>
        /// <param name="maxShield">Punti scudo massimi (0 per nessuno scudo)</param>
        /// <param name="enableAutoRegen">Abilita rigenerazione automatica della salute</param>
        /// <param name="enableShieldRegen">Abilita rigenerazione automatica dello scudo</param>
        /// <returns>HealthComponent inizializzato con i valori specificati</returns>

        public static HealthComponent Default(float maxHealth, float maxShield, bool enableAutoRegen, bool enableShieldRegen);
         <summary>
        /// Applica danni all'entità, tenendo conto dell'invulnerabilità
        /// </summary>
        /// <param name="damage">Quantità di danno da applicare</param>
        /// <returns>Danno effettivamente applicato</returns>

        public float ApplyDamage(float damage);
         <summary>
        /// Ripristina salute all'entità
        /// </summary>
        /// <param name="amount">Quantità di salute da ripristinare</param>
        /// <returns>Salute effettivamente ripristinata</returns>

        public float Heal(float amount);
         <summary>
        /// Attiva l'invulnerabilità per un periodo di tempo specificato
        /// </summary>
        /// <param name="duration">Durata dell'invulnerabilità in secondi</param>

        public void SetInvulnerable(float duration);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/MovementComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che gestisce i parametri di movimento di un'entità,
    /// inclusi velocità, salto, scivolata e altri attributi di movimento.
    /// </summary>

    public struct MovementComponent : IComponentData
    {
        public float BaseSpeed;
        public float CurrentSpeed;
        public float MaxSpeed;
        public float Acceleration;
        public float JumpForce;
        public int MaxJumps;
        public int RemainingJumps;
        public bool IsJumping;
        public float SlideDuration;
        public float SlideTimeRemaining;
        public bool IsSliding;
        public float SlideSpeedMultiplier;
        public bool IsMoving;
        public float3 MoveDirection;
         <summary>
        /// Genera un MovementComponent con valori di default per un personaggio giocabile
        /// </summary>

        public static MovementComponent DefaultPlayer();
         <summary>
        /// Inizia un salto, se possibile
        /// </summary>
        /// <returns>True se il salto è stato avviato, false altrimenti</returns>

        public bool TryJump();
         <summary>
        /// Inizia una scivolata, se possibile
        /// </summary>
        /// <returns>True se la scivolata è stata avviata, false altrimenti</returns>

        public bool TrySlide();
         <summary>
        /// Reimposta i salti disponibili quando il personaggio tocca terra
        /// </summary>

        public void ResetJumps();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ObstacleComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che rappresenta un ostacolo nel gioco.
    /// Contiene proprietà come dimensioni, resistenza e danno causato.
    /// </summary>

    public struct ObstacleComponent : IComponentData
    {
        public float Height;
        public float Width;
        public float CollisionRadius;
        public float Strength;
        public float DamageValue;
        public float DamageAmount;
        public bool DealsDamage;
        public bool IsMoving;
        public bool IsDestructible;
         <summary>
        /// Crea un nuovo ObstacleComponent con valori predefiniti per un ostacolo piccolo
        /// </summary>

        public static ObstacleComponent CreateSmall();
         <summary>
        /// Crea un nuovo ObstacleComponent con valori predefiniti per un ostacolo medio
        /// </summary>

        public static ObstacleComponent CreateMedium();
         <summary>
        /// Crea un nuovo ObstacleComponent con valori predefiniti per un ostacolo grande
        /// </summary>

        public static ObstacleComponent CreateLarge();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/MissionComponent.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente che rappresenta una missione o quest all'interno del gioco.
    /// Una missione è composta da uno o più obiettivi che devono essere completati.
    /// </summary>

    public struct MissionComponent : IComponentData
    {
        public int MissionID;
        public FixedString64Bytes MissionName;
        public FixedString128Bytes Description;
        public byte MissionType;
        public int CompletedObjectives;
        public int TotalObjectives;
        public bool IsCompleted;
        public bool IsFailed;
        public bool IsActive;
        public int AssociatedLevelID;
        public int RewardValue;
        public byte RewardType;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Gameplay/ProgressionComponents.cs

namespace RunawayHeroes.ECS.Components.Gameplay
{
     <summary>
    /// Componente principale per tracciare la progressione globale del giocatore
    /// </summary>

    public struct PlayerProgressionComponent : IComponentData
    {
        public int CompletedTutorialCount;
        public int HighestUnlockedTutorial;
        public bool TutorialsCompleted;
        public int HighestUnlockedWorld;
        public int CurrentActiveWorld;
        public byte WorldsCompleted;
        public int TotalFragmentsCollected;
        public byte FragmentsCollectedMask;
        public int TotalStarsEarned;
        public int TotalLevelsCompleted;
        public int TotalBonusObjectivesCompleted;
        public byte UnlockedCharactersMask;
        public byte CurrentActiveCharacter;
        public long LastUpdatedTimestamp;
    }
     <summary>
    /// Componente specifico per tracciare la progressione dei tutorial
    /// </summary>

    public struct TutorialProgressionComponent : IComponentData
    {
        public int CompletedTutorialCount;
        public int HighestUnlockedTutorial;
        public bool AllTutorialsCompleted;
        public int MechanicsLearned;
        public int TutorialRetryCount;
        public float AverageTutorialCompletionTime;
    }
     <summary>
    /// Tag che identifica un livello tutorial
    /// </summary>

    public struct TutorialLevelTag : IComponentData
    {
        public int TutorialIndex;
        public int CurrentSequence;
        public bool Completed;
    }
     <summary>
    /// Tag per identificare il completamento di un tutorial
    /// </summary>

    public struct TutorialCompletedTag : IComponentData
    {
        public int CompletedTutorialIndex;
    }
     <summary>
    /// Evento generato quando viene completato un tutorial
    /// </summary>

    public struct TutorialCompletionEvent : IComponentData
    {
        public int CompletedTutorialIndex;
        public bool AllTutorialsCompleted;
        public int NextTutorialToUnlock;
        public float CompletionTime;
    }
     <summary>
    /// Componente per tracciare la progressione all'interno di un mondo
    /// </summary>

    public struct WorldProgressionComponent : IComponentData
    {
        public int WorldIndex;
        public FixedString32Bytes WorldName;
        public byte CompletedLevelsBitmap;
        public byte FullyCompletedLevelsBitmap;
        public byte UnlockedLevelsBitmap;
        public bool IsFragmentCollected;
        public bool IsBossDefeated;
        public byte CollectiblesMask;
        public int TotalStarsInWorld;
        public int StarsCollected;
        public byte DifficultyLevel;
    }
     <summary>
    /// Tag che identifica un mondo di gioco
    /// </summary>

    public struct WorldTag : IComponentData
    {
        public int WorldIndex;
        public bool IsActive;
    }
     <summary>
    /// Evento generato quando viene completato un mondo intero
    /// </summary>

    public struct WorldCompletionEvent : IComponentData
    {
        public int WorldIndex;
        public bool IsFullyCompleted;
        public int NextWorldToUnlock;
        public int FragmentIndex;
        public int CharacterUnlocked;
    }
     <summary>
    /// Tag per identificare lo sblocco di un nuovo mondo
    /// </summary>

    public struct WorldUnlockedTag : IComponentData
    {
        public int WorldIndex;
    }
     <summary>
    /// Componente per tracciare la progressione all'interno di un livello
    /// </summary>

    public struct LevelProgressionComponent : IComponentData
    {
        public int WorldIndex;
        public int LevelIndex;
        public byte StarCount;
        public bool IsCompleted;
        public bool IsBonusObjectiveCompleted;
        public bool AreAllCollectiblesFound;
        public float BestCompletionTime;
        public int AttemptCount;
        public byte TreasuresFound;
        public long LastPlayedTimestamp;
    }
     <summary>
    /// Tag che identifica un livello di gioco
    /// </summary>

    public struct LevelTag : IComponentData
    {
        public int WorldIndex;
        public int LevelIndex;
        public FixedString64Bytes LevelName;
        public bool IsActive;
    }
     <summary>
    /// Evento generato quando viene completato un livello
    /// </summary>

    public struct LevelCompletionEvent : IComponentData
    {
        public int WorldIndex;
        public int LevelIndex;
        public byte StarsEarned;
        public bool BonusObjectiveCompleted;
        public float CompletionTime;
        public int CollectiblesFound;
        public int TreasuresFound;
        public bool IsNewHighScore;
    }
     <summary>
    /// Evento che notifica avanzamento nella progressione generale
    /// </summary>

    public struct ProgressionAdvancementEvent : IComponentData
    {
        public byte ProgressionType;
        public int PrimaryIndex;
        public int SecondaryIndex;
        public int ValueChanged;
        public bool IsSignificantAdvancement;
    }
     <summary>
    /// Evento che notifica lo sblocco di un nuovo elemento
    /// </summary>

    public struct UnlockEvent : IComponentData
    {
        public byte UnlockType;
        public int UnlockedItemIndex;
        public FixedString64Bytes UnlockedItemName;
    }
     <summary>
    /// Evento che notifica il salvataggio dei dati di progressione
    /// </summary>

    public struct ProgressionSaveEvent : IComponentData
    {
        public bool IsAutosave;
        public long Timestamp;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/EmberComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Ember, la sopravvissuta dell'inferno di lava.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Corpo Ignifugo
    /// e la sua resistenza agli ambienti vulcanici.
    /// </summary>

    public struct EmberComponent : IComponentData
    {
        public float HeatResistance;
        public float FireDamageReduction;
        public float ToxicGasResistance;
        public float ExplosionResistance;
        public float MagmaPathfinding;
        public float EruptionSense;
        public float CoolantEfficiency;
        public float AshVision;
         <summary>
        /// Crea un nuovo componente Ember con valori di default
        /// </summary>
        /// <returns>Componente EmberComponent inizializzato</returns>

        public static EmberComponent Default();
         <summary>
        /// Versione potenziata di Ember (livello medio)
        /// </summary>

        public static EmberComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Ember (fine gioco)
        /// </summary>

        public static EmberComponent Master();
         <summary>
        /// Calcola la riduzione del danno da fuoco
        /// </summary>
        /// <param name="fireDamage">Danno da fuoco base</param>
        /// <returns>Danno da fuoco ridotto</returns>

        public float ReduceFireDamage(float fireDamage);
         <summary>
        /// Calcola l'efficacia aumentata degli oggetti raffreddanti
        /// </summary>
        /// <param name="baseDuration">Durata base dell'oggetto raffreddante</param>
        /// <returns>Durata aumentata</returns>

        public float EnhanceCoolantDuration(float baseDuration);
         <summary>
        /// Verifica se Ember può prevedere un'eruzione imminente
        /// </summary>
        /// <returns>True se prevede un'eruzione, false altrimenti</returns>

        public bool DetectEruption();
         <summary>
        /// Calcola la riduzione del danno da gas tossici
        /// </summary>
        /// <param name="toxicDamage">Danno da gas tossico base</param>
        /// <returns>Danno da gas tossico ridotto</returns>

        public float ReduceToxicGasDamage(float toxicDamage);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/MayaComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Maya, l'esploratrice della foresta primordiale.
    /// Contiene attributi e bonus specifici per questo personaggio, in particolare
    /// quelli legati alla sua abilità Richiamo della Natura e la sua affinità
    /// con l'ambiente naturale.
    /// </summary>

    public struct MayaComponent : IComponentData
    {
        public float NaturalRegeneration;
        public float PoisonResistance;
        public float ForestVision;
        public float WildlifeAffinity;
        public float HerbKnowledge;
        public float TreeClimbingAbility;
        public float StealthInNature;
        public float BushTraversalSpeed;
         <summary>
        /// Crea un nuovo componente Maya con valori di default
        /// </summary>
        /// <returns>Componente MayaComponent inizializzato</returns>

        public static MayaComponent Default();
         <summary>
        /// Versione potenziata di Maya (livello medio)
        /// </summary>

        public static MayaComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Maya (fine gioco)
        /// </summary>

        public static MayaComponent Master();
         <summary>
        /// Calcola il bonus di guarigione basato sulla conoscenza delle erbe
        /// </summary>
        /// <param name="baseHealAmount">Quantità base di guarigione</param>
        /// <returns>Quantità di guarigione potenziata</returns>

        public float ApplyHerbKnowledgeBonus(float baseHealAmount);
         <summary>
        /// Calcola la riduzione del danno da veleno
        /// </summary>
        /// <param name="poisonDamage">Danno da veleno base</param>
        /// <returns>Danno da veleno ridotto</returns>

        public float ReducePoisonDamage(float poisonDamage);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/PlayerDataComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente che memorizza i dati comuni a tutti i personaggi giocabili.
    /// Contiene informazioni generali come il tipo di personaggio, il livello di sbloccamento,
    /// e le statistiche base condivise tra tutti i personaggi.
    /// </summary>

    public struct PlayerDataComponent : IComponentData
    {
        public CharacterType Type;
        public FixedString64Bytes Name;
        public int UnlockLevel;
        public bool IsUnlocked;
        public int ExperienceLevel;
        public int CurrentExperience;
        public int ExperienceToNextLevel;
        public float StatMultiplier;
        public int FragmentID;
        public int FragmentPowerLevel;
        public WorldType NativeWorldType;
         <summary>
        /// Costruttore di base per un personaggio
        /// </summary>
        /// <param name="type">Tipo di personaggio</param>
        /// <param name="name">Nome del personaggio</param>
        /// <param name="worldType">Tipo di mondo associato</param>
        /// <returns>Un nuovo componente PlayerData inizializzato</returns>

        public static PlayerDataComponent Create(CharacterType type, string name, WorldType worldType);
         <summary>
        /// Aggiunge esperienza al personaggio e gestisce l'aumento di livello
        /// </summary>
        /// <param name="expAmount">Quantità di esperienza guadagnata</param>
        /// <returns>True se il personaggio è salito di livello, false altrimenti</returns>

        public bool AddExperience(int expAmount);
         <summary>
        /// Aumenta il livello di potere del frammento
        /// </summary>
        /// <returns>True se il potenziamento è stato applicato, false se già al massimo</returns>

        public bool UpgradeFragment();
    }
     <summary>
    /// Tipi di personaggi disponibili nel gioco
    /// </summary>

    public enum CharacterType
    {
        Alex = 0,
        Maya = 1,
        Kai = 2,
        Ember = 3,
        Marina = 4,
        Neo = 5
    }
     <summary>
    /// Tipi di mondo nel gioco
    /// </summary>

    public enum WorldType
    {
        None = 0,
        Urban = 1,
        Forest = 2,
        Tundra = 3,
        Volcano = 4,
        Abyss = 5,
        Virtual = 6
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/KaiComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Kai, l'alpinista della tundra eterna.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Aura di Calore
    /// e la sua resistenza agli ambienti freddi.
    /// </summary>

    public struct KaiComponent : IComponentData
    {
        public float ColdResistance;
        public float IceGrip;
        public float StaminaBonus;
        public float ClimbingAbility;
        public float IceAnalysis;
        public float AvalancheAwareness;
        public float BlizzardVision;
        public float HeatRetention;
         <summary>
        /// Crea un nuovo componente Kai con valori di default
        /// </summary>
        /// <returns>Componente KaiComponent inizializzato</returns>

        public static KaiComponent Default();
         <summary>
        /// Versione potenziata di Kai (livello medio)
        /// </summary>

        public static KaiComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Kai (fine gioco)
        /// </summary>

        public static KaiComponent Master();
         <summary>
        /// Calcola la riduzione del danno da freddo
        /// </summary>
        /// <param name="coldDamage">Danno da freddo base</param>
        /// <returns>Danno da freddo ridotto</returns>

        public float ReduceColdDamage(float coldDamage);
         <summary>
        /// Calcola il modificatore di scivolamento su ghiaccio
        /// </summary>
        /// <param name="baseSlipperiness">Scivolosità base della superficie</param>
        /// <returns>Scivolosità ridotta</returns>

        public float CalculateIceSlip(float baseSlipperiness);
         <summary>
        /// Verifica se Kai rileva ghiaccio debole
        /// </summary>
        /// <returns>True se rileva un punto debole, false altrimenti</returns>

        public bool DetectWeakIce();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/MarinaComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Marina, la biologa degli abissi inesplorati.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Bolla d'Aria
    /// e la sua adattabilità agli ambienti acquatici.
    /// </summary>

    public struct MarinaComponent : IComponentData
    {
        public float SwimSpeed;
        public float WaterBreathing;
        public float PressureResistance;
        public float UnderwaterVision;
        public float ElectricResistance;
        public float MarineEmpathy;
        public float UnderwaterAgility;
        public float ToxinResistance;
         <summary>
        /// Crea un nuovo componente Marina con valori di default
        /// </summary>
        /// <returns>Componente MarinaComponent inizializzato</returns>

        public static MarinaComponent Default();
         <summary>
        /// Versione potenziata di Marina (livello medio)
        /// </summary>

        public static MarinaComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Marina (fine gioco)
        /// </summary>

        public static MarinaComponent Master();
         <summary>
        /// Calcola la velocità di nuoto effettiva basata sulle condizioni
        /// </summary>
        /// <param name="baseSpeed">Velocità base di movimento</param>
        /// <param name="waterDensity">Densità dell'acqua (1.0 = normale)</param>
        /// <returns>Velocità di nuoto calcolata</returns>

        public float CalculateSwimSpeed(float baseSpeed, float waterDensity);
         <summary>
        /// Calcola il tasso di consumo di ossigeno
        /// </summary>
        /// <param name="baseConsumption">Consumo base di ossigeno</param>
        /// <param name="depth">Profondità attuale (influenza il consumo)</param>
        /// <returns>Tasso di consumo ossigeno ridotto</returns>

        public float CalculateOxygenConsumption(float baseConsumption, float depth);
         <summary>
        /// Calcola la riduzione del danno da pressione
        /// </summary>
        /// <param name="pressureDamage">Danno da pressione base</param>
        /// <returns>Danno da pressione ridotto</returns>

        public float ReducePressureDamage(float pressureDamage);
         <summary>
        /// Calcola la riduzione del danno elettrico
        /// </summary>
        /// <param name="electricDamage">Danno elettrico base</param>
        /// <returns>Danno elettrico ridotto</returns>

        public float ReduceElectricDamage(float electricDamage);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/AlexComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Alex, il corriere urbano.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare legati alla sua abilità Scatto Urbano e la sua
    /// maestria nell'ambiente urbano.
    /// </summary>

    public struct AlexComponent : IComponentData
    {
        public float UrbanParkourBonus;
        public float SlideSpeedBonus;
        public bool WallRunEnabled;
        public float MaxWallRunTime;
        public float WallRunTimeRemaining;
        public bool RailGrindEnabled;
        public float RailGrindSpeedBonus;
        public float UrbanJumpBonus;
        public bool DoubleJumpEnabled;
        public float UrbanDashCooldownReduction;
        public float UrbanObstacleDamageReduction;
        public float ObstacleBreakThroughBonus;
        public float UrbanNightVisionBonus;
         <summary>
        /// Crea un nuovo componente Alex con valori di default
        /// </summary>
        /// <returns>Componente AlexComponent inizializzato</returns>

        public static AlexComponent Default();
         <summary>
        /// Versione potenziata di Alex (livello medio)
        /// </summary>

        public static AlexComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Alex (fine gioco)
        /// </summary>

        public static AlexComponent Master();
         <summary>
        /// Ripristina il tempo di wall-run al massimo
        /// </summary>

        public void ResetWallRunTime();
         <summary>
        /// Consuma tempo di wall-run
        /// </summary>
        /// <param name="deltaTime">Tempo trascorso dall'ultimo frame</param>
        /// <returns>True se il wall-run è ancora attivo, false se il tempo è esaurito</returns>

        public bool ConsumeWallRunTime(float deltaTime);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Characters/NeoComponent.cs

namespace RunawayHeroes.ECS.Components.Characters
{
     <summary>
    /// Componente specifico per Neo, l'hacker della realtà virtuale.
    /// Contiene attributi e bonus specifici per questo personaggio,
    /// in particolare quelli legati alla sua abilità Glitch Controllato
    /// e la sua capacità di manipolare l'ambiente digitale.
    /// </summary>

    public struct NeoComponent : IComponentData
    {
        public float CodeSight;
        public float DataCorruptionResistance;
        public float GlitchManipulation;
        public float HackingEfficiency;
        public float FirewallBypass;
        public float SystemRestoration;
        public float DataTransferSpeed;
        public float MalwareImmunity;
         <summary>
        /// Crea un nuovo componente Neo con valori di default
        /// </summary>
        /// <returns>Componente NeoComponent inizializzato</returns>

        public static NeoComponent Default();
         <summary>
        /// Versione potenziata di Neo (livello medio)
        /// </summary>

        public static NeoComponent Advanced();
         <summary>
        /// Versione completamente potenziata di Neo (fine gioco)
        /// </summary>

        public static NeoComponent Master();
         <summary>
        /// Calcola la probabilità di individuare un glitch nascosto
        /// </summary>
        /// <param name="glitchHiddenFactor">Fattore di occultamento del glitch (0-1)</param>
        /// <returns>True se il glitch è individuato, false altrimenti</returns>

        public bool DetectHiddenGlitch(float glitchHiddenFactor);
         <summary>
        /// Calcola la riduzione del danno da corruzione dati
        /// </summary>
        /// <param name="corruptionDamage">Danno da corruzione base</param>
        /// <returns>Danno da corruzione ridotto</returns>

        public float ReduceCorruptionDamage(float corruptionDamage);
         <summary>
        /// Calcola la probabilità di bypassare un firewall
        /// </summary>
        /// <param name="firewallStrength">Forza del firewall (0-1)</param>
        /// <returns>True se il bypass ha successo, false altrimenti</returns>

        public bool BypassFirewall(float firewallStrength);
         <summary>
        /// Calcola la velocità effettiva nei data stream
        /// </summary>
        /// <param name="baseSpeed">Velocità base di movimento</param>
        /// <returns>Velocità potenziata nei data stream</returns>

        public float CalculateDataStreamSpeed(float baseSpeed);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/EnemyComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// Componente principale per tutte le entità nemiche.
    /// Contiene proprietà base come velocità, danno e stato.
    /// </summary>

    public struct EnemyComponent : IComponentData
    {
        public EnemyType Type;
        public int Tier;
        public bool IsElite;
        public float BaseSpeed;
        public float DetectionRange;
        public int AttackDamage;
        public float AttackRange;
        public float AttackSpeed;
        public bool IsAggressive;
        public bool IsStunned;
    }
     <summary>
    /// Tipi di nemici disponibili nel gioco
    /// </summary>

    public enum EnemyType
    {
        Drone = 0,
        SecurityGuard = 1,
        Turret = 2,
        Sniper = 10,
        Bruiser = 11,
        Speeder = 12,
        EliteDrone = 20,
        EliteGuard = 21,
        CommandUnit = 22
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/StatusTags.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// Tag che indica che un'entità è attualmente stordita.
    /// Le entità con questo tag sono escluse da sistemi di movimento e attacco.
    /// </summary>

    public struct StunnedTag : IComponentData
    {
    }
     <summary>
    /// Tag che indica che un'entità è attualmente paralizzata.
    /// Simile allo stordimento ma con effetti visivi diversi.
    /// </summary>

    public struct ParalyzedTag : IComponentData
    {
    }
     <summary>
    /// Tag che indica che un'entità è vulnerabile a danni aggiuntivi.
    /// </summary>

    public struct VulnerableTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/DroneComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct DroneComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/MidBossComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// Componente che definisce le caratteristiche di un mid-boss.
    /// I mid-boss sono nemici più potenti dei normali ma meno complessi dei boss finali,
    /// che possono apparire a metà livello o alla fine di segmenti specifici.
    /// </summary>

    public struct MidBossComponent : IComponentData
    {
        public MidBossType Type;
        public int Tier;
        public int AttackDamage;
        public bool HasEnragedState;
        public float EnrageThreshold;
        public float EnragedDamageMultiplier;
        public float EnragedSpeedMultiplier;
        public SpecialAbilityType SpecialAbility;
        public float SpecialAbilityCooldown;
        public float CurrentSpecialCooldown;
        public bool HasSpecialAttacks;
        public float SpecialAttackCooldown;
        public bool IsEnraged;
        public bool IsActivated;
    }
     <summary>
    /// Tipi di mid-boss disponibili nel gioco
    /// </summary>

    public enum MidBossType
    {
        SecurityCaptain = 0,
        ArmoredDrone = 1,
        TurretCommander = 2,
        ElderShaman = 10,
        CorruptedTreent = 11,
        PrimalHunter = 12,
        FrostGiant = 20,
        IceGolem = 21,
        StormCaller = 22,
        LavaConstruct = 30,
        AshWraith = 31,
        MagmaSerpent = 32,
        DeepStalker = 40,
        CoralGuardian = 41,
        VoidSiren = 42,
        BinaryReaper = 50,
        FirewallEnforcer = 51,
        DataPredator = 52
    }
     <summary>
    /// Abilità speciali dei mid-boss
    /// </summary>

    public enum SpecialAbilityType
    {
        None = 0,
        AreaStun = 1,
        ShieldBurst = 2,
        TeleportStrike = 3,
        SummonMinions = 4,
        ElementalFury = 5,
        HealthDrain = 6,
        BerserkRage = 7,
        DamageReflection = 8,
        DeathThroes = 9
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/AIStateComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// 
    /// </summary>

    public struct AIStateComponent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/AttackComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// Componente che definisce le proprietà e i parametri di attacco
    /// per un'entità nemica o per oggetti che possono infliggere danni.
    /// </summary>

    public struct AttackComponent : IComponentData
    {
        public float BaseDamage;
        public float AttackRange;
        public float AttackCooldown;
        public float CurrentCooldown;
        public AttackPatternType PatternType;
        public byte PatternVariant;
        public float PatternSpeed;
        public float CriticalChance;
        public float CriticalMultiplier;
        public ElementType ElementType;
        public StatusEffectType StatusEffect;
        public float StatusEffectChance;
        public float StatusEffectDuration;
        public bool IsAreaEffect;
        public float AreaRadius;
        public float AreaFalloff;
    }
     <summary>
    /// Tipi di pattern di attacco disponibili
    /// </summary>

    public enum AttackPatternType
    {
        Direct = 0,
        Sweep = 1,
        Burst = 2,
        Charge = 3,
        Projectile = 4,
        AOE = 5,
        Summon = 6,
        DoT = 7,
        Teleport = 8,
        Special = 9
    }
     <summary>
    /// Tipi di elementi per gli attacchi
    /// </summary>

    public enum ElementType
    {
        None = 0,
        Fire = 1,
        Ice = 2,
        Electric = 3,
        Poison = 4,
        Digital = 5,
        Water = 6,
        Earth = 7,
        Wind = 8
    }
     <summary>
    /// Tipi di effetti di stato che possono essere applicati da un attacco
    /// </summary>

    public enum StatusEffectType
    {
        None = 0,
        Burn = 1,
        Freeze = 2,
        Paralyze = 3,
        Poison = 4,
        Corrupt = 5,
        Drown = 6,
        Stun = 7,
        Confuse = 8
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/PatrolComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// Componente che definisce il comportamento di pattugliamento di un nemico.
    /// Gestisce il percorso di pattugliamento, le tempistiche e le configurazioni per
    /// i nemici che seguono percorsi predefiniti.
    /// </summary>

    public struct PatrolComponent : IComponentData
    {
        public float3 StartPoint;
        public float3 EndPoint;
        public byte CurrentWaypointIndex;
        public float WaypointReachedDistance;
        public float PatrolSpeed;
        public float WaitTimeAtWaypoint;
        public float WaitTimer;
        public bool IsWaiting;
        public bool IsCircular;
        public bool IsReversing;
        public float LookAheadDistance;
        public float RotationSpeed;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/Enemies/BossComponent.cs

namespace RunawayHeroes.ECS.Components.Enemies
{
     <summary>
    /// Componente che definisce le caratteristiche e il comportamento di un boss.
    /// I boss sono nemici speciali con meccaniche di combattimento complesse basate
    /// su fasi e con attacchi unici al tema del mondo in cui si trovano.
    /// </summary>

    public struct BossComponent : IComponentData
    {
        public BossType Type;
        public int CurrentPhase;
        public int TotalPhases;
        public int BaseDamage;
        public int AttackPatternComplexity;
        public float PhaseThreshold1;
        public float PhaseThreshold2;
        public float PhaseThreshold3;
        public float PhaseThreshold4;
        public float PhaseTransitionTimer;
        public float SpecialAttackCooldown;
        public float CurrentPhaseIntensity;
        public float PhaseIntensityRate;
        public bool IsInvulnerable;
        public float InvulnerabilityTimer;
        public bool HasMinions;
        public int MaxMinionCount;
        public float MinionSpawnCooldown;
        public bool IsEnraged;
        public bool IsActivated;
        public float GetCurrentHealthPercentage(float currentHealth, float maxHealth);
        public bool ShouldTransitionToNextPhase(float currentHealth, float maxHealth);
    }
     <summary>
    /// Tipi di boss disponibili nel gioco
    /// </summary>

    public enum BossType
    {
        SecurityDirector = 0,
        PrototypeWarMech = 1,
        AncientGuardian = 10,
        CorruptedSpirit = 11,
        FrostLord = 20,
        AncientConstruct = 21,
        MoltenTitan = 30,
        FireElemental = 31,
        AbyssalHorror = 40,
        DeepDweller = 41,
        CorruptedAI = 50,
        SecurityOvermind = 51,
        Architect = 100
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/GameplayEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// Sistema che gestisce eventi generali di gameplay come completamento obiettivi,
    /// avanzamento di livello, e altri eventi di gioco
    /// </summary>

    public partial struct GameplayEventHandler : ISystem
    {
        private EntityQuery _objectiveCompletedEventsQuery;
        private EntityQuery _objectiveFailedEventsQuery;
        private EntityQuery _objectiveUpdatedEventsQuery;
        private EntityQuery _levelStartEventsQuery;
        private EntityQuery _levelCompletedEventsQuery;
        private EntityQuery _levelFailedEventsQuery;
        private EntityQuery _fragmentCollectedEventsQuery;
        private EntityQuery _fragmentResonanceEventsQuery;
        private EntityQuery _checkpointEventsQuery;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<MissionComponent> MissionLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<MissionComponent> MissionLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<FragmentInventoryComponent> FragmentInventoryLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema e configura le query per i vari tipi di eventi
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulizia risorse
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Gestisce tutti gli eventi di gameplay nel frame corrente
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(int sortKey, Entity entity, ObjectiveCompletedEvent evt);
        private void Execute(int sortKey, Entity entity, ObjectiveFailedEvent evt);
        private void Execute(int sortKey, Entity entity, ObjectiveUpdatedEvent evt);
        private void Execute(int sortKey, Entity entity, LevelStartEvent evt);
        private void Execute(int sortKey, Entity entity, LevelCompletedEvent evt);
        private void Execute(int sortKey, Entity entity, LevelFailedEvent evt);
        private void Execute(int sortKey, Entity entity, FragmentCollectedEvent evt);
        private void Execute(int sortKey, Entity entity, FragmentResonanceEvent evt);
        private void Execute(int sortKey, Entity entity, CheckpointActivatedEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di completamento obiettivi
        /// </summary>

    private partial struct ProcessObjectiveCompletedEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<MissionComponent> MissionLookup;
        private void Execute(int sortKey, Entity entity, ObjectiveCompletedEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di fallimento obiettivi
        /// </summary>

    private partial struct ProcessObjectiveFailedEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<MissionComponent> MissionLookup;
        private void Execute(int sortKey, Entity entity, ObjectiveFailedEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di aggiornamento obiettivi
        /// </summary>

    private partial struct ProcessObjectiveUpdatedEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(int sortKey, Entity entity, ObjectiveUpdatedEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di inizio livello
        /// </summary>

    private partial struct ProcessLevelStartEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(int sortKey, Entity entity, LevelStartEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di completamento livello
        /// </summary>

    private partial struct ProcessLevelCompletedEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(int sortKey, Entity entity, LevelCompletedEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di fallimento livello
        /// </summary>

    private partial struct ProcessLevelFailedEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(int sortKey, Entity entity, LevelFailedEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di raccolta frammenti
        /// </summary>

    private partial struct ProcessFragmentCollectedEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<FragmentInventoryComponent> FragmentInventoryLookup;
        private void Execute(int sortKey, Entity entity, FragmentCollectedEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi di risonanza frammenti
        /// </summary>

    private partial struct ProcessFragmentResonanceEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(int sortKey, Entity entity, FragmentResonanceEvent evt);
    }
     <summary>
        /// Job che elabora gli eventi relativi ai checkpoint
        /// </summary>

    private partial struct ProcessCheckpointEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(int sortKey, Entity entity, CheckpointActivatedEvent evt);
    }
     <summary>
    /// Evento UI per aggiornamenti livello
    /// </summary>

    public struct LevelUIUpdateEvent : IComponentData
    {
        public int LevelID;
        public byte EventType;
        public float Score;
        public float TimeElapsed;
        public byte FragmentsCollected;
        public byte FailReason;
    }
     <summary>
    /// Evento UI per risonanza frammenti
    /// </summary>

    public struct FragmentResonanceUIEvent : IComponentData
    {
        public Entity ActivatorEntity;
        public byte ResonatingFragmentType;
        public byte CharacterType;
    }
     <summary>
    /// Evento UI per attivazione checkpoint
    /// </summary>

    public struct CheckpointUIEvent : IComponentData
    {
        public int CheckpointID;
        public FixedString64Bytes CheckpointName;
    }
     <summary>
    /// Evento per obiettivo completato
    /// </summary>

    public struct ObjectiveCompletedEvent : IComponentData
    {
        public int ObjectiveID;
        public Entity MissionEntity;
    }
     <summary>
    /// Evento per obiettivo fallito
    /// </summary>

    public struct ObjectiveFailedEvent : IComponentData
    {
        public int ObjectiveID;
        public Entity MissionEntity;
        public byte FailReason;
        public bool IsCritical;
        public float Progress;
    }
     <summary>
    /// Evento per obiettivo aggiornato
    /// </summary>

    public struct ObjectiveUpdatedEvent : IComponentData
    {
        public int ObjectiveID;
        public float Progress;
    }
     <summary>
    /// Evento per missione completata
    /// </summary>

    public struct MissionCompletedEvent : IComponentData
    {
        public Entity MissionEntity;
        public int MissionID;
    }
     <summary>
    /// Evento per missione fallita
    /// </summary>

    public struct MissionFailedEvent : IComponentData
    {
        public Entity MissionEntity;
        public int MissionID;
        public byte FailReason;
    }
     <summary>
    /// Evento per inizio livello
    /// </summary>

    public struct LevelStartEvent : IComponentData
    {
        public int LevelID;
    }
     <summary>
    /// Evento per completamento livello
    /// </summary>

    public struct LevelCompletedEvent : IComponentData
    {
        public int LevelID;
        public float FinalScore;
        public float TimeElapsed;
        public byte FragmentsCollected;
    }
     <summary>
    /// Evento per fallimento livello
    /// </summary>

    public struct LevelFailedEvent : IComponentData
    {
        public int LevelID;
        public byte FailReason;
    }
     <summary>
    /// Evento per frammento raccolto
    /// </summary>

    public struct FragmentCollectedEvent : IComponentData
    {
        public int FragmentID;
        public byte FragmentType;
        public Entity CollectorEntity;
    }
     <summary>
    /// Evento per risonanza frammenti
    /// </summary>

    public struct FragmentResonanceEvent : IComponentData
    {
        public Entity ActivatorEntity;
        public byte FragmentType;
        public byte CharacterType;
    }
     <summary>
    /// Evento per checkpoint attivato
    /// </summary>

    public struct CheckpointActivatedEvent : IComponentData
    {
        public int CheckpointID;
        public FixedString64Bytes CheckpointName;
        public Entity ActivatorEntity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/DamageEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// Sistema che gestisce gli eventi di danno inflitti tra entità
    /// </summary>

    public partial struct DamageEventHandler : ISystem
    {
        private EntityQuery _damageEventsQuery;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<HealthComponent> HealthLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
         <summary>
        /// Inizializza il sistema e definisce le query necessarie
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Esegue la pulizia delle risorse allocate
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Elabora tutti gli eventi di danno presenti nel frame corrente
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(Entity entity, int sortKey, DamageEvent damageEvent);
         <summary>
            /// Calcola il danno effettivo considerando le resistenze della difesa
            /// </summary>

        private float CalculateDamageWithDefense(float rawDamage, RunawayHeroes.ECS.Systems.Movement.DamageType damageType, DefenseComponent defense);
    }
     <summary>
        /// Job che elabora gli eventi di danno
        /// </summary>

    private partial struct ProcessDamageEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<HealthComponent> HealthLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        private void Execute(Entity entity, int sortKey, DamageEvent damageEvent);
         <summary>
            /// Calcola il danno effettivo considerando le resistenze della difesa
            /// </summary>

        private float CalculateDamageWithDefense(float rawDamage, RunawayHeroes.ECS.Systems.Movement.DamageType damageType, DefenseComponent defense);
    }
     <summary>
    /// Evento di feedback visivo per il danno
    /// </summary>

    public struct DamageFeedbackEvent : IComponentData
    {
        public Entity TargetEntity;
        public float DamageAmount;
        public byte DamageType;
        public bool IsCritical;
        public float3 HitPoint;
    }
     <summary>
    /// Evento di morte di un'entità
    /// </summary>

    public struct DeathEvent : IComponentData
    {
        public Entity DeadEntity;
        public Entity KillerEntity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/CollisionEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// Sistema che gestisce gli eventi di collisione tra entità
    /// </summary>

    public partial struct CollisionEventHandler : ISystem
    {
        private EntityQuery _collisionEventsQuery;
        public EntityCommandBuffer ECB;
         <summary>
        /// Inizializza il sistema e definisce le query necessarie
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Esegue la pulizia delle risorse allocate
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Elabora tutti gli eventi di collisione presenti nel frame corrente
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(Entity entity, CollisionEvent collisionEvent);
    }
     <summary>
        /// Job che elabora gli eventi di collisione
        /// </summary>

    private partial struct ProcessCollisionEventsJob : IJobEntity
    {
        public EntityCommandBuffer ECB;
        private void Execute(Entity entity, CollisionEvent collisionEvent);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventHandlers/UIEventHandler.cs

namespace RunawayHeroes.ECS.Events.Handlers
{
     <summary>
    /// Sistema che gestisce gli eventi relativi all'interfaccia utente, 
    /// instradandoli verso i componenti UI appropriati.
    /// </summary>

    public partial struct UIEventHandler : ISystem
    {
        private EntityQuery _uiVisibilityEventsQuery;
        private EntityQuery _uiGenericEventsQuery;
        private EntityQuery _scoreUIEventsQuery;
        private EntityQuery _finalScoreUIEventsQuery;
        private EntityQuery _healthUIEventsQuery;
        private EntityQuery _healthChangeAnimationEventsQuery;
        private EntityQuery _objectiveUIEventsQuery;
        private EntityQuery _missionUIEventsQuery;
        private EntityQuery _collectibleFeedbackEventsQuery;
        private EntityQuery _fragmentUIEventsQuery;
        private EntityQuery _notificationEventsQuery;
        private EntityQuery _tooltipEventsQuery;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIVisibilityComponent> VisibilityLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIHighlightComponent> HighlightLookup;
        public ComponentLookup<UIInteractableComponent> InteractableLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UIScoreDisplayComponent> ScoreDisplayLookup;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIScoreInfoComponent> ScoreInfoLookup;
        public double ElapsedTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UIHealthDisplayComponent> HealthDisplayLookup;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIHealthInfoComponent> HealthInfoLookup;
        public double ElapsedTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIObjectiveInfoComponent> ObjectiveInfoLookup;
        public double ElapsedTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIMissionInfoComponent> MissionInfoLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UIFragmentInventoryComponent> FragmentInventoryLookup;
        public EntityStorageInfoLookup EntityLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UINotificationManagerComponent> NotificationManagerLookup;
        public double ElapsedTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UITooltipManagerComponent> TooltipManagerLookup;
        public double ElapsedTime;
         <summary>
        /// Inizializza il sistema e configura le query per i diversi tipi di eventi UI
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse allocate
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Elabora i vari tipi di eventi UI e li invia ai componenti UI appropriati
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(Entity entity, int sortKey, UIVisibilityEvent visibilityEvent);
        private void Execute(Entity entity, int sortKey, UIGenericEvent genericEvent);
        private void Execute(Entity entity, int sortKey, ScoreUIUpdateEvent scoreEvent);
        private void Execute(Entity entity, int sortKey, FinalScoreUIEvent finalScoreEvent);
        private void Execute(Entity entity, int sortKey, HealthUIUpdateEvent healthEvent);
        private void Execute(Entity entity, int sortKey, HealthChangeAnimationEvent animEvent);
        private void Execute(Entity entity, int sortKey, ObjectiveUIUpdateEvent objectiveEvent);
        private Entity FindObjectiveUIEntity(int objectiveID);
        private void Execute(Entity entity, int sortKey, MissionUIUpdateEvent missionEvent);
        private Entity FindMissionUIEntity(int missionID);
        private void Execute(Entity entity, int sortKey, CollectibleFeedbackEvent feedbackEvent);
        private void Execute(Entity entity, int sortKey, FragmentUIUpdateEvent fragmentEvent);
        private void Execute(Entity entity, int sortKey, NotificationEvent notificationEvent);
        private Entity FindNotificationManager();
        private void Execute(Entity entity, int sortKey, TooltipEvent tooltipEvent);
        private Entity FindTooltipManager();
    }
     <summary>
        /// Job che elabora gli eventi di visibilità UI
        /// </summary>

    private partial struct ProcessUIVisibilityEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIVisibilityComponent> VisibilityLookup;
        private void Execute(Entity entity, int sortKey, UIVisibilityEvent visibilityEvent);
    }
     <summary>
        /// Job che elabora gli eventi generici UI
        /// </summary>

    private partial struct ProcessUIGenericEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIHighlightComponent> HighlightLookup;
        public ComponentLookup<UIInteractableComponent> InteractableLookup;
        private void Execute(Entity entity, int sortKey, UIGenericEvent genericEvent);
    }
     <summary>
        /// Job che elabora gli eventi di aggiornamento punteggio
        /// </summary>

    private partial struct ProcessScoreUIEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UIScoreDisplayComponent> ScoreDisplayLookup;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIScoreInfoComponent> ScoreInfoLookup;
        public double ElapsedTime;
        private void Execute(Entity entity, int sortKey, ScoreUIUpdateEvent scoreEvent);
    }
     <summary>
        /// Job che elabora gli eventi di punteggio finale
        /// </summary>

    private partial struct ProcessFinalScoreUIEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(Entity entity, int sortKey, FinalScoreUIEvent finalScoreEvent);
    }
     <summary>
        /// Job che elabora gli eventi di aggiornamento salute
        /// </summary>

    private partial struct ProcessHealthUIEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UIHealthDisplayComponent> HealthDisplayLookup;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIHealthInfoComponent> HealthInfoLookup;
        public double ElapsedTime;
        private void Execute(Entity entity, int sortKey, HealthUIUpdateEvent healthEvent);
    }
     <summary>
        /// Job che elabora gli eventi di animazione cambio salute
        /// </summary>

    private partial struct ProcessHealthChangeAnimationEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(Entity entity, int sortKey, HealthChangeAnimationEvent animEvent);
    }
     <summary>
        /// Job che elabora gli eventi di aggiornamento obiettivi
        /// </summary>

    private partial struct ProcessObjectiveUIEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIObjectiveInfoComponent> ObjectiveInfoLookup;
        public double ElapsedTime;
        private void Execute(Entity entity, int sortKey, ObjectiveUIUpdateEvent objectiveEvent);
        private Entity FindObjectiveUIEntity(int objectiveID);
    }
     <summary>
        /// Job che elabora gli eventi di aggiornamento missione
        /// </summary>

    private partial struct ProcessMissionUIEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UIMissionInfoComponent> MissionInfoLookup;
        private void Execute(Entity entity, int sortKey, MissionUIUpdateEvent missionEvent);
        private Entity FindMissionUIEntity(int missionID);
    }
     <summary>
        /// Job che elabora gli eventi di feedback collezionabili
        /// </summary>

    private partial struct ProcessCollectibleFeedbackEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(Entity entity, int sortKey, CollectibleFeedbackEvent feedbackEvent);
    }
     <summary>
        /// Job che elabora gli eventi UI per frammenti
        /// </summary>

    private partial struct ProcessFragmentUIEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UIFragmentInventoryComponent> FragmentInventoryLookup;
        public EntityStorageInfoLookup EntityLookup;
        private void Execute(Entity entity, int sortKey, FragmentUIUpdateEvent fragmentEvent);
    }
     <summary>
        /// Job che elabora gli eventi di notifica
        /// </summary>

    private partial struct ProcessNotificationEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UINotificationManagerComponent> NotificationManagerLookup;
        public double ElapsedTime;
        private void Execute(Entity entity, int sortKey, NotificationEvent notificationEvent);
        private Entity FindNotificationManager();
    }
     <summary>
        /// Job che elabora gli eventi tooltip
        /// </summary>

    private partial struct ProcessTooltipEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<UITooltipManagerComponent> TooltipManagerLookup;
        public double ElapsedTime;
        private void Execute(Entity entity, int sortKey, TooltipEvent tooltipEvent);
        private Entity FindTooltipManager();
    }
     <summary>
    /// Tipi di animazione UI
    /// </summary>

    public enum UIAnimationType
    {
        None = 0,
        FadeIn = 1,
        FadeOut = 2,
        Shake = 3,
        Pulse = 4,
        Progress = 5,
        Complete = 6,
        Fail = 7
    }
     <summary>
    /// Tipi di azioni UI
    /// </summary>

    public enum UIActionType
    {
        None = 0,
        Show = 1,
        Hide = 2,
        Highlight = 3,
        Shake = 4,
        Pulse = 5,
        Enable = 6,
        Disable = 7
    }
     <summary>
    /// Evento per la visibilità di elementi UI
    /// </summary>

    public struct UIVisibilityEvent : IComponentData
    {
        public Entity UIEntityTarget;
        public bool ShouldBeVisible;
        public bool ShouldAnimate;
        public float FadeTime;
        public float Delay;
    }
     <summary>
    /// Evento generico per azioni UI
    /// </summary>

    public struct UIGenericEvent : IComponentData
    {
        public Entity UIEntityTarget;
        public UIActionType ActionType;
        public float4 Color;
        public float Duration;
        public float Intensity;
    }
     <summary>
    /// Evento per animazioni UI
    /// </summary>

    public struct UIAnimationEvent : IComponentData
    {
        public Entity UIEntityTarget;
        public UIAnimationType AnimationType;
        public float Duration;
        public float Delay;
        public float Intensity;
        public float4 Color;
    }
     <summary>
    /// Evento per animazioni punteggio
    /// </summary>

    public struct UIScoreAnimationEvent : IComponentData
    {
        public Entity UIScoreEntity;
        public float Amount;
        public byte SourceType;
    }
     <summary>
    /// Evento per animazioni salute
    /// </summary>

    public struct UIHealthAnimationEvent : IComponentData
    {
        public Entity UIHealthEntity;
        public float Amount;
        public bool IsCritical;
    }
     <summary>
    /// Evento per popup collezione
    /// </summary>

    public struct ShowCollectiblePopupEvent : IComponentData
    {
        public Entity CollectorEntity;
        public byte CollectibleType;
        public float Value;
        public float3 WorldPosition;
    }
     <summary>
    /// Evento per animazione frammento
    /// </summary>

    public struct UIFragmentCollectionAnimEvent : IComponentData
    {
        public byte FragmentType;
        public Entity UIInventoryEntity;
    }
     <summary>
    /// Evento per schermata punteggio finale
    /// </summary>

    public struct ShowFinalScoreScreenEvent : IComponentData
    {
        public int LevelID;
        public Entity PlayerEntity;
        public float FinalScore;
        public bool IsHighScore;
        public int TotalCollectibles;
        public int TotalEnemiesDefeated;
        public float TimeBonus;
    }
     <summary>
    /// Evento notifica
    /// </summary>

    public struct NotificationEvent : IComponentData
    {
        public byte NotificationType;
        public byte Priority;
        public float Duration;
        public int TextID;
    }
     <summary>
    /// Evento tooltip
    /// </summary>

    public struct TooltipEvent : IComponentData
    {
        public Entity TargetUIElement;
        public bool Show;
        public int TextID;
        public float2 Position;
        public float Width;
    }
     <summary>
    /// Evento cambio salute animazione
    /// </summary>

    public struct HealthChangeAnimationEvent : IComponentData
    {
        public Entity TargetEntity;
        public float HealthChange;
        public bool IsCritical;
        public float3 WorldPosition;
    }
     <summary>
    /// Evento aggiornamento missione UI
    /// </summary>

    public struct MissionUIUpdateEvent : IComponentData
    {
        public int MissionID;
        public byte CompletedObjectives;
        public byte TotalObjectives;
        public bool IsCompleted;
        public bool IsFailed;
    }
     <summary>
    /// Evento aggiornamento punteggio UI
    /// </summary>

    public struct ScoreUIUpdateEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float NewScore;
        public float ScoreIncrement;
        public byte ScoreSource;
    }
     <summary>
    /// Evento punteggio finale
    /// </summary>

    public struct FinalScoreUIEvent : IComponentData
    {
        public int LevelID;
        public Entity PlayerEntity;
        public float FinalScore;
        public bool IsHighScore;
        public int TotalCollectibles;
        public int TotalEnemiesDefeated;
        public float TimeBonus;
    }
     <summary>
    /// Evento aggiornamento salute UI
    /// </summary>

    public struct HealthUIUpdateEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float NewHealth;
        public float MaxHealth;
        public float HealthChange;
        public bool IsCritical;
    }
     <summary>
    /// Evento aggiornamento obiettivo UI
    /// </summary>

    public struct ObjectiveUIUpdateEvent : IComponentData
    {
        public int ObjectiveID;
        public float Progress;
        public bool IsCompleted;
        public bool IsFailed;
    }
     <summary>
    /// Evento di feedback collezionabile
    /// </summary>

    public struct CollectibleFeedbackEvent : IComponentData
    {
        public Entity CollectorEntity;
        public byte CollectibleType;
        public float Value;
        public float3 CollectionPoint;
    }
     <summary>
    /// Evento di aggiornamento frammento
    /// </summary>

    public struct FragmentUIUpdateEvent : IComponentData
    {
        public int FragmentID;
        public byte FragmentType;
        public Entity CollectorEntity;
    }
     <summary>
    /// Componente per la visibilità UI
    /// </summary>

    public struct UIVisibilityComponent : IComponentData
    {
        public bool IsVisible;
        public float FadeTime;
    }
     <summary>
    /// Componente per highlight UI
    /// </summary>

    public struct UIHighlightComponent : IComponentData
    {
        public bool IsHighlighted;
        public float4 HighlightColor;
        public float Duration;
        public float PulseIntensity;
    }
     <summary>
    /// Componente per interagibilità UI
    /// </summary>

    public struct UIInteractableComponent : IComponentData
    {
        public bool IsEnabled;
        public bool IsHovered;
        public bool IsPressed;
    }
     <summary>
    /// Componente per display punteggio
    /// </summary>

    public struct UIScoreDisplayComponent : IComponentData
    {
        public Entity UIScoreEntity;
    }
     <summary>
    /// Componente per info punteggio UI
    /// </summary>

    public struct UIScoreInfoComponent : IComponentData
    {
        public float CurrentScore;
        public float LastScoreIncrement;
        public byte LastScoreSource;
        public double LastUpdateTime;
    }
     <summary>
    /// Componente per display salute
    /// </summary>

    public struct UIHealthDisplayComponent : IComponentData
    {
        public Entity UIHealthEntity;
    }
     <summary>
    /// Componente per info salute UI
    /// </summary>

    public struct UIHealthInfoComponent : IComponentData
    {
        public float CurrentHealth;
        public float MaxHealth;
        public float LastHealthChange;
        public double LastUpdateTime;
    }
     <summary>
    /// Componente per info obiettivo UI
    /// </summary>

    public struct UIObjectiveInfoComponent : IComponentData
    {
        public int ObjectiveID;
        public float Progress;
        public bool IsCompleted;
        public bool IsFailed;
        public double LastUpdateTime;
    }
     <summary>
    /// Componente per info missione UI
    /// </summary>

    public struct UIMissionInfoComponent : IComponentData
    {
        public int MissionID;
        public byte CompletedObjectives;
        public byte TotalObjectives;
        public bool IsCompleted;
        public bool IsFailed;
    }
     <summary>
    /// Componente per display inventario frammenti
    /// </summary>

    public struct UIFragmentInventoryComponent : IComponentData
    {
        public Entity UIInventoryEntity;
    }
     <summary>
    /// Componente per gestione notifiche
    /// </summary>

    public struct UINotificationManagerComponent : IComponentData
    {
        public byte MaxNotifications;
        public byte ActiveNotificationsCount;
        public float DefaultDuration;
    }
     <summary>
    /// Componente per notifica
    /// </summary>

    public struct UINotificationComponent : IComponentData
    {
        public byte Type;
        public byte Priority;
        public float Duration;
        public int TextID;
        public double CreationTime;
    }
     <summary>
    /// Componente per gestione tooltip
    /// </summary>

    public struct UITooltipManagerComponent : IComponentData
    {
        public Entity CurrentTooltipEntity;
    }
     <summary>
    /// Componente per tooltip
    /// </summary>

    public struct UITooltipComponent : IComponentData
    {
        public Entity TargetUIElement;
        public int TextID;
        public float2 Position;
        public float Width;
        public double CreationTime;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/DamageReceivedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un'entità riceve danno
    /// </summary>

    public struct DamageReceivedEvent : IComponentData
    {
        public Entity TargetEntity;
        public Entity SourceEntity;
        public float DamageAmount;
        public DamageType DamageType;
        public float3 ImpactPosition;
        public float RemainingHealth;
        public float RemainingShield;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/LevelCompletedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un livello è completato con successo.
    /// Contiene informazioni sul livello e le statistiche di completamento.
    /// </summary>

    public struct LevelCompletedEvent : IComponentData
    {
        public int LevelID;
        public float FinalScore;
        public float TimeElapsed;
        public byte FragmentsCollected;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/CollisionEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct CollisionEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/ObstacleInteractionEvent.cs

namespace RunawayHeroes.ECS.Events.EventDefinitions
{
     <summary>
    /// Evento per l'attraversamento della lava
    /// </summary>

    public struct LavaWalkingEvent : IComponentData
    {
        public Entity EntityID;
        public float3 Position;
    }
     <summary>
    /// Evento per l'inizio del teletrasporto tramite Glitch
    /// </summary>

    public struct GlitchTeleportStartEvent : IComponentData
    {
        public Entity EntityID;
        public float3 StartPosition;
        public float3 TargetPosition;
        public Entity BarrierEntity;
    }
     <summary>
    /// Evento per la fine del teletrasporto tramite Glitch
    /// </summary>

    public struct GlitchTeleportEndEvent : IComponentData
    {
        public Entity EntityID;
        public float3 FinalPosition;
    }
     <summary>
    /// Evento per la repulsione di un nemico
    /// </summary>

    public struct EnemyRepulsionEvent : IComponentData
    {
        public Entity EnemyEntity;
        public Entity SourceEntity;
        public float RepulsionForce;
        public float3 Direction;
    }
     <summary>
    /// Evento per lo scioglimento completo di un ostacolo di ghiaccio
    /// </summary>

    public struct IceMeltedEvent : IComponentData
    {
        public Entity SourceEntity;
        public Entity IceEntity;
        public float3 Position;
        public float Size;
    }
     <summary>
    /// Evento per l'interazione con superfici scivolose
    /// </summary>

    public struct SlipInteractionEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity SurfaceEntity;
        public float EffectiveSlipFactor;
        public bool IsNegated;
    }
     <summary>
    /// Evento per l'interazione con correnti (aria/acqua)
    /// </summary>

    public struct CurrentInteractionEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity CurrentEntity;
        public float EffectiveForce;
        public float3 Direction;
        public bool IsNegated;
    }
     <summary>
    /// Evento per l'interazione con zone prive di ossigeno
    /// </summary>

    public struct OxygenInteractionEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity NoOxygenZoneEntity;
        public float RemainingOxygen;
        public bool IsNegated;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/DeathEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un'entità muore
    /// </summary>

    public struct DeathEvent : IComponentData
    {
        public Entity DeadEntity;
        public Entity KillerEntity;
        public DamageType DamageType;
        public float3 DeathPosition;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/FragmentCollectedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un giocatore raccoglie un frammento del Nucleo dell'Equilibrio
    /// </summary>

    public struct FragmentCollectedEvent : IComponentData
    {
        public int FragmentID;
        public byte FragmentType;
        public Entity CollectorEntity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/CharacterSwitchEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct CharacterSwitchEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/FocusTimeEvents.cs

namespace RunawayHeroes.ECS.Events.EventDefinitions
{
     <summary>
    /// Evento generato quando il Focus Time viene attivato
    /// </summary>

    public struct FocusTimeActivatedEvent : IComponentData
    {
        public Entity EntityActivated;
        public float Duration;
        public float TimeScale;
    }
     <summary>
    /// Evento generato quando il Focus Time viene disattivato
    /// </summary>

    public struct FocusTimeDeactivatedEvent : IComponentData
    {
        public Entity EntityDeactivated;
        public float CooldownRemaining;
    }
     <summary>
    /// Evento generato quando il Focus Time è pronto dopo un cooldown
    /// </summary>

    public struct FocusTimeReadyEvent : IComponentData
    {
        public Entity EntityReady;
    }
     <summary>
    /// Evento generato quando l'energia del Focus Time è completamente ricaricata
    /// </summary>

    public struct FocusTimeFullEnergyEvent : IComponentData
    {
        public Entity EntityWithFullEnergy;
    }
     <summary>
    /// Evento generato quando un oggetto viene aggiunto a uno slot del Focus Time
    /// </summary>

    public struct ItemAddedToSlotEvent : IComponentData
    {
        public Entity UserEntity;
        public Entity ItemEntity;
        public int SlotIndex;
    }
     <summary>
    /// Evento generato quando un oggetto viene utilizzato durante il Focus Time
    /// </summary>

    public struct ItemUsedEvent : IComponentData
    {
        public Entity UserEntity;
        public Entity ItemEntity;
        public int SlotIndex;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/DamageBlockedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un danno viene bloccato
    /// </summary>

    public struct DamageBlockedEvent : IComponentData
    {
        public Entity TargetEntity;
        public Entity SourceEntity;
        public float DamageAmount;
        public DamageType DamageType;
        public BlockReason BlockReason;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/MomentEvents.cs

namespace RunawayHeroes.ECS.Events.EventDefinitions
{
     <summary>
    /// Evento generato quando un personaggio inizia a saltare
    /// </summary>

    public struct JumpStartedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float JumpForce;
        public int RemainingJumps;
        public float3 JumpPosition;
    }
     <summary>
    /// Evento generato quando un personaggio atterra
    /// </summary>

    public struct LandingEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float LandingVelocity;
        public float3 LandingPosition;
        public bool IsHardLanding;
    }
     <summary>
    /// Evento generato quando un personaggio inizia a scivolare
    /// </summary>

    public struct SlideStartedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float Duration;
        public float3 StartPosition;
        public float InitialSpeed;
    }
     <summary>
    /// Evento generato quando un personaggio termina una scivolata
    /// </summary>

    public struct SlideEndedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float3 EndPosition;
        public float SlideDistance;
        public float ActualDuration;
    }
     <summary>
    /// Evento generato quando un personaggio inizia a muoversi
    /// </summary>

    public struct MovementStartedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float3 StartPosition;
        public float3 InitialDirection;
    }
     <summary>
    /// Evento generato quando un personaggio smette di muoversi
    /// </summary>

    public struct MovementStoppedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float3 StopPosition;
        public float3 FinalVelocity;
    }
     <summary>
    /// Evento generato quando cambia lo stato di animazione
    /// </summary>

    public struct AnimationStateChangedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public MovementAnimationState State;
        public float Speed;
        public float BlendFactor;
    }
     <summary>
    /// Evento generato quando il personaggio urta un ostacolo
    /// </summary>

    public struct ObstacleHitEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity ObstacleEntity;
        public float3 ImpactPosition;
        public float3 ImpactNormal;
        public float ImpactVelocity;
        public float DamageAmount;
    }
     <summary>
    /// Enumerazione degli stati di animazione per il movimento
    /// </summary>

    public enum MovementAnimationState
    {
        Idle = 0,
        Run = 1,
        Jump = 2,
        Fall = 3,
        Slide = 4,
        Land = 5,
        Hit = 6,
        Ability = 7
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/AbilityActivatedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un'abilità viene attivata
    /// </summary>

    public struct AbilityActivatedEvent : IComponentData
    {
        public Entity EntityID;
        public AbilityType AbilityType;
        public float3 Position;
        public float Duration;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/EnemyDefeatedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct EnemyDefeatedEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/CheckpointReachedEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// 
    /// </summary>

    public struct CheckpointReachedEvent : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Events/EventDefinitions/DamageEvent.cs

namespace RunawayHeroes.ECS.Events
{
     <summary>
    /// Evento generato quando un'entità subisce danno.
    /// Questo evento viene processato da DamageEventHandler per applicare
    /// il danno effettivo alle entità, considerando difese e resistenze.
    /// </summary>

    public struct DamageEvent : IComponentData
    {
        public Entity TargetEntity;
        public Entity SourceEntity;
        public float DamageAmount;
        public RunawayHeroes.ECS.Systems.Movement.DamageType DamageType;
        public bool IsCritical;
        public float3 ImpactPosition;
        public byte StatusEffectType;
        public float StatusEffectDuration;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/FocusTimeUISystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce l'interfaccia utente per il Focus Time,
    /// visualizzando la barra di energia, il cooldown e l'interfaccia radiale per gli oggetti.
    /// </summary>

    public partial struct FocusTimeUISystem : ISystem
    {
        private RectTransform _focusTimeEnergyBar;
        private RectTransform _focusTimeCooldownIndicator;
        private GameObject _radialMenuContainer;
        private RectTransform[] _itemSlots;
        private GameObject _timeScaleEffect;
        private float _pulseAnimationTime;
        private const float PULSE_SPEED;
        private const float PULSE_AMPLITUDE;
        private EntityQuery _playerFocusTimeQuery;
        public void OnCreate(SystemState state);
        public void OnStartRunning(SystemState state);
        public void OnDestroy(SystemState state);
        private void InitializeUIReferences();
        public void OnUpdate(SystemState state);
         <summary>
        /// Aggiorna gli elementi dell'interfaccia del Focus Time in base allo stato attuale
        /// </summary>

        private void UpdateFocusTimeUI(SystemState state);
         <summary>
        /// Processa gli eventi relativi al Focus Time e applica i feedback visivi corrispondenti
        /// </summary>

        private void ProcessFocusTimeEvents(SystemState state);
        private void PlayFocusTimeActivationEffects();
        private void PlayFocusTimeDeactivationEffects();
        private void PlayFocusTimeReadyEffects();
        private void PlayItemUsedEffects(int slotIndex);
        private System.Collections.IEnumerator ResetSlotScale(int slotIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/UIMessageSystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce la visualizzazione dei messaggi UI nel gioco,
    /// inclusi i messaggi di istruzione del tutorial, notifiche e avvisi.
    /// </summary>

    public partial struct UIMessageSystem : ISystem
    {
        private GameObject _messagePanel;
        private TextMeshProUGUI _messageText;
        private Animator _messageAnimator;
        private Image _backgroundImage;
        private Color[] _messageTypeColors;
        private bool _isMessageVisible;
        private float _messageTimer;
        private Entity _currentMessageEntity;
        private Queue<Entity> _messageQueue;
        private const float FADE_IN_TIME;
        private const float FADE_OUT_TIME;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnStartRunning(SystemState state);
         <summary>
        /// Crea dinamicamente un pannello per i messaggi se non esiste già
        /// </summary>

        private void CreateMessagePanelDynamically(Transform parentTransform);
        public void OnUpdate(SystemState state);
         <summary>
        /// Processa nuovi messaggi aggiunti al sistema
        /// </summary>

        private void ProcessNewMessages(SystemState state);
         <summary>
        /// Aggiorna lo stato del messaggio correntemente visualizzato
        /// </summary>

        private void UpdateCurrentMessage(SystemState state);
         <summary>
        /// Mostra il prossimo messaggio nella coda
        /// </summary>

        private void ShowNextMessage(SystemState state);
         <summary>
        /// Processa eventi relativi ai messaggi
        /// </summary>

        private void ProcessMessageEvents(SystemState state);
         <summary>
        /// Mostra il pannello dei messaggi con animazione
        /// </summary>

        private void ShowMessage(SystemState state);
         <summary>
        /// Nasconde il pannello dei messaggi con animazione
        /// </summary>

        private void HideCurrentMessage(SystemState state);
        private System.Collections.IEnumerator FadeIn(CanvasGroup canvasGroup);
        private System.Collections.IEnumerator FadeOut(CanvasGroup canvasGroup, GameObject panel);
        private System.Collections.IEnumerator DisableAfterDelay(GameObject obj, float delay);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/ObjectiveFeedbackSystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce il feedback visivo per gli obiettivi tutorial.
    /// Mostra gli obiettivi correnti, aggiorna l'interfaccia e fornisce feedback al completamento.
    /// </summary>

    public partial struct ObjectiveFeedbackSystem : ISystem
    {
        private GameObject _objectivesPanel;
        private RectTransform _objectivesContainer;
        private Dictionary<int, GameObject> _activeObjectiveItems;
        private GameObject _objectiveItemPrefab;
        private EntityQuery _activeObjectivesQuery;
        public void OnCreate(SystemState state);
        public void OnStartRunning(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         <summary>
        /// Inizializza i riferimenti all'interfaccia utente
        /// </summary>

        private void InitializeUIReferences();
         <summary>
        /// Crea dinamicamente un pannello per gli obiettivi
        /// </summary>

        private void CreateObjectivesPanelDynamically();
         <summary>
        /// Crea un prefab base per gli elementi obiettivo
        /// </summary>

        private GameObject CreateObjectiveItemPrefab();
         <summary>
        /// Aggiorna il pannello degli obiettivi
        /// </summary>

        private void UpdateObjectivesPanel(SystemState state);
         <summary>
        /// Crea un nuovo elemento UI per un obiettivo
        /// </summary>

        private GameObject CreateObjectiveItem(ObjectiveComponent objective, ObjectiveProgressComponent progress);
         <summary>
        /// Aggiorna i dati di un elemento obiettivo esistente
        /// </summary>

        private void UpdateObjectiveItem(GameObject itemObj, ObjectiveComponent objective, ObjectiveProgressComponent progress);
         <summary>
        /// Processa eventi di completamento obiettivi
        /// </summary>

        private void ProcessObjectiveCompletionEvents(SystemState state);
         <summary>
        /// Processa eventi di progresso obiettivi
        /// </summary>

        private void ProcessObjectiveProgressEvents(SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/UI/ResonanceUISystem.cs

namespace RunawayHeroes.ECS.Systems.UI
{
     <summary>
    /// Sistema che gestisce l'interfaccia utente per la Risonanza dei Frammenti,
    /// permettendo al giocatore di cambiare personaggio durante il gameplay.
    /// </summary>

    public partial struct ResonanceUISystem : ISystem
    {
        private GameObject _resonanceButton;
        private GameObject _characterMenu;
        private Button[] _characterButtons;
        private Image[] _characterButtonImages;
        private Image _resonanceButtonImage;
        private Image _cooldownOverlay;
        private GameObject _resonanceWaveEffect;
        private GameObject _resonanceUnlockEffect;
        private Sprite[] _characterSprites;
        private Text _resonanceLevelText;
        private Animator _menuAnimator;
        private bool _isMenuOpen;
        private float _menuCloseTimer;
        private float _waveEffectTimer;
        private float _unlockEffectTimer;
        private EntityQuery _resonanceQuery;
        public SystemState SystemState { ... }
        public void OnCreate(SystemState state);
        public void OnStartRunning(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         <summary>
        /// Aggiorna l'overlay del cooldown
        /// </summary>

        private void UpdateCooldownOverlay(FragmentResonanceComponent resonance);
         <summary>
        /// Aggiorna il testo del livello di risonanza
        /// </summary>

        private void UpdateResonanceLevel(FragmentResonanceComponent resonance);
         <summary>
        /// Aggiorna i timer per le animazioni
        /// </summary>

        private void UpdateTimers(float deltaTime);
         <summary>
        /// Aggiorna l'icona del personaggio attivo nel pulsante principale
        /// </summary>

        private void UpdateActiveCharacterIcon(FragmentResonanceComponent resonance);
         <summary>
        /// Aggiorna le icone e lo stato dei personaggi nel menu
        /// </summary>

        private void UpdateCharacterMenu(FragmentResonanceComponent resonance);
         <summary>
        /// Ottiene l'indice del personaggio attivo
        /// </summary>

        private int GetActiveCharacterIndex(FragmentResonanceComponent resonance);
         <summary>
        /// Attiva/disattiva il menu dei personaggi
        /// </summary>

        private void ToggleCharacterMenu();
         <summary>
        /// Gestisce la selezione di un personaggio
        /// </summary>

        private void OnCharacterSelected(int characterIndex);
         <summary>
        /// Mostra l'effetto per lo sblocco di un nuovo personaggio
        /// </summary>

        public void PlayUnlockEffect(int characterIndex);
    }
    partial class ResonanceUISystemGroup : ComponentSystemGroup
    {
        public SystemState SystemState { ... }
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/RenderSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema responsabile del rendering delle entità nel mondo di gioco,
    /// gestendo la sincronizzazione tra componenti ECS e rappresentazione visiva.
    /// Gestisce aspetti come materiali, mesh, effetti visivi e visibilità delle entità.
    /// </summary>

    public partial struct RenderSystem : ISystem
    {
        private EntityQuery _renderableEntitiesQuery;
         <summary>
        /// Inizializza il sistema di rendering, configurando eventuali risorse grafiche condivise,
        /// shader, e query per le entità che necessitano di rendering.
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna la rappresentazione visiva di tutte le entità con componenti di rendering,
        /// sincronizzando le loro proprietà grafiche con lo stato attuale dei componenti ECS.
        /// Gestisce ottimizzazioni come culling e level of detail.
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Metodo per operazioni di rendering che richiedono accesso all'API Unity
        /// e non sono compatibili con Burst
        /// </summary>

        private void UpdateRenderingState(SystemState state);
    }
     <summary>
    /// Job per sincronizzare i dati di trasformazione con il sistema di rendering
    /// </summary>

    public partial struct SyncRenderTransformsJob : IJobEntity
    {
        public void Execute(TransformComponent transform, RenderComponent renderer);
    }
     <summary>
    /// Componente che collega un'entità ECS con la sua rappresentazione visiva in Unity
    /// </summary>

    public struct RenderComponent : IComponentData
    {
        public Entity VisualEntity;
        public bool IsVisible;
        public float CullingDistance;
        public int RenderLayer;
        public int MaterialID;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/PhysicsSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema che gestisce la simulazione fisica di base per tutte le entità con componenti fisici.
    /// Si occupa di applicare gravità, aggiornare velocità e posizioni e gestire collisioni semplici.
    /// </summary>

    public partial struct PhysicsSystem : ISystem
    {
        private EntityQuery _physicsQuery;
         <summary>
        /// Inizializza il sistema e definisce le query per le entità
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulizia delle risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna la simulazione fisica per tutte le entità rilevanti ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job che esegue la simulazione fisica per ciascuna entità
    /// </summary>

    public partial struct PhysicsSimulationJob : IJobEntity
    {
        public float DeltaTime;
        public void Execute(TransformComponent transform, PhysicsComponent physics);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/EntityLifecycleSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema che gestisce il ciclo di vita delle entità nel mondo di gioco.
    /// Responsabile della creazione, distruzione e gestione dello stato di attivazione
    /// delle entità in base a criteri come distanza dalla telecamera, tempo di vita,
    /// o eventi di gioco.
    /// </summary>

    public partial struct EntityLifecycleSystem : ISystem
    {
        private EntityQuery _timeBasedEntitiesQuery;
        private EntityQuery _distanceBasedEntitiesQuery;
        private EntityQuery _poolableEntitiesQuery;
         <summary>
        /// Inizializza il sistema di gestione del ciclo di vita delle entità e 
        /// configura le query necessarie.
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce eventuali risorse allocate dal sistema
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Gestisce la creazione, distruzione e lo stato di attivazione delle entità
        /// in base a vari criteri come distanza, tempo di vita, o eventi specifici.
        /// </summary>

        public void OnUpdate(SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/CollisionSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema responsabile della rilevazione e gestione delle collisioni tra entità nel gioco.
    /// Integra il sistema di fisica di Unity con l'architettura ECS, gestendo interazioni
    /// tra giocatori, nemici, proiettili, ostacoli e altri elementi interattivi.
    /// </summary>

    public partial struct CollisionSystem : ISystem
    {
        private EntityQuery _collidersQuery;
         <summary>
        /// Inizializza il sistema di collisione, configurando le strutture dati necessarie
        /// per la gestione efficiente delle collisioni e registrando eventuali callback.
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Rileva e gestisce le collisioni tra entità ad ogni frame, generando eventi
        /// appropriati e applicando effetti fisici come rimbalzi, danneggiamenti o trigger.
        /// Ottimizza il processo utilizzando tecniche di broad e narrow phase.
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per la detection delle collisioni (stub)
    /// </summary>

    public partial struct CollisionDetectionJob : IJob
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute();
    }
     <summary>
    /// Evento generato quando avviene una collisione tra due entità
    /// </summary>

    public struct CollisionEvent : IComponentData
    {
        public Entity EntityA;
        public Entity EntityB;
        public float3 ContactPoint;
        public float3 Normal;
        public float ImpactForce;
        public bool IsTrigger;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Core/TransformSystem.cs

namespace RunawayHeroes.ECS.Systems.Core
{
     <summary>
    /// Sistema responsabile della sincronizzazione tra TransformComponent personalizzati e 
    /// il sistema di trasformazione nativo di Unity DOTS. Gestisce posizione, rotazione e scala
    /// delle entità nel mondo di gioco.
    /// </summary>

    public partial struct TransformSystem : ISystem
    {
        private EntityQuery _transformQuery;
         <summary>
        /// Inizializza il sistema di trasformazione, configurando le query di entità
        /// necessarie per la sincronizzazione.
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Cleanup del sistema quando viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna la trasformazione di tutte le entità che hanno sia un TransformComponent
        /// che le necessarie componenti di trasformazione native di Unity DOTS (come Translation,
        /// Rotation, e NonUniformScale).
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per sincronizzare TransformComponent con componenti di trasformazione native
    /// </summary>

    public partial struct SyncTransformsJob : IJobEntity
    {
        public void Execute(LocalTransform localTransform, RunawayHeroes.ECS.Components.Core.TransformComponent transformComponent);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/HitboxSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// Sistema responsabile della gestione delle hitbox di attacco e hurtbox di danno.
    /// Rileva collisioni tra hitbox offensive e hurtbox difensive, generando eventi di danno
    /// quando si verificano impatti validi. Gestisce anche la tempistica degli attacchi e
    /// i frame di invulnerabilità.
    /// </summary>

    public partial struct HitboxSystem : ISystem
    {
        private EntityQuery _hitboxQuery;
        private EntityQuery _hurtboxQuery;
         <summary>
        /// Inizializza il sistema di hitbox e prepara le query per le entità
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna le hitbox e rileva le collisioni ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job che processa tutte le hitbox e rileva collisioni con hurtbox
    /// </summary>

    public struct ProcessHitboxesJob : IJob
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> HitboxEntities;
        public NativeArray<HitboxComponent> HitboxComponents;
        public NativeArray<TransformComponent> HitboxTransforms;
        public NativeArray<Entity> HurtboxEntities;
        public NativeArray<HurtboxComponent> HurtboxComponents;
        public NativeArray<TransformComponent> HurtboxTransforms;
        public void Execute();
    }
     <summary>
    /// Componente che definisce una hitbox (box di attacco)
    /// </summary>

    public struct HitboxComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Radius;
        public float Damage;
        public AttackType AttackType;
        public float KnockbackForce;
        public float InitialActiveTime;
        public float RemainingActiveTime;
        public NativeList<Entity> HitEntities;
    }
     <summary>
    /// Componente che definisce una hurtbox (box di vulnerabilità)
    /// </summary>

    public struct HurtboxComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Radius;
        public float DamageMultiplier;
    }
     <summary>
    /// Tag per indicare entità temporaneamente invulnerabili
    /// </summary>

    public struct InvulnerableTag : IComponentData
    {
    }
     <summary>
    /// Tipi di attacco supportati
    /// </summary>

    public enum AttackType
    {
        Melee = 0,
        Ranged = 1,
        Special = 2,
        Environmental = 3
    }
     <summary>
    /// Evento generato quando una hitbox colpisce una hurtbox
    /// </summary>

    public struct HitEvent : IComponentData
    {
        public Entity AttackerEntity;
        public Entity VictimEntity;
        public Entity HitboxEntity;
        public Entity HurtboxEntity;
        public float3 HitPoint;
        public float Damage;
        public AttackType AttackType;
        public float3 KnockbackDirection;
        public float KnockbackForce;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/KnockbackSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// Sistema che gestisce l'effetto di knockback (spinta) applicato alle entità
    /// in seguito a colpi, esplosioni o altre forze. Applica una forza temporanea
    /// che spinge l'entità in una certa direzione, considerando peso, resistenza
    /// e altre caratteristiche dell'entità.
    /// </summary>

    public partial struct KnockbackSystem : ISystem
    {
        private EntityQuery _knockbackQuery;
        private EntityQuery _hitEventsQuery;
         <summary>
        /// Inizializza il sistema di knockback e prepara le query per le entità
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna gli effetti di knockback ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job che processa gli eventi di hit per applicare nuovo knockback
    /// </summary>

    public struct ProcessHitEventsJob : IJob
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<HitEvent> HitEvents;
        public NativeArray<Entity> HitEntities;
        public EntityManager EntityManager;
        public ComponentLookup<PhysicsComponent> PhysicsLookup;
        public void Execute();
    }
     <summary>
    /// Job che aggiorna le entità con knockback attivo
    /// </summary>

    public partial struct UpdateKnockbackJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, KnockbackComponent knockback, PhysicsComponent physics);
    }
     <summary>
    /// Componente che rappresenta un effetto di knockback attivo su un'entità
    /// </summary>

    public struct KnockbackComponent : IComponentData
    {
        public float3 Direction;
        public float RemainingForce;
        public float RemainingTime;
        public float Duration;
        public Entity AttackerEntity;
    }
     <summary>
    /// Evento generato quando inizia un effetto di knockback
    /// </summary>

    public struct KnockbackStartedEvent : IComponentData
    {
        public Entity VictimEntity;
        public Entity AttackerEntity;
        public float3 KnockbackDirection;
        public float KnockbackForce;
        public float3 StartPosition;
    }
     <summary>
    /// Evento generato quando termina un effetto di knockback
    /// </summary>

    public struct KnockbackEndedEvent : IComponentData
    {
        public Entity VictimEntity;
        public Entity AttackerEntity;
        public float TotalDistance;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/DamageSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// Sistema che gestisce l'applicazione del danno alle entità.
    /// Elabora gli eventi di danno, applica modificatori di resistenza/vulnerabilità 
    /// e notifica gli altri sistemi attraverso eventi specifici.
    /// </summary>

    public partial struct DamageSystem : ISystem
    {
        private EntityQuery _damageEventsQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per elaborare gli eventi di danno
    /// </summary>

    public partial struct ProcessDamageEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<HealthComponent> HealthLookup;
        public ComponentLookup<ArmorComponent> ArmorLookup;
        public EntityManager EntityManager;
        public void Execute(Entity entity, int entityInQueryIndex, DamageEvent damageEvent);
         <summary>
        /// Calcola il danno finale considerando armatura e resistenze
        /// </summary>

        private float CalculateFinalDamage(DamageEvent damageEvent);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/HealthSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// Sistema che gestisce la salute delle entità, il recupero della salute,
    /// la gestione delle invulnerabilità temporanee e lo stato di morte.
    /// </summary>

    public partial struct HealthSystem : ISystem
    {
        private EntityQuery _healthEntitiesQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per gestire il componente salute delle entità
    /// </summary>

    public partial struct ProcessHealthJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, HealthComponent health);
    }
     <summary>
    /// Evento generato quando un'entità rigenera salute
    /// </summary>

    public struct HealthRegeneratedEvent : IComponentData
    {
        public Entity TargetEntity;
        public float RegenAmount;
        public float CurrentHealth;
        public float CurrentShield;
    }
     <summary>
    /// Evento generato quando un'entità rigenera scudo
    /// </summary>

    public struct ShieldRegeneratedEvent : IComponentData
    {
        public Entity TargetEntity;
        public float RegenAmount;
        public float CurrentHealth;
        public float CurrentShield;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Combat/StatusEffectSystem.cs

namespace RunawayHeroes.ECS.Systems.Combat
{
     <summary>
    /// Sistema che gestisce gli effetti di stato sulle entità.
    /// Si occupa di applicare, monitorare e rimuovere effetti come stordimento,
    /// paralisi, vulnerabilità e altri effetti temporanei.
    /// </summary>

    public partial struct StatusEffectSystem : ISystem
    {
        private EntityQuery _stunnedEntitiesQuery;
        private EntityQuery _stunEventQuery;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<StunnedTag> StunnedTagLookup;
        public ComponentLookup<StunDurationComponent> StunDurationLookup;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema di effetti di stato
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna gli effetti di stato su tutte le entità
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(int sortKey, Entity entity, StunEvent stunEvent);
        private void Execute(int sortKey, Entity entity, StunDurationComponent stunDuration);
    }
     <summary>
        /// Job che processa gli eventi di stordimento
        /// </summary>

    private partial struct ProcessStunEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public ComponentLookup<StunnedTag> StunnedTagLookup;
        public ComponentLookup<StunDurationComponent> StunDurationLookup;
        private void Execute(int sortKey, Entity entity, StunEvent stunEvent);
    }
     <summary>
        /// Job che aggiorna lo stato di stordimento
        /// </summary>

    private partial struct UpdateStunEffectsJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(int sortKey, Entity entity, StunDurationComponent stunDuration);
    }
     <summary>
    /// Componente che tiene traccia della durata rimanente di uno stordimento
    /// </summary>

    public struct StunDurationComponent : IComponentData
    {
        public float RemainingTime;
        public float OriginalDuration;
    }
     <summary>
    /// Evento per stordire un'entità
    /// </summary>

    public struct StunEvent : IComponentData
    {
        public Entity TargetEntity;
        public float Duration;
        public StunType Type;
    }
     <summary>
    /// Tipi di stordimento disponibili
    /// </summary>

    public enum StunType
    {
        Light = 0,
        Medium = 1,
        Heavy = 2,
        Freeze = 3,
        Shock = 4,
        Override = 5
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Input/InputSystem.cs

namespace RunawayHeroes.ECS.Systems.Input
{
     <summary>
    /// Sistema che gestisce l'input del giocatore, elaborando i comandi
    /// da tastiera, touch o controller e aggiornando l'InputComponent.
    /// </summary>

    public partial struct InputSystem : ISystem
    {
        private EntityQuery _inputQuery;
         <summary>
        /// Inizializza il sistema e definisce le query per le entità
        /// </summary>

        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna gli input ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per aggiornare gli input del giocatore
    /// </summary>

    public partial struct UpdatePlayerInputJob : IJobEntity
    {
        public bool JumpPressed;
        public bool SlidePressed;
        public bool FocusTimePressed;
        public bool AbilityPressed;
        public bool CharacterSwitchPressed;
        public bool IsMovementEnabled;
        public float LateralMovement;
        public float2 MoveDirection;
        public bool TouchActive;
        public float2 TouchPosition;
        public float TouchDuration;
         <summary>
        /// Aggiorna il componente di input per ogni entità giocatore
        /// </summary>

        public void Execute(InputComponent input);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Input/TouchInputSystem.cs

namespace RunawayHeroes.ECS.Systems.Input
{
     <summary>
    /// Sistema che gestisce gli input touch per dispositivi mobili.
    /// Elabora gli eventi di touch, riconosce i gesti principali e li
    /// converte in componenti di input utilizzabili dagli altri sistemi.
    /// </summary>

    public partial struct TouchInputSystem : ISystem
    {
        private Entity _inputEntity;
        private float _swipeThreshold;
        private float _tapThreshold;
        private float _doubleTapThreshold;
        private bool _isTouching;
        private float _touchStartTime;
        private float2 _touchStartPosition;
        private float _lastTapTime;
         <summary>
        /// Inizializza il sistema di input touch
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulizia delle risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Elabora gli input touch ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Tag per il singleton dell'input touch
    /// </summary>

    public struct TouchInputSingleton : IComponentData
    {
    }
     <summary>
    /// Componente che contiene lo stato dell'input touch
    /// </summary>

    public struct TouchInputComponent : IComponentData
    {
        public bool IsTouching;
        public float2 TouchPosition;
        public float2 TouchDelta;
        public bool Tap;
        public bool DoubleTap;
        public bool SwipeUp;
        public bool SwipeDown;
        public bool SwipeLeft;
        public bool SwipeRight;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Input/GestureRecognitionSystem.cs

namespace RunawayHeroes.ECS.Systems.Input
{
     <summary>
    /// Sistema responsabile del riconoscimento di gesti complessi
    /// come pinch, rotate, e altri pattern di movimento che possono
    /// attivare abilità speciali o comandi di gioco avanzati.
    /// </summary>

    public partial struct GestureRecognitionSystem : ISystem
    {
        private Entity _gestureEntity;
        private float _pinchThreshold;
        private float _rotationThreshold;
        private float _longPressThreshold;
        private float _edgeSwipeThreshold;
        private bool _isMultiTouch;
        private float _touchStartTime;
        private float2 _touch1StartPos;
        private float2 _touch2StartPos;
        private float _initialTouchDistance;
        private float _initialTouchAngle;
         <summary>
        /// Inizializza il sistema di riconoscimento gesti
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulizia delle risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il riconoscimento dei gesti ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Tag per il singleton del sistema di riconoscimento gesti
    /// </summary>

    public struct GestureRecognitionSingleton : IComponentData
    {
    }
     <summary>
    /// Componente che contiene lo stato dei gesti riconosciuti
    /// </summary>

    public struct GestureComponent : IComponentData
    {
        public bool PinchIn;
        public bool PinchOut;
        public bool Rotate;
        public float RotationAngle;
        public bool LongPress;
        public float2 LongPressPosition;
        public bool EdgeSwipeTop;
        public bool EdgeSwipeBottom;
        public bool EdgeSwipeLeft;
        public bool EdgeSwipeRight;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/ObstacleSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce il comportamento e lo stato degli ostacoli nel gioco.
    /// Si occupa di aggiornare, attivare e disattivare ostacoli in base a varie condizioni.
    /// </summary>

    public partial struct ObstacleSystem : ISystem
    {
        private EntityQuery _activeObstaclesQuery;
        private EntityQuery _movingObstaclesQuery;
        private EntityQuery _temporaryObstaclesQuery;
        private EntityQuery _sequencedObstaclesQuery;
        private EntityQuery _damagedObstaclesQuery;
        private float _obstacleUpdateTimer;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PatrolPathComponent> PatrolLookup;
        public ComponentLookup<OscillatingObstacleComponent> OscillatingLookup;
        public ComponentLookup<RotatingObstacleComponent> RotatingLookup;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<RenderComponent> RenderLookup;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PhysicsComponent> PhysicsLookup;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<RenderComponent> RenderLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema di gestione ostacoli
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna lo stato e il comportamento degli ostacoli
        /// </summary>

        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int sortKey, PhysicsComponent physics, TransformComponent transform, ObstacleComponent obstacle);
         void Execute(Entity entity, int sortKey, TemporaryObstacleComponent temporary);
         void Execute(Entity entity, int sortKey, SequencedBehaviorComponent sequence);
         void Execute(Entity entity, int sortKey, ObstacleComponent obstacle, DamagedStateComponent damaged);
         void Execute(Entity entity, int sortKey, TransformComponent transform, ObstacleComponent obstacle);
    }
     <summary>
        /// Job che aggiorna gli ostacoli in movimento
        /// </summary>

    private partial struct UpdateMovingObstaclesJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PatrolPathComponent> PatrolLookup;
        public ComponentLookup<OscillatingObstacleComponent> OscillatingLookup;
        public ComponentLookup<RotatingObstacleComponent> RotatingLookup;
         void Execute(Entity entity, int sortKey, PhysicsComponent physics, TransformComponent transform, ObstacleComponent obstacle);
    }
     <summary>
        /// Job che aggiorna gli ostacoli temporanei (con durata limitata)
        /// </summary>

    private partial struct UpdateTemporaryObstaclesJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<RenderComponent> RenderLookup;
         void Execute(Entity entity, int sortKey, TemporaryObstacleComponent temporary);
    }
     <summary>
        /// Job che aggiorna gli ostacoli con comportamenti in sequenza
        /// </summary>

    private partial struct UpdateSequencedObstaclesJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PhysicsComponent> PhysicsLookup;
         void Execute(Entity entity, int sortKey, SequencedBehaviorComponent sequence);
    }
     <summary>
        /// Job che aggiorna gli ostacoli danneggiati
        /// </summary>

    private partial struct UpdateDamagedObstaclesJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<RenderComponent> RenderLookup;
         void Execute(Entity entity, int sortKey, ObstacleComponent obstacle, DamagedStateComponent damaged);
    }
     <summary>
        /// Job che attiva gli ostacoli in base alla distanza dai giocatori
        /// </summary>

    private partial struct ActivateObstaclesByDistanceJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, TransformComponent transform, ObstacleComponent obstacle);
    }
     <summary>
    /// Componente per ostacoli che si muovono lungo un percorso predefinito
    /// </summary>

    public struct PatrolPathComponent : IComponentData
    {
        public float3 StartPoint;
        public float3 EndPoint;
        public byte CurrentPointIndex;
        public byte TotalPoints;
        public float3 CurrentPoint;
        public float MoveSpeed;
        public bool IsLooping;
        public float3 GetPoint(int index);
    }
     <summary>
    /// Componente per ostacoli che si muovono con moto oscillatorio
    /// </summary>

    public struct OscillatingObstacleComponent : IComponentData
    {
        public float3 CenterPosition;
        public float AmplitudeX;
        public float AmplitudeY;
        public float AmplitudeZ;
        public float FrequencyX;
        public float FrequencyY;
        public float FrequencyZ;
        public float CurrentTime;
    }
     <summary>
    /// Componente per ostacoli rotanti
    /// </summary>

    public struct RotatingObstacleComponent : IComponentData
    {
        public float3 RotationAxis;
        public float RotationSpeed;
    }
     <summary>
    /// Componente per ostacoli temporanei con durata limitata
    /// </summary>

    public struct TemporaryObstacleComponent : IComponentData
    {
        public float TotalLifetime;
        public float RemainingLifetime;
        public bool HasFadeOut;
        public float FadeOutTime;
    }
     <summary>
    /// Componente per ostacoli con comportamenti in sequenza
    /// </summary>

    public struct SequencedBehaviorComponent : IComponentData
    {
        public byte CurrentPhase;
        public byte TotalPhases;
        public float CurrentPhaseTimer;
        public PhaseType Phase1Type;
        public PhaseType Phase2Type;
        public PhaseType Phase3Type;
        public PhaseType Phase4Type;
        public float Phase1Duration;
        public float Phase2Duration;
        public float Phase3Duration;
        public float Phase4Duration;
        public float3 Phase1Direction;
        public float3 Phase2Direction;
        public float3 Phase3Direction;
        public float3 Phase4Direction;
        public float Phase1Speed;
        public float Phase2Speed;
        public float Phase3Speed;
        public float Phase4Speed;
        public float GetPhaseDuration(int phaseIndex);
        public PhaseType GetPhaseType(int phaseIndex);
        public float3 GetPhaseDirection(int phaseIndex);
        public float GetPhaseSpeed(int phaseIndex);
    }
    public enum PhaseType
    {
        Idle = 0,
        Warning = 1,
        Active = 2,
        Recovery = 3
    }
     <summary>
    /// Componente per ostacoli danneggiati
    /// </summary>

    public struct DamagedStateComponent : IComponentData
    {
        public float MaxIntegrity;
        public float CurrentIntegrity;
        public byte DamageLevel;
        public bool IsDestroyed;
        public bool CanRecover;
        public float RecoveryDelay;
        public float RecoveryTimer;
        public bool HasContinuousEffects;
        public float EffectInterval;
        public float EffectTimer;
        public byte EffectType;
    }
     <summary>
    /// Componente per il ritardo della distruzione
    /// </summary>

    public struct DestructionDelayComponent : IComponentData
    {
        public float DestroyDelay;
        public float RemainingTime;
    }
     <summary>
    /// Tag per ostacoli in movimento
    /// </summary>

    public struct MovingObstacleTag : IComponentData
    {
    }
     <summary>
    /// Evento generato quando un ostacolo cambia fase
    /// </summary>

    public struct ObstaclePhaseChangedEvent : IComponentData
    {
        public Entity ObstacleEntity;
        public byte NewPhase;
        public byte TotalPhases;
    }
     <summary>
    /// Evento generato quando un ostacolo viene distrutto
    /// </summary>

    public struct ObstacleDestroyedEvent : IComponentData
    {
        public Entity ObstacleEntity;
    }
     <summary>
    /// Evento generato quando un ostacolo viene riparato
    /// </summary>

    public struct ObstacleRepairedEvent : IComponentData
    {
        public Entity ObstacleEntity;
    }
     <summary>
    /// Evento generato per gli effetti di danno
    /// </summary>

    public struct ObstacleDamageEffectEvent : IComponentData
    {
        public Entity ObstacleEntity;
        public byte DamageLevel;
        public byte EffectType;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RandomLevelGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce la generazione procedurale di livelli randomizzati
    /// in base ai parametri definiti in RandomLevelConfigComponent
    /// </summary>

    public partial struct RandomLevelGenerationSystem : ISystem
    {
        private EntityQuery _configQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per processare le configurazioni di livelli casuali
    /// </summary>

    public partial struct ProcessRandomLevelConfigsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, RandomLevelConfigComponent config, LocalTransform transform);
         <summary>
        /// Genera un livello procedurale basato sulla configurazione specificata
        /// </summary>

        private void GenerateLevel(Entity configEntity, int entityInQueryIndex, RandomLevelConfigComponent config, LocalTransform transform, Unity.Mathematics.Random random, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Crea una nuova stanza nell'ambito del livello generato
        /// </summary>

        private Entity CreateRoom(int entityInQueryIndex, RoomType type, bool isStartRoom, bool isEndRoom, Entity levelEntity, EntityCommandBuffer.ParallelWriter commandBuffer);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/LevelGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema base per la generazione di livelli che coordina sia la generazione predefinita
    /// che quella procedurale per runner
    /// </summary>

    public partial struct LevelGenerationSystem : ISystem
    {
        private EntityQuery _levelQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         <summary>
        /// Crea un'entità con configurazione per la generazione di un livello runner casuale
        /// </summary>
        /// <param name="theme">Tema del mondo da generare</param>
        /// <param name="levelLength">Lunghezza del livello in metri</param>
        /// <param name="seed">Seed per la generazione casuale</param>
        /// <param name="isTutorial">Indica se il livello è un tutorial (difficoltà ridotta)</param>

        public Entity CreateRunnerLevelRequest(SystemState state, WorldTheme theme, int levelLength, int seed, bool isTutorial);
         <summary>
        /// Ottiene un tema complementare per creare varietà nei livelli
        /// </summary>

        private static WorldTheme GetComplementaryTheme(WorldTheme primaryTheme);
    }
     <summary>
    /// Job per processare le richieste di generazione livelli predefiniti
    /// </summary>

    public partial struct ProcessLevelGenerationRequestsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, LevelComponent level, LocalTransform transform);
         <summary>
        /// Genera un livello predefinito in base ai dati di configurazione
        /// </summary>

        private void GeneratePredefinedLevel(Entity levelEntity, int entityInQueryIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/CheckpointSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile della gestione dei checkpoint nei livelli,
    /// inclusa l'attivazione, il salvataggio dello stato del giocatore e il respawn
    /// </summary>

    public partial struct CheckpointSystem : ISystem
    {
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/ThematicObstacleGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile della generazione di ostacoli tematici nei segmenti di percorso
    /// </summary>

    public partial struct ThematicObstacleGenerationSystem : ISystem
    {
        private Unity.Mathematics.Random _random;
        private uint _seed;
        private EntityQuery _segmentsRequiringContentQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         <summary>
        /// Genera ostacoli tematici per un segmento di percorso
        /// </summary>

        private void GenerateThematicObstacles(Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, ObstacleSpawnConfigComponent config, EntityCommandBuffer commandBuffer, Unity.Mathematics.Random random);
         <summary>
        /// Seleziona un codice di ostacolo appropriato per il tema e la difficoltà
        /// </summary>

        private string SelectObstacleForTheme(WorldTheme theme, int difficultyLevel, bool isTutorial, ObstacleSpawnConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Determina il tipo di contenuto del segmento in base al codice dell'ostacolo
        /// </summary>

        private SegmentContentType DetermineContentTypeFromObstacleCode(string obstacleCode);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/ObstacleSystemGroup.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che raggruppa tutti i sistemi relativi agli ostacoli
    /// </summary>

    partial class ObstacleSystemGroup : ComponentSystemGroup
    {
        protected override void OnCreate();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/EnvironmentalEffectSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile per la gestione degli effetti ambientali nel mondo di gioco,
    /// come particelle, suoni ambientali, e condizioni meteorologiche
    /// </summary>

    public partial struct EnvironmentalEffectSystem : ISystem
    {
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/SegmentContentGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile della generazione dei contenuti (ostacoli, nemici, ecc.) in un segmento di percorso
    /// </summary>

    public partial struct SegmentContentGenerationSystem : ISystem
    {
        private uint _seed;
        private EntityQuery _segmentQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per generare i contenuti dei segmenti
    /// </summary>

    public partial struct GenerateSegmentContentsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public uint Seed;
        public ObstacleSpawnConfigComponent ObstacleConfig;
        public EnemySpawnConfigComponent EnemyConfig;
        public void Execute(Entity segmentEntity, int entityInQueryIndex, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer);
         <summary>
        /// Genera ostacoli all'interno di un segmento
        /// </summary>

        private void GenerateObstacles(int entityInQueryIndex, Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, ObstacleSpawnConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Aggiunge tag speciali agli ostacoli in base al tema del segmento
        /// </summary>

        private void AddSpecialObstacleTags(int entityInQueryIndex, Entity obstacleEntity, WorldTheme theme, ObstacleSpawnConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Genera nemici all'interno di un segmento
        /// </summary>

        private void GenerateEnemies(int entityInQueryIndex, Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, EnemySpawnConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Genera un singolo nemico nella posizione specificata
        /// </summary>

        private void SpawnEnemy(int entityInQueryIndex, Entity segmentEntity, float3 position, WorldTheme theme, DynamicBuffer<SegmentContentBuffer> contentBuffer, EnemySpawnConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Genera collezionabili all'interno di un segmento
        /// </summary>

        private void GenerateCollectibles(int entityInQueryIndex, Entity segmentEntity, PathSegmentComponent segment, DynamicBuffer<SegmentContentBuffer> contentBuffer, Unity.Mathematics.Random random);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RoomConnectionSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce la creazione e il collegamento di doorway tra le stanze
    /// </summary>

    public partial struct RoomConnectionSystem : ISystem
    {
        private EntityQuery _roomsQuery;
        private EntityQuery _unconnectedRoomsQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         <summary>
        /// Identifica le stanze che non hanno connessioni e le marca per la connessione
        /// </summary>

        private void FindUnconnectedRooms(SystemState state, EntityCommandBuffer commandBuffer);
         <summary>
        /// Collega le stanze che richiedono una connessione
        /// </summary>

        private void ConnectRooms(SystemState state, EntityCommandBuffer commandBuffer);
         <summary>
        /// Crea una nuova doorway per una stanza nella direzione specificata
        /// </summary>

        private void CreateDoorway(Entity roomEntity, DynamicBuffer<RoomDoorwayBuffer> doorways, DoorwayDirection direction, EntityCommandBuffer commandBuffer);
    }
     <summary>
    /// Tag component per identificare le stanze che richiedono una connessione
    /// </summary>

    public struct RequiresConnectionTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/HazardSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce le zone pericolose (hazard) nell'ambiente di gioco.
    /// Si occupa del rilevamento di entità all'interno di aree pericolose,
    /// dell'applicazione di danni e effetti di stato, e dell'aggiornamento
    /// delle proprietà delle zone pericolose nel tempo.
    /// </summary>

    public partial struct HazardSystem : ISystem
    {
        private EntityQuery _hazardsQuery;
        private EntityQuery _vulnerableEntitiesQuery;
        private ComponentLookup<StatusEffectComponent> _statusEffectLookup;
        private float _effectTimer;
        public float DeltaTime;
        public float EffectTimer;
        public NativeArray<float3> VulnerablePositions;
        public NativeArray<Entity> VulnerableEntities;
        public ComponentLookup<StatusEffectComponent> StatusEffects;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema di gestione delle zone pericolose
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna gli effetti delle zone pericolose
        /// </summary>

        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int sortKey, TransformComponent transform, HazardComponent hazard);
         void Execute(Entity entity, int sortKey, HazardComponent hazard);
    }
     <summary>
        /// Job che gestisce gli effetti delle zone pericolose sulle entità
        /// </summary>

    private partial struct ProcessHazardZonesJob : IJobEntity
    {
        public float DeltaTime;
        public float EffectTimer;
        public NativeArray<float3> VulnerablePositions;
        public NativeArray<Entity> VulnerableEntities;
        public ComponentLookup<StatusEffectComponent> StatusEffects;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, TransformComponent transform, HazardComponent hazard);
    }
     <summary>
        /// Job che aggiorna gli effetti visivi delle zone pericolose
        /// </summary>

    private partial struct UpdateHazardVisualsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, HazardComponent hazard);
    }
     <summary>
    /// Componente che rappresenta un effetto di stato attivo su un'entità
    /// </summary>

    public struct StatusEffectComponent : IComponentData
    {
        public byte Type;
        public float Intensity;
        public float Duration;
        public float RemainingDuration;
        public Entity SourceEntity;
    }
     <summary>
    /// Tag per entità invulnerabili ai pericoli
    /// </summary>

    public struct InvulnerableTag : IComponentData
    {
    }
     <summary>
    /// Evento generato per gli effetti visivi delle zone pericolose
    /// </summary>

    public struct HazardVisualEffectEvent : IComponentData
    {
        public Entity HazardEntity;
        public byte EffectType;
        public float Intensity;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RoomPopulationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile del popolamento delle stanze con nemici, collezionabili e ostacoli
    /// </summary>

    public partial struct RoomPopulationSystem : ISystem
    {
        private uint _seed;
        private EntityQuery _roomQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per popolare le stanze con contenuto
    /// </summary>

    public partial struct PopulateRoomsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public uint Seed;
        public void Execute(Entity roomEntity, int entityInQueryIndex, RoomComponent room);
         <summary>
        /// Popola una stanza con nemici, collezionabili e ostacoli in base alle probabilità specificate
        /// </summary>

        private void PopulateRoom(int entityInQueryIndex, Entity roomEntity, RoomComponent room, float enemyProbability, float collectibleProbability, float obstacleProbability, Unity.Mathematics.Random random);
         <summary>
        /// Crea un nemico nella stanza specificata
        /// </summary>

        private void CreateEnemy(int entityInQueryIndex, Entity roomEntity, RoomComponent room, Unity.Mathematics.Random random);
         <summary>
        /// Crea un oggetto collezionabile nella stanza specificata
        /// </summary>

        private void CreateCollectible(int entityInQueryIndex, Entity roomEntity, RoomComponent room, Unity.Mathematics.Random random);
         <summary>
        /// Crea un ostacolo nella stanza specificata
        /// </summary>

        private void CreateObstacle(int entityInQueryIndex, Entity roomEntity, RoomComponent room, Unity.Mathematics.Random random);
    }
     <summary>
    /// Tag component per identificare le stanze già popolate
    /// </summary>

    public struct RoomPopulatedTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/DynamicSegmentLoadingSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema che gestisce il caricamento dinamico dei segmenti del percorso
    /// man mano che il giocatore avanza nel livello
    /// </summary>

    public partial struct DynamicSegmentLoadingSystem : ISystem
    {
        private const float ACTIVATION_DISTANCE;
        private const float DEACTIVATION_DISTANCE;
        public float3 PlayerPosition;
        public float ActivationDistance;
        public float DeactivationDistance;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity segmentEntity, int chunkIndexInQuery, PathSegmentComponent segment);
    }
    private partial struct ManageSegmentActivationJob : IJobEntity
    {
        public float3 PlayerPosition;
        public float ActivationDistance;
        public float DeactivationDistance;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
         void Execute(Entity segmentEntity, int chunkIndexInQuery, PathSegmentComponent segment);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/World/RunnerLevelGenerationSystem.cs

namespace RunawayHeroes.ECS.Systems.World
{
     <summary>
    /// Sistema responsabile della generazione procedurale dei livelli per il gioco runner
    /// </summary>

    public partial struct RunnerLevelGenerationSystem : ISystem
    {
        private const float DEFAULT_SEGMENT_LENGTH;
        private EntityQuery _levelConfigQuery;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public EntityManager EntityManager;
        private const float DEFAULT_SEGMENT_LENGTH;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int entityInQueryIndex, RunnerLevelConfigComponent config, LocalTransform transform);
         <summary>
        /// Genera l'entità principale del livello
        /// </summary>

        private Entity GenerateLevel(int entityInQueryIndex, RunnerLevelConfigComponent config, int numSegments, LocalTransform transform, Unity.Mathematics.Random random);
         <summary>
        /// Genera i segmenti del percorso per il livello
        /// </summary>

        private void GeneratePathSegments(int entityInQueryIndex, Entity levelEntity, int numSegments, RunnerLevelConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Determina il tipo di segmento in base alla posizione e alla varietà richiesta
        /// </summary>

        private SegmentType DetermineSegmentType(int index, int totalSegments, float varietyFactor, Unity.Mathematics.Random random);
         <summary>
        /// Crea un segmento di percorso
        /// </summary>

        private Entity CreatePathSegment(int entityInQueryIndex, Entity levelEntity, int segmentIndex, int difficultyLevel, SegmentType type, WorldTheme theme, bool isActive, Entity prevSegment, Unity.Mathematics.Random random);
    }
     <summary>
    /// Job per elaborare le richieste di generazione livello
    /// </summary>

    public partial struct ProcessRunnerLevelRequestsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public EntityManager EntityManager;
        private const float DEFAULT_SEGMENT_LENGTH;
         void Execute(Entity entity, int entityInQueryIndex, RunnerLevelConfigComponent config, LocalTransform transform);
         <summary>
        /// Genera l'entità principale del livello
        /// </summary>

        private Entity GenerateLevel(int entityInQueryIndex, RunnerLevelConfigComponent config, int numSegments, LocalTransform transform, Unity.Mathematics.Random random);
         <summary>
        /// Genera i segmenti del percorso per il livello
        /// </summary>

        private void GeneratePathSegments(int entityInQueryIndex, Entity levelEntity, int numSegments, RunnerLevelConfigComponent config, Unity.Mathematics.Random random);
         <summary>
        /// Determina il tipo di segmento in base alla posizione e alla varietà richiesta
        /// </summary>

        private SegmentType DetermineSegmentType(int index, int totalSegments, float varietyFactor, Unity.Mathematics.Random random);
         <summary>
        /// Crea un segmento di percorso
        /// </summary>

        private Entity CreatePathSegment(int entityInQueryIndex, Entity levelEntity, int segmentIndex, int difficultyLevel, SegmentType type, WorldTheme theme, bool isActive, Entity prevSegment, Unity.Mathematics.Random random);
    }
     <summary>
/// Tag per indicare che un segmento richiede la generazione dei contenuti
/// </summary>

    public struct RequiresContentGenerationTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/UrbanDashSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Scatto Urbano" di Alex.
    /// Si occupa dell'attivazione, della durata e degli effetti dell'abilità,
    /// inclusi velocità aumentata, invulnerabilità e capacità di sfondare ostacoli.
    /// </summary>

    public partial struct UrbanDashSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int entityIndexInQuery, UrbanDashAbilityComponent urbanDash, MovementComponent movement, HealthComponent health, PhysicsComponent physics, AbilityInputComponent abilityInput, TransformComponent transform, AlexComponent alexComponent);
    }
     <summary>
        /// Job responsabile dell'aggiornamento dell'abilità "Scatto Urbano"
        /// </summary>

    private partial struct UpdateUrbanDashJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int entityIndexInQuery, UrbanDashAbilityComponent urbanDash, MovementComponent movement, HealthComponent health, PhysicsComponent physics, AbilityInputComponent abilityInput, TransformComponent transform, AlexComponent alexComponent);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/FireproofBodySystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Corpo Ignifugo" di Ember.
    /// Si occupa della trasformazione in forma ignea che permette
    /// di attraversare la lava e resistere al calore estremo.
    /// </summary>

    public partial struct FireproofBodySystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _lavaQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Componente per l'effetto visivo del corpo ignifugo
    /// </summary>

    public struct FireBodyVisualComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Duration;
        public float RemainingTime;
    }
     <summary>
    /// Evento per l'attraversamento della lava
    /// </summary>

    public struct LavaWalkingEvent : IComponentData
    {
        public Entity EntityID;
        public float3 Position;
    }
     <summary>
    /// Job per elaborare l'abilità Fireproof Body
    /// </summary>

    public partial struct FireproofBodyJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> LavaHazards;
        public NativeArray<float3> LavaPositions;
        public NativeArray<float> LavaRadii;
        public NativeArray<bool> HasRadiusData;
        public void Execute(Entity entity, int entityInQueryIndex, FireproofBodyAbilityComponent fireproofBody, HealthComponent health, AbilityInputComponent abilityInput, TransformComponent transform, EmberComponent emberComponent);
    }
     <summary>
    /// Job per aggiornare le visualizzazioni del corpo ignifugo
    /// </summary>

    public partial struct FireBodyVisualUpdateJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<TransformComponent> TransformLookup;
        public void Execute(int chunkIndexInQuery, Entity entity, FireBodyVisualComponent fireVisual, TransformComponent transform);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/FragmentResonanceSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce la meccanica "Risonanza dei Frammenti", che permette
    /// ai giocatori di cambiare personaggio istantaneamente durante il gameplay.
    /// </summary>

    public partial struct FragmentResonanceSystem : ISystem
    {
        private EntityQuery _resonanceQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public void OnCreate(SystemState state);
         void Execute(Entity entity, int chunkIndexInQuery, FragmentResonanceComponent resonance, FocusTimeComponent focusTime, HealthComponent health, ResonanceInputComponent input, TransformComponent transform);
        public void OnUpdate(SystemState state);
    }
    public partial struct FragmentResonanceJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
         void Execute(Entity entity, int chunkIndexInQuery, FragmentResonanceComponent resonance, FocusTimeComponent focusTime, HealthComponent health, ResonanceInputComponent input, TransformComponent transform);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/NatureCallSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Richiamo della Natura" di Maya.
    /// Si occupa dell'evocazione di animali alleati temporanei che
    /// distraggono i nemici.
    /// </summary>

    public partial struct NatureCallSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _enemyQuery;
        private EntityQuery _allyQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Componente che definisce un alleato naturale evocato da Maya
    /// </summary>

    public struct NatureAllyComponent : IComponentData
    {
        public Entity TargetEnemy;
        public Entity OwnerEntity;
        public float Duration;
        public float RemainingTime;
    }
     <summary>
    /// Tag per identificare le entità che devono essere distrutte
    /// </summary>

    public struct DisableEntityTag : IComponentData
    {
    }
     <summary>
    /// Job per processare l'abilità NatureCall
    /// </summary>

    public struct NatureCallAbilityJob
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityQuery EnemyQuery;
        public EntityTypeHandle EntityTypeHandle;
        public void Run(EntityManager entityManager, EntityQuery query);
    }
     <summary>
    /// Job per il comportamento base degli alleati naturali
    /// </summary>

    public partial struct NatureAllyBehaviorJob : IJobEntity
    {
        public float DeltaTime;
        public float GameTime;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int entityInQueryIndex, NatureAllyComponent ally, TransformComponent transform);
    }
     <summary>
    /// Job per l'interazione degli alleati con i target nemici
    /// </summary>

    public struct NatureAllyTargetInteractionJob
    {
        public float DeltaTime;
        public float GameTime;
        public void Run(EntityManager entityManager, EntityQuery query);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/ControlledGlitchSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Glitch Controllato" di Neo.
    /// Si occupa della deformazione temporanea della realtà che permette
    /// di attraversare barriere digitali.
    /// </summary>

    public partial struct ControlledGlitchSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _barrierQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Tag per identificare le barriere digitali
    /// </summary>

    public struct DigitalBarrierTag : IComponentData
    {
    }
     <summary>
    /// Evento per l'inizio del teletrasporto
    /// </summary>

    public struct GlitchTeleportStartEvent : IComponentData
    {
        public Entity EntityID;
        public float3 StartPosition;
        public float3 TargetPosition;
        public Entity BarrierEntity;
    }
     <summary>
    /// Evento per la fine del teletrasporto
    /// </summary>

    public struct GlitchTeleportEndEvent : IComponentData
    {
        public Entity EntityID;
        public float3 FinalPosition;
    }
     <summary>
    /// Job per gestire l'abilità di Glitch Controllato
    /// </summary>

    public partial struct ControlledGlitchJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> Barriers;
        public NativeArray<float3> BarrierPositions;
        public void Execute(Entity entity, int entityInQueryIndex, ControlledGlitchAbilityComponent glitch, TransformComponent transform, PhysicsComponent physics, AbilityInputComponent abilityInput, NeoComponent neoComponent);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/AbilitySystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema base per la gestione delle abilità dei personaggi.
    /// Si occupa della ricezione degli input e del routing verso i sistemi
    /// specifici di ciascuna abilità.
    /// </summary>

    public partial struct AbilitySystem : ISystem
    {
        private EntityQuery _inputQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Enumerazione dei tipi di abilità disponibili
    /// </summary>

    public enum AbilityType
    {
        None = 0,
        UrbanDash = 1,
        NatureCall = 2,
        HeatAura = 3,
        FireproofBody = 4,
        AirBubble = 5,
        ControlledGlitch = 6
    }
     <summary>
    /// Evento generato quando un'abilità termina
    /// </summary>

    public struct AbilityEndedEvent : IComponentData
    {
        public Entity EntityID;
        public AbilityType AbilityType;
    }
     <summary>
    /// Evento generato quando un'abilità è pronta (cooldown terminato)
    /// </summary>

    public struct AbilityReadyEvent : IComponentData
    {
        public Entity EntityID;
        public AbilityType AbilityType;
    }
     <summary>
    /// Job per elaborare gli input di abilità
    /// </summary>

    public partial struct AbilityInputProcessorJob : IJobEntity
    {
         void Execute(Entity entity, AbilityInputComponent abilityInput, InputComponent input, PlayerDataComponent playerData);
         <summary>
        /// Determina il tipo di abilità associata a un personaggio
        /// </summary>

        private AbilityType GetAbilityTypeForCharacter(CharacterType characterType);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/AirBubbleSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
    public partial struct AirBubbleSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _underwaterEnemyQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> UnderwaterEnemies;
        public NativeArray<float3> EnemyPositions;
        public NativeArray<PhysicsComponent> EnemyPhysics;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityManager EntityManager;
        public void OnCreate(SystemState state);
        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleAbilityComponent airBubble, AbilityInputComponent abilityInput, TransformComponent transform, MarinaComponent marinaComponent);
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleVisualComponent bubbleVisual, TransformComponent transform);
    }
    private partial struct AirBubbleUpdateJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> UnderwaterEnemies;
        public NativeArray<float3> EnemyPositions;
        public NativeArray<PhysicsComponent> EnemyPhysics;
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleAbilityComponent airBubble, AbilityInputComponent abilityInput, TransformComponent transform, MarinaComponent marinaComponent);
    }
    private partial struct AirBubbleVisualUpdateJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityManager EntityManager;
         void Execute(Entity entity, int chunkIndexInQuery, AirBubbleVisualComponent bubbleVisual, TransformComponent transform);
    }
    public struct AirBubbleVisualComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Radius;
        public float Duration;
        public float RemainingTime;
    }
    public struct UnderwaterTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/HeatAuraSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce l'abilità "Aura di Calore" di Kai.
    /// Si occupa della generazione di un campo di calore che scioglie
    /// il ghiaccio e protegge dal freddo.
    /// </summary>

    public partial struct HeatAuraSystem : ISystem
    {
        private EntityQuery _abilityQuery;
        private EntityQuery _iceObstacleQuery;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Componente per l'effetto visivo dell'aura di calore
    /// </summary>

    public struct HeatAuraVisualComponent : IComponentData
    {
        public Entity OwnerEntity;
        public float Radius;
        public float Duration;
        public float RemainingTime;
    }
     <summary>
    /// Tag per identificare gli ostacoli di ghiaccio
    /// </summary>

    public struct IceObstacleTag : IComponentData
    {
    }
     <summary>
    /// Componente per tracciare l'integrità del ghiaccio
    /// </summary>

    public struct IceIntegrityComponent : IComponentData
    {
        public float MaxIntegrity;
        public float CurrentIntegrity;
    }
     <summary>
    /// Componente per l'effetto visivo di scioglimento del ghiaccio
    /// </summary>

    public struct IceMeltEffectComponent : IComponentData
    {
        public float3 Position;
        public float Size;
    }
     <summary>
    /// Job per elaborare l'abilità Heat Aura
    /// </summary>

    public partial struct HeatAuraProcessingJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public NativeArray<Entity> IceObstacles;
        public NativeArray<float3> ObstaclePositions;
        public NativeArray<float> ObstacleScales;
        public NativeArray<IceIntegrityComponent> IceIntegrities;
        public NativeArray<bool> HasIntegrity;
        public void Execute(Entity entity, int entityInQueryIndex, HeatAuraAbilityComponent heatAura, AbilityInputComponent abilityInput, TransformComponent transform, KaiComponent kaiComponent);
        public void OnDestroy();
    }
     <summary>
    /// Job per aggiornare le visualizzazioni dell'aura di calore
    /// </summary>

    public partial struct HeatAuraVisualUpdateJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<TransformComponent> TransformLookup;
        public void Execute(int chunkIndexInQuery, Entity entity, HeatAuraVisualComponent auraVisual, TransformComponent transform);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Abilities/FocusTimeSystem.cs

namespace RunawayHeroes.ECS.Systems.Abilities
{
     <summary>
    /// Sistema che gestisce la meccanica del "Focus Time", permettendo al giocatore di
    /// rallentare il tempo per prendere decisioni strategiche e utilizzare oggetti.
    /// </summary>

    public partial struct FocusTimeSystem : ISystem
    {
        private EntityQuery _focusTimeQuery;
        private Entity _timeManagerEntity;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public NativeReference<bool> AnyFocusTimeActive;
        public void OnCreate(SystemState state);
         void Execute(Entity entity, int chunkIndexInQuery, FocusTimeComponent focusTime, FocusTimeInputComponent input);
        public void OnUpdate(SystemState state);
    }
    public partial struct FocusTimeProcessorJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter CommandBuffer;
        public NativeReference<bool> AnyFocusTimeActive;
         void Execute(Entity entity, int chunkIndexInQuery, FocusTimeComponent focusTime, FocusTimeInputComponent input);
    }
     <summary>
    /// Componente che gestisce la scala del tempo globale
    /// </summary>

    public struct TimeScaleComponent : IComponentData
    {
        public float Scale;
    }
     <summary>
    /// Tag per identificare l'entità manager del tempo
    /// </summary>

    public struct TimeManagerTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/SlideSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce la meccanica di scivolata del giocatore.
    /// Si occupa di avviare le scivolate in risposta all'input, gestire la durata
    /// e gli effetti collaterali come l'altezza ridotta per passare sotto gli ostacoli.
    /// </summary>

    public partial struct SlideSystem : ISystem
    {
        private EntityQuery _slidableEntitiesQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, SlideInputComponent slideInput);
    }
    private partial struct SlideProcessorJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, SlideInputComponent slideInput);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/JumpSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce il salto del giocatore in risposta all'input.
    /// Si occupa di avviare i salti, gestire i salti multipli e coordinare
    /// con il sistema di fisica per applicare le forze appropriate.
    /// </summary>

    public partial struct JumpSystem : ISystem
    {
        private EntityQuery _jumpableEntitiesQuery;
        public EntityCommandBuffer.ParallelWriter ECB;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, JumpInputComponent jumpInput);
    }
    private partial struct JumpProcessorJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public void Execute(Entity entity, int entityInQueryIndex, PhysicsComponent physics, MovementComponent movement, TransformComponent transform, JumpInputComponent jumpInput);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/ObstacleInteractionSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce le interazioni speciali tra i personaggi e gli ostacoli in base alle loro abilità.
    /// Estende le funzionalità di base dell'ObstacleCollisionSystem per supportare l'interazione con tutti i tipi di ostacoli
    /// in base alle abilità dei vari personaggi.
    /// </summary>

    public partial struct ObstacleInteractionSystem : ISystem
    {
        private EntityQuery _playerQuery;
        private EntityQuery _obstacleQuery;
        private EntityQuery _specialObstaclesQuery;
        private const float INTERACTION_RADIUS;
        private const float MELT_RATE;
        private const float BARRIER_PENETRATION_DISTANCE;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public ComponentLookup<SlipperyTag> SlipperyTagLookup;
        public NativeArray<Entity> SpecialObstacles;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public float InteractionRadius;
        public float MeltRate;
        public float BarrierPenetrationDistance;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity playerEntity, int chunkIndexInQuery, TransformComponent playerTransform, PhysicsComponent physics);
         <summary>
        /// Gestisce l'interazione con gli ostacoli di lava per Ember
        /// </summary>

        private static void HandleLavaInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Gestisce l'interazione di scioglimento del ghiaccio per Kai
        /// </summary>

        private static void HandleIceMeltingInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, float auraRadius, EntityCommandBuffer.ParallelWriter commandBuffer, float deltaTime);
         <summary>
        /// Gestisce l'interazione con le barriere digitali per Neo
        /// </summary>

        private static void HandleDigitalBarrierInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, float glitchDistance, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Gestisce l'interazione con l'ambiente sottomarino per Marina
        /// </summary>

        private static void HandleUnderwaterInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, float bubbleRadius, float repelForce, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Gestisce l'interazione con superfici scivolose per tutti i personaggi
        /// </summary>

        private static void HandleSlipperyInteraction(Entity playerEntity, int entityInQueryIndex, float3 playerPos, bool hasHeatAura, EntityCommandBuffer.ParallelWriter commandBuffer);
         <summary>
        /// Verifica se un'entità contiene una certa abilità e se è attiva
        /// </summary>

        private static bool HasActiveAbility(Entity entity, ComponentLookup<T> lookup);
    }
    private partial struct SpecialObstacleInteractionJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public ComponentLookup<SlipperyTag> SlipperyTagLookup;
        public NativeArray<Entity> SpecialObstacles;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public float InteractionRadius;
        public float MeltRate;
        public float BarrierPenetrationDistance;
        public void Execute(Entity playerEntity, int chunkIndexInQuery, TransformComponent playerTransform, PhysicsComponent physics);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/ObstacleCollisionSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce le collisioni tra il giocatore e gli ostacoli.
    /// Rileva collisioni, genera eventi appropriati e applica gli effetti delle collisioni.
    /// </summary>

    public partial struct ObstacleCollisionSystem : ISystem
    {
        private EntityQuery _playerQuery;
        private EntityQuery _obstacleQuery;
        private const float OBSTACLE_DAMAGE_MULTIPLIER;
        private const float MIN_IMPACT_VELOCITY;
        private const float SMALL_OBSTACLE_THRESHOLD;
        private const float PLAYER_RADIUS;
        public NativeArray<Entity> Obstacles;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float PlayerRadius;
        public float ObstacleDamageMultiplier;
        public float MinImpactVelocity;
        public float SmallObstacleThreshold;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity playerEntity, int entityInQueryIndex, HealthComponent health, TransformComponent transform, PhysicsComponent physics, MovementComponent movement);
         <summary>
            /// Verifica se c'è una collisione tra due entità basata su posizione e raggio
            /// </summary>

        private bool CheckCollision(float3 posA, float3 posB, float radiusA, float radiusB);
         <summary>
            /// Calcola la posizione di impatto tra due entità
            /// </summary>

        private float3 CalculateImpactPosition(float3 posA, float3 posB);
    }
    private partial struct ProcessCollisionsJob : IJobEntity
    {
        public NativeArray<Entity> Obstacles;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public NativeArray<TransformComponent> ObstacleTransforms;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float PlayerRadius;
        public float ObstacleDamageMultiplier;
        public float MinImpactVelocity;
        public float SmallObstacleThreshold;
        public ComponentLookup<UrbanDashAbilityComponent> UrbanDashLookup;
        public ComponentLookup<FireproofBodyAbilityComponent> FireproofBodyLookup;
        public ComponentLookup<ControlledGlitchAbilityComponent> ControlledGlitchLookup;
        public ComponentLookup<HeatAuraAbilityComponent> HeatAuraLookup;
        public ComponentLookup<AirBubbleAbilityComponent> AirBubbleLookup;
        public ComponentLookup<AlexComponent> AlexLookup;
        public ComponentLookup<EmberComponent> EmberLookup;
        public ComponentLookup<KaiComponent> KaiLookup;
        public ComponentLookup<MarinaComponent> MarinaLookup;
        public ComponentLookup<NeoComponent> NeoLookup;
        public ComponentLookup<LavaTag> LavaTagLookup;
        public ComponentLookup<IceObstacleTag> IceObstacleTagLookup;
        public ComponentLookup<DigitalBarrierTag> DigitalBarrierTagLookup;
        public ComponentLookup<UnderwaterTag> UnderwaterTagLookup;
        public void Execute(Entity playerEntity, int entityInQueryIndex, HealthComponent health, TransformComponent transform, PhysicsComponent physics, MovementComponent movement);
         <summary>
            /// Verifica se c'è una collisione tra due entità basata su posizione e raggio
            /// </summary>

        private bool CheckCollision(float3 posA, float3 posB, float radiusA, float radiusB);
         <summary>
            /// Calcola la posizione di impatto tra due entità
            /// </summary>

        private float3 CalculateImpactPosition(float3 posA, float3 posB);
    }
     <summary>
    /// Evento generato quando il giocatore sfonda un ostacolo
    /// </summary>

    public struct ObstacleBreakThroughEvent : IComponentData
    {
        public Entity PlayerEntity;
        public Entity ObstacleEntity;
        public float3 BreakThroughPosition;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/NavigationSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce la navigazione delle entità nel mondo di gioco,
    /// utilizzando il sistema di navigazione di Unity per calcolare percorsi
    /// evitando ostacoli e seguendo il mesh di navigazione.
    /// </summary>

    public partial struct NavigationSystem : ISystem
    {
        private EntityQuery _navigatorQuery;
         <summary>
        /// Inizializza il sistema di navigazione, configurando le query e altre risorse necessarie
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna la navigazione di tutte le entità ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Calcola un percorso utilizzando il NavMesh di Unity
        /// </summary>

        private static void CalculatePath(SystemState state, NavigatorComponent navigator, float3 startPosition);
    }
     <summary>
    /// Componente che rappresenta un'entità navigante
    /// </summary>

    public struct NavigatorComponent : IComponentData
    {
        public bool HasDestination;
        public float3 Destination;
        public float MovementSpeed;
        public float SteeringSpeed;
        public bool RotateTowardsTarget;
        public PathStatus PathStatus;
        public const int MaxPathPoints;
        public float3 PathPoint1;
        public float3 PathPoint2;
        public float3 PathPoint3;
        public float3 PathPoint4;
        public float3 PathPoint5;
        public float3 PathPoint6;
        public float3 PathPoint7;
        public float3 PathPoint8;
        public float3 PathPoint9;
        public float3 PathPoint10;
        public float3 PathPoint11;
        public float3 PathPoint12;
        public float3 PathPoint13;
        public float3 PathPoint14;
        public float3 PathPoint15;
        public float3 PathPoint16;
        public float3 PathPoint17;
        public float3 PathPoint18;
        public float3 PathPoint19;
        public float3 PathPoint20;
        public int PathPointCount;
        public int CurrentPathIndex;
        public float WaypointReachedThreshold;
         <summary>
        /// Ottiene il punto del percorso all'indice specificato
        /// </summary>

        public float3 GetPathPoint(int index);
         <summary>
        /// Imposta il punto del percorso all'indice specificato
        /// </summary>

        public void SetPathPoint(int index, float3 point);
    }
     <summary>
    /// Stato del calcolo del percorso
    /// </summary>

    public enum PathStatus
    {
        None = 0,
        Calculating = 1,
        Ready = 2,
        Failed = 3
    }
     <summary>
    /// Evento generato quando un'entità raggiunge la sua destinazione
    /// </summary>

    public struct DestinationReachedEvent : IComponentData
    {
        public Entity NavigatorEntity;
        public float3 FinalDestination;
        public float3 ActualPosition;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/ObstacleAvoidanceSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che implementa comportamenti di steering per evitare ostacoli.
    /// Rileva potenziali collisioni con ostacoli nel percorso delle entità mobili
    /// e modifica il loro movimento per evitarli in modo realistico.
    /// </summary>

    public partial struct ObstacleAvoidanceSystem : ISystem
    {
        private EntityQuery _avoidersQuery;
        private EntityQuery _obstaclesQuery;
         <summary>
        /// Inizializza il sistema di obstacle avoidance
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il comportamento di evitamento ostacoli per tutte le entità
        /// </summary>

        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job che implementa il comportamento di obstacle avoidance
    /// </summary>

    public partial struct ObstacleAvoidanceJob : IJobEntity
    {
        public float DeltaTime;
        public NativeArray<Entity> Obstacles;
        public NativeArray<TransformComponent> ObstaclePositions;
        public NativeArray<ObstacleComponent> ObstacleComponents;
        public void Execute(Entity entity, PhysicsComponent physics, TransformComponent transform, ObstacleAvoiderComponent avoider);
    }
     <summary>
    /// Componente che definisce il comportamento di obstacle avoidance
    /// </summary>

    public struct ObstacleAvoiderComponent : IComponentData
    {
        public float DetectionRadius;
        public float AvoidanceRadius;
        public float AvoidanceStrength;
        public float MaxSteeringForce;
        public float MoveSpeed;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/DamageType.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Tipi di danno che possono essere applicati
    /// </summary>

    public enum DamageType
    {
        Obstacle = 0,
        Fall = 1,
        Enemy = 2,
        Hazard = 3,
        StatusEffect = 4
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/PlayerMovementSystem.cs

namespace RunawayHeroes.ECS.Systems.Movement
{
     <summary>
    /// Sistema che gestisce il movimento del giocatore in base all'input ricevuto.
    /// Elabora la corsa automatica, i movimenti laterali, e coordina con altri sistemi
    /// come salto e scivolata.
    /// </summary>

    public partial struct PlayerMovementSystem : ISystem
    {
        private const float LANE_WIDTH;
        private const float MAX_LANE_OFFSET;
        private const float GROUND_LEVEL;
        private const float GRAVITY_MULTIPLIER;
        private const float GROUND_CHECK_DISTANCE;
        private EntityQuery _playerQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float LaneWidth;
        public float MaxLaneOffset;
        public float GroundLevel;
        public float GravityMultiplier;
        public float GroundCheckDistance;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
        public void Execute(Entity entity, int entityInQueryIndex, TransformComponent transform, PhysicsComponent physics, MovementComponent movement, InputComponent input);
    }
    private partial struct PlayerMovementJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float LaneWidth;
        public float MaxLaneOffset;
        public float GroundLevel;
        public float GravityMultiplier;
        public float GroundCheckDistance;
        public void Execute(Entity entity, int entityInQueryIndex, TransformComponent transform, PhysicsComponent physics, MovementComponent movement, InputComponent input);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/PatrolSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// Sistema che gestisce il movimento di pattugliamento dei nemici.
    /// Si occupa di far muovere i nemici lungo percorsi predefiniti o generati
    /// dinamicamente, gestendo le tempistiche di attesa e le transizioni tra waypoint.
    /// </summary>

    public partial struct PatrolSystem : ISystem
    {
        private EntityQuery _patrolQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema di pattugliamento
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il movimento di pattugliamento di tutti i nemici
        /// </summary>

        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int sortKey, PatrolComponent patrol, TransformComponent transform, PhysicsComponent physics);
    }
     <summary>
        /// Job che gestisce il movimento di pattugliamento
        /// </summary>

    private partial struct PatrolMovementJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, PatrolComponent patrol, TransformComponent transform, PhysicsComponent physics);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/AttackPatternSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// Sistema che gestisce i pattern di attacco dei nemici.
    /// Implementa logiche di attacco complesse in base ai tipi di pattern
    /// definiti, coordina le fasi di attacco e genera gli eventi di danno.
    /// </summary>

    public partial struct AttackPatternSystem : ISystem
    {
        private EntityQuery _attackingQuery;
        private EntityQuery _targetQuery;
        private ComponentLookup<AttackingStateComponent> _attackingStateLookup;
        public float DeltaTime;
        public float DeltaTime;
        public NativeArray<float3> TargetPositions;
        public ComponentLookup<AttackingStateComponent> AttackingStates;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema di pattern di attacco
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna i pattern di attacco per tutti i nemici in stato di attacco
        /// </summary>

        public void OnUpdate(SystemState state);
        private void ProcessEnemyAttackEvents(SystemState state, EntityCommandBuffer ecb);
         void Execute(AttackComponent attackComponent);
         void Execute(Entity entity, int sortKey, AttackComponent attackComponent, TransformComponent transform, PhysicsComponent physics);
         <summary>
            /// Ottiene la durata di un pattern di attacco in base al tipo
            /// </summary>

        private float GetPatternDuration(AttackPatternType patternType);
         <summary>
            /// Applica il comportamento specifico per il pattern di attacco
            /// </summary>

        private void ApplyAttackPatternBehavior(Entity entity, int sortKey, AttackComponent attackComponent, TransformComponent transform, PhysicsComponent physics, AttackingStateComponent attackState);
    }
     <summary>
        /// Job che aggiorna i timer di cooldown degli attacchi
        /// </summary>

    private partial struct UpdateAttackCooldownsJob : IJobEntity
    {
        public float DeltaTime;
         void Execute(AttackComponent attackComponent);
    }
     <summary>
        /// Job che elabora gli attacchi attivamente in esecuzione
        /// </summary>

    private partial struct ProcessActiveAttacksJob : IJobEntity
    {
        public float DeltaTime;
        public NativeArray<float3> TargetPositions;
        public ComponentLookup<AttackingStateComponent> AttackingStates;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, AttackComponent attackComponent, TransformComponent transform, PhysicsComponent physics);
         <summary>
            /// Ottiene la durata di un pattern di attacco in base al tipo
            /// </summary>

        private float GetPatternDuration(AttackPatternType patternType);
         <summary>
            /// Applica il comportamento specifico per il pattern di attacco
            /// </summary>

        private void ApplyAttackPatternBehavior(Entity entity, int sortKey, AttackComponent attackComponent, TransformComponent transform, PhysicsComponent physics, AttackingStateComponent attackState);
    }
     <summary>
    /// Componente che rappresenta lo stato di un attacco in esecuzione
    /// </summary>

    public struct AttackingStateComponent : IComponentData
    {
        public float3 TargetPosition;
        public byte AttackType;
        public float StartTime;
        public AttackPhase Phase;
        public float Progress;
    }
     <summary>
    /// Fasi di un attacco
    /// </summary>

    public enum AttackPhase
    {
        Startup = 0,
        Active = 1,
        Recovery = 2
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/EnemyAISystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// Sistema principale che coordina l'intelligenza artificiale dei nemici.
    /// Gestisce il processo decisionale degli agenti nemici, la selezione degli
    /// stati di comportamento, e le transizioni tra gli stati.
    /// </summary>

    public partial struct EnemyAISystem : ISystem
    {
        private EntityQuery _aiAgentsQuery;
        private EntityQuery _playerQuery;
         <summary>
        /// Inizializza il sistema di IA nemica
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna l'IA di tutti i nemici ad ogni frame
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Aggiorna i timer dell'IA
        /// </summary>

        private void UpdateAITimers(EnemyAIComponent ai, float deltaTime);
         <summary>
        /// Determina il prossimo stato dell'IA in base a vari fattori
        /// </summary>

        private AIState DetermineNextState(EnemyAIComponent ai, float distanceToPlayer, float3 position, float3 playerPosition);
         <summary>
        /// Gestisce l'uscita da uno stato
        /// </summary>

        private void ExitState(Entity entity, AIState state, SystemState systemState, EntityCommandBuffer ecb);
         <summary>
        /// Gestisce l'entrata in un nuovo stato
        /// </summary>

        private void EnterState(Entity entity, AIState state, SystemState systemState, EntityCommandBuffer ecb, float3 targetPosition);
         <summary>
        /// Aggiorna il comportamento in base allo stato corrente
        /// </summary>

        private void UpdateState(Entity entity, EnemyAIComponent ai, float3 position, PhysicsComponent physics, float3 targetPosition, float distanceToTarget, float deltaTime, SystemState systemState, EntityCommandBuffer ecb);
    }
     <summary>
    /// Stati possibili dell'IA nemica
    /// </summary>

    public enum AIState
    {
        Idle = 0,
        Patrolling = 1,
        Pursuing = 2,
        Attacking = 3,
        Fleeing = 4,
        Stunned = 5
    }
     <summary>
    /// Componente che contiene i dati di IA per un nemico
    /// </summary>

    public struct EnemyAIComponent : IComponentData
    {
        public AIState CurrentState;
        public float StateEnterTime;
        public float DetectionRange;
        public float AttackRange;
        public float MovementSpeed;
        public bool CanPatrol;
        public bool CanFlee;
        public float AbilityCooldown;
        public int AttackPattern;
        public float Health;
        public float FleeHealthThreshold;
        public float WaitTimer;
        public float LoseTargetTimer;
        public float StunTime;
    }
     <summary>
    /// Evento generato quando un nemico esce da uno stato AI
    /// </summary>

    public struct AIStateExitEvent : IComponentData
    {
        public Entity EntityID;
        public AIState PreviousState;
    }
     <summary>
    /// Evento generato quando un nemico entra in un nuovo stato AI
    /// </summary>

    public struct AIStateEnterEvent : IComponentData
    {
        public Entity EntityID;
        public AIState NewState;
        public float3 TargetPosition;
    }
     <summary>
    /// Evento generato quando un nemico esegue un attacco
    /// </summary>

    public struct EnemyAttackEvent : IComponentData
    {
        public Entity AttackerEntity;
        public float3 TargetPosition;
        public byte AttackType;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/BossPhasesSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// Sistema che gestisce le fasi dei boss e mid-boss.
    /// Coordina i cambiamenti di fase basati sulla salute,
    /// gestisce gli stati di rabbia/enrage, e attiva comportamenti
    /// specifici per ogni fase del combattimento.
    /// </summary>

    public partial struct BossPhasesSystem : ISystem
    {
        private EntityQuery _bossQuery;
        private EntityQuery _midBossQuery;
        private EntityQuery _playerQuery;
        public float DeltaTime;
        public NativeArray<float3> PlayerPositions;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float DeltaTime;
        public NativeArray<float3> PlayerPositions;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema di fasi dei boss
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna le fasi e stati dei boss
        /// </summary>

        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int sortKey, BossComponent boss, HealthComponent health, TransformComponent transform);
         void Execute(Entity entity, int sortKey, MidBossComponent midBoss, HealthComponent health, TransformComponent transform);
    }
     <summary>
        /// Job che gestisce i cambiamenti di fase dei boss
        /// </summary>

    private partial struct BossPhaseManagementJob : IJobEntity
    {
        public float DeltaTime;
        public NativeArray<float3> PlayerPositions;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, BossComponent boss, HealthComponent health, TransformComponent transform);
    }
     <summary>
        /// Job che gestisce gli stati dei mid-boss
        /// </summary>

    private partial struct MidBossStateManagementJob : IJobEntity
    {
        public float DeltaTime;
        public NativeArray<float3> PlayerPositions;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, MidBossComponent midBoss, HealthComponent health, TransformComponent transform);
    }
     <summary>
    /// Evento generato quando un boss viene attivato
    /// </summary>

    public struct BossActivationEvent : IComponentData
    {
        public Entity BossEntity;
        public byte BossType;
        public float3 Position;
    }
     <summary>
    /// Evento generato quando un boss inizia la transizione di fase
    /// </summary>

    public struct BossPhaseTransitionStartEvent : IComponentData
    {
        public Entity BossEntity;
        public int PhaseIndex;
    }
     <summary>
    /// Evento generato quando un boss completa la transizione di fase
    /// </summary>

    public struct BossPhaseTransitionEndEvent : IComponentData
    {
        public Entity BossEntity;
        public int PhaseIndex;
    }
     <summary>
    /// Evento generato quando un attacco speciale del boss è pronto
    /// </summary>

    public struct BossSpecialAttackReadyEvent : IComponentData
    {
        public Entity BossEntity;
        public byte BossType;
        public int PhaseIndex;
    }
     <summary>
    /// Evento generato quando un mid-boss viene attivato
    /// </summary>

    public struct MidBossActivationEvent : IComponentData
    {
        public Entity MidBossEntity;
        public byte MidBossType;
        public float3 Position;
    }
     <summary>
    /// Evento generato quando un mid-boss entra nello stato infuriato
    /// </summary>

    public struct MidBossEnrageEvent : IComponentData
    {
        public Entity MidBossEntity;
        public byte MidBossType;
    }
     <summary>
    /// Evento generato quando un'abilità speciale del mid-boss è pronta
    /// </summary>

    public struct MidBossSpecialAbilityReadyEvent : IComponentData
    {
        public Entity MidBossEntity;
        public byte MidBossType;
        public byte AbilityType;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/AI/PursuitSystem.cs

namespace RunawayHeroes.ECS.Systems.AI
{
     <summary>
    /// Sistema che gestisce l'inseguimento di bersagli da parte dei nemici.
    /// Implementa il comportamento di inseguimento degli agenti nemici,
    /// calcolando percorsi, evitando ostacoli e adattando le velocità.
    /// </summary>

    public partial struct PursuitSystem : ISystem
    {
        private EntityQuery _pursuitQuery;
        private EntityQuery _targetQuery;
        public float DeltaTime;
        public NativeArray<float3> TargetPositions;
        public EntityCommandBuffer.ParallelWriter ECB;
         <summary>
        /// Inizializza il sistema di inseguimento
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il comportamento di inseguimento di tutti i nemici
        /// </summary>

        public void OnUpdate(SystemState state);
         void Execute(Entity entity, int sortKey, TransformComponent transform, PhysicsComponent physics, EnemyAIComponent ai);
         <summary>
            /// Trova la posizione del target più vicino
            /// </summary>

        private float3 FindNearestTarget(float3 currentPosition);
    }
     <summary>
        /// Job che gestisce il comportamento di inseguimento
        /// </summary>

    private partial struct PursuitJob : IJobEntity
    {
        public float DeltaTime;
        public NativeArray<float3> TargetPositions;
        public EntityCommandBuffer.ParallelWriter ECB;
         void Execute(Entity entity, int sortKey, TransformComponent transform, PhysicsComponent physics, EnemyAIComponent ai);
         <summary>
            /// Trova la posizione del target più vicino
            /// </summary>

        private float3 FindNearestTarget(float3 currentPosition);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/TutorialProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema specializzato che gestisce la progressione del giocatore attraverso i tutorial.
    /// Si occupa dell'apprendimento delle meccaniche di base e dello sblocco sequenziale dei tutorial.
    /// </summary>

    public partial struct TutorialProgressionSystem : ISystem
    {
        private EntityQuery _tutorialLevelQuery;
        private EntityQuery _tutorialProgressQuery;
        private EntityQuery _playerQuery;
        private EntityQuery _playerProgressionQuery;
        private bool _initializationComplete;
        private RunawayHeroes.Runtime.Levels.TutorialLevelInitializer _tutorialManager;
        private int _totalAvailableTutorials;
        private const float TUTORIAL_COMPLETION_THRESHOLD;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnStartRunning(SystemState state);
         <summary>
        /// Aggiorna il sistema di progressione tutorial
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Verifica se il giocatore ha completato un tutorial percorrendo la distanza necessaria
        /// </summary>

        private void CheckTutorialCompletionByDistance(SystemState state);
         <summary>
        /// Inizializza i dati di progressione se non esistono già
        /// </summary>

        private void InitializeProgressionData(SystemState state);
         <summary>
        /// Ottiene o crea l'entità di progressione tutorial
        /// </summary>

        private Entity GetOrCreateTutorialProgressionEntity(SystemState state);
         <summary>
        /// Crea un messaggio UI per il completamento tutorial
        /// </summary>

        private void CreateTutorialCompletionMessage(EntityCommandBuffer commandBuffer, bool allCompleted);
         <summary>
        /// Genera un evento di avanzamento progressione
        /// </summary>

        private void GenerateProgressionAdvancementEvent(EntityCommandBuffer commandBuffer, byte progressionType, int primaryIndex, int secondaryIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/FocusTimeItemDetectionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che rileva oggetti collezionabili nel raggio del giocatore durante il Focus Time
    /// e li segnala come disponibili per l'aggiunta agli slot.
    /// </summary>

    public partial struct FocusTimeItemDetectionSystem : ISystem
    {
        private EntityQuery _playerQuery;
        private EntityQuery _collectibleQuery;
        private const float FOCUS_TIME_DETECTION_RADIUS;
        public void OnCreate(SystemState state);
        public void OnUpdate(SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/WorldProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema specializzato che gestisce la progressione del giocatore attraverso i vari mondi di gioco.
    /// Si occupa dello sblocco dei mondi, della raccolta dei frammenti e della progressione narrativa.
    /// </summary>

    public partial struct WorldProgressionSystem : ISystem
    {
        private EntityQuery _playerProgressionQuery;
        private EntityQuery _worldProgressionQuery;
        private EntityQuery _activeWorldQuery;
        private bool _initializationComplete;
        private Unity.Entities.World _world;
        private int[] _worldCharacterMapping;
        private string[] _worldNames;
        private const int TOTAL_WORLDS;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il sistema di progressione dei mondi
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Processa eventi di completamento tutorial per sbloccare il primo mondo
        /// </summary>

        private void ProcessTutorialCompletionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Processa eventi di completamento mondo
        /// </summary>

        private void ProcessWorldCompletionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Processa eventi di raccolta frammenti
        /// </summary>

        private void ProcessFragmentCollectionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Aggiorna lo stato globale di progressione
        /// </summary>

        private void UpdateGlobalProgressionState(SystemState state);
         <summary>
        /// Inizializza i dati di progressione dei mondi se non esistono già
        /// </summary>

        private void InitializeWorldProgressionData(SystemState state);
         <summary>
        /// Ottiene o crea un'entità di progressione per un mondo specifico
        /// </summary>

        private Entity GetOrCreateWorldProgressionEntity(int worldIndex, SystemState state);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un mondo
        /// </summary>

        private void CreateWorldUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex, SystemState state);
         <summary>
        /// Crea un messaggio UI per la raccolta di un frammento
        /// </summary>

        private void CreateFragmentCollectionMessage(EntityCommandBuffer commandBuffer, int fragmentIndex, SystemState state);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un personaggio
        /// </summary>

        private void CreateCharacterUnlockMessage(EntityCommandBuffer commandBuffer, int characterIndex, SystemState state);
         <summary>
        /// Ottiene il numero totale di stelle disponibili in un mondo
        /// </summary>

        private int GetTotalStarsForWorld(int worldIndex);
         <summary>
        /// Ottiene il nome di un frammento in base all'indice
        /// </summary>

        private string GetFragmentName(int fragmentIndex);
         <summary>
        /// Ottiene il nome di un personaggio in base all'indice
        /// </summary>

        private string GetCharacterName(int characterIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/LevelProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema specializzato che gestisce la progressione del giocatore all'interno dei singoli livelli.
    /// Si occupa del tracking delle stelle, collezionabili e obiettivi bonus.
    /// </summary>

    public partial struct LevelProgressionSystem : ISystem
    {
        private EntityQuery _playerProgressionQuery;
        private EntityQuery _worldProgressionQuery;
        private EntityQuery _levelProgressionQuery;
        private EntityQuery _activeLevelQuery;
        private bool _initializationComplete;
        private int _currentSessionScore;
        private int _currentSessionCollectibles;
        private int _currentSessionTreasures;
        private float _currentSessionStartTime;
        private bool _bonusObjectiveCompleted;
        private int _activeWorldIndex;
        private int _activeLevelIndex;
        private const float TIME_FOR_THREE_STARS;
        private const float TIME_FOR_TWO_STARS;
        private const float TIME_FOR_ONE_STAR;
        private const int COLLECTIBLES_PER_LEVEL;
        private const int TREASURES_PER_LEVEL;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Inizializza la sessione corrente
        /// </summary>

        public void OnStartRunning(SystemState state);
         <summary>
        /// Aggiorna il sistema di progressione dei livelli
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Reimposta i contatori per una nuova sessione di gioco
        /// </summary>

        private void ResetSessionCounters(SystemState state);
         <summary>
        /// Identifica il livello attualmente attivo
        /// </summary>

        private void IdentifyActiveLevel(SystemState state);
         <summary>
        /// Processa eventi di completamento livello
        /// </summary>

        private void ProcessLevelCompletionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Processa eventi di raccolta oggetti
        /// </summary>

        private void ProcessCollectionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Processa eventi di completamento obiettivi
        /// </summary>

        private void ProcessObjectiveCompletionEvents(EntityCommandBuffer commandBuffer, SystemState state);
         <summary>
        /// Calcola il numero di stelle guadagnate in base al tempo di completamento
        /// </summary>

        private byte CalculateStars(float completionTime, byte existingStars);
         <summary>
        /// Aggiorna la progressione del mondo per un livello completato
        /// </summary>

        private void UpdateWorldProgressionForLevel(int worldIndex, int levelIndex, byte starsEarned, bool bonusObjectiveCompleted, SystemState state);
         <summary>
        /// Aggiorna la progressione del mondo per un obiettivo bonus completato
        /// </summary>

        private void UpdateWorldProgressionForBonusObjective(int worldIndex, SystemState state);
         <summary>
        /// Sblocca il livello successivo se esiste
        /// </summary>

        private void UnlockNextLevel(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex, SystemState state);
         <summary>
        /// Aggiorna il progresso globale basato sui livelli e mondi
        /// </summary>

        private void UpdateGlobalProgress(SystemState state);
         <summary>
        /// Inizializza i dati di progressione
        /// </summary>

        private void InitializeLevelProgressionData(SystemState state);
         <summary>
        /// Ottiene o crea un'entità di progressione livello
        /// </summary>

        private Entity GetOrCreateLevelProgressionEntity(int worldIndex, int levelIndex, SystemState state);
         <summary>
        /// Crea un messaggio UI per il completamento di un livello
        /// </summary>

        private void CreateLevelCompletionMessage(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex, byte starsEarned, bool isNewBest);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un livello
        /// </summary>

        private void CreateLevelUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex);
         <summary>
        /// Verifica se un mondo è stato completato al 100%
        /// </summary>

        private bool IsWorldFullyCompleted(WorldProgressionComponent worldProgress);
         <summary>
        /// Ottiene il numero massimo di livelli per un mondo
        /// </summary>

        private int GetMaxLevelsForWorld(int worldIndex);
         <summary>
        /// Ottiene il nome di un mondo in base all'indice
        /// </summary>

        private string GetWorldName(int worldIndex);
         <summary>
        /// Ottiene le stelle già assegnate a un livello
        /// </summary>

        private int GetStarsForLevel(int worldIndex, int levelIndex, SystemState state);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/ScoreSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce il conteggio del punteggio, i moltiplicatori di punteggio,
    /// le combo e il tracciamento dei punteggi più alti.
    /// </summary>

    public partial struct ScoreSystem : ISystem
    {
        private EntityQuery _scoreEntitiesQuery;
        private EntityQuery _scoreUpdateEventsQuery;
        private EntityQuery _levelCompletionEventsQuery;
        private NativeParallelHashMap<Entity, ComboState> _playerCombos;
        public NativeParallelHashMap<Entity, ComboState>.ParallelWriter PlayerCombos;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<ScoreComponent> ScoreLookup;
        public double ElapsedTime;
         <summary>
        /// Inizializza il sistema e le sue strutture dati
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse allocate
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il punteggio e le statistiche correlate
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(Entity entity, int sortKey, ScoreUpdatedEvent scoreEvent);
        private void Execute(Entity entity, int sortKey, LevelCompletedEvent completionEvent);
    }
     <summary>
        /// Job che elabora gli aggiornamenti di punteggio
        /// </summary>

    private partial struct ProcessScoreUpdatesJob : IJobEntity
    {
        public NativeParallelHashMap<Entity, ComboState>.ParallelWriter PlayerCombos;
        public EntityCommandBuffer.ParallelWriter ECB;
        public EntityStorageInfoLookup EntityLookup;
        private void Execute(Entity entity, int sortKey, ScoreUpdatedEvent scoreEvent);
    }
     <summary>
        /// Job che elabora gli eventi di completamento livello
        /// </summary>

    private partial struct ProcessLevelCompletionJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<ScoreComponent> ScoreLookup;
        public double ElapsedTime;
        private void Execute(Entity entity, int sortKey, LevelCompletedEvent completionEvent);
    }
     <summary>
    /// Componente per il punteggio di un'entità
    /// </summary>

    public struct ScoreComponent : IComponentData
    {
        public float CurrentScore;
        public float HighScore;
        public float PreviousHighScore;
        public double HighScoreDate;
        public int TotalCollectibles;
        public int TotalEnemiesDefeated;
        public float TimeBonus;
        public float ScoreMultiplier;
    }
     <summary>
    /// Stato di una combo mantenuto nel sistema
    /// </summary>

    public struct ComboState
    {
        public int CurrentCombo;
        public float ComboMultiplier;
        public float ComboTimeRemaining;
        public float ScoreFromCurrentCombo;
    }
     <summary>
    /// Evento per aggiornamenti UI del punteggio
    /// </summary>

    public struct ScoreUIUpdateEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float NewScore;
        public float ScoreIncrement;
        public byte ScoreSource;
    }
     <summary>
    /// Evento quando una combo raggiunge una milestone
    /// </summary>

    public struct ComboMilestoneEvent : IComponentData
    {
        public Entity PlayerEntity;
        public int ComboCount;
        public float ComboMultiplier;
    }
     <summary>
    /// Evento quando una combo termina
    /// </summary>

    public struct ComboEndedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public int FinalComboCount;
        public float FinalMultiplier;
        public float TotalScoreFromCombo;
    }
     <summary>
    /// Evento per il punteggio finale del livello
    /// </summary>

    public struct FinalScoreUIEvent : IComponentData
    {
        public Entity PlayerEntity;
        public int LevelID;
        public float FinalScore;
        public bool IsHighScore;
        public int TotalCollectibles;
        public int TotalEnemiesDefeated;
        public float TimeBonus;
    }
     <summary>
    /// Evento quando si ottiene un nuovo punteggio più alto
    /// </summary>

    public struct HighScoreAchievedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public int LevelID;
        public float NewHighScore;
        public float PreviousHighScore;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/ProgressionEventSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema centralizzato che gestisce gli eventi di progressione per la comunicazione tra sistemi.
    /// Si occupa di propagare eventi tra i diversi livelli di progressione (tutorial, mondo, livello).
    /// </summary>

    public partial struct ProgressionEventSystem : ISystem
    {
        private EntityQuery _playerProgressionQuery;
        private EntityQuery _progressionEventsQuery;
        private EntityQuery _unlockEventsQuery;
        private AudioManager _audioManager;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Cerca e ottiene riferimenti
        /// </summary>

        public void OnStartRunning(SystemState state);
        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il sistema di eventi progressione
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Processa eventi di avanzamento progressione
        /// </summary>

        private void ProcessProgressionAdvancementEvents(SystemState state, EntityCommandBuffer commandBuffer);
         <summary>
        /// Processa eventi di sblocco
        /// </summary>

        private void ProcessUnlockEvents(SystemState state, EntityCommandBuffer commandBuffer);
         <summary>
        /// Notifica avanzamento tutorial al sistema mondo
        /// </summary>

        private void NotifyWorldOfTutorialAdvancement(EntityCommandBuffer commandBuffer, int tutorialIndex);
         <summary>
        /// Notifica avanzamento mondo ai livelli
        /// </summary>

        private void NotifyLevelsOfWorldAdvancement(EntityCommandBuffer commandBuffer, int worldIndex);
         <summary>
        /// Notifica avanzamento livello al sistema mondo
        /// </summary>

        private void NotifyWorldOfLevelAdvancement(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex);
         <summary>
        /// Aggiorna PlayerPrefs per un evento di avanzamento
        /// </summary>

        private void UpdatePlayerPrefs(ProgressionAdvancementEvent progressionEvent);
         <summary>
        /// Aggiorna PlayerPrefs per un evento di sblocco
        /// </summary>

        private void UpdatePlayerPrefsForUnlock(string prefix, int index);
         <summary>
        /// Riproduce audio appropriato per eventi di progressione
        /// </summary>

        private void PlayProgressionAudio(ProgressionAdvancementEvent progressionEvent);
         <summary>
        /// Riproduce audio appropriato per eventi di sblocco
        /// </summary>

        private void PlayUnlockAudio(string unlockType);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un mondo
        /// </summary>

        private void CreateWorldUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex);
         <summary>
        /// Crea un messaggio UI per lo sblocco di un livello
        /// </summary>

        private void CreateLevelUnlockMessage(EntityCommandBuffer commandBuffer, int worldIndex, int levelIndex);
         <summary>
        /// Ottiene il numero massimo di livelli per un mondo
        /// </summary>

        private int GetMaxLevelsForWorld(int worldIndex);
         <summary>
        /// Ottiene il nome di un mondo in base all'indice
        /// </summary>

        private string GetWorldName(int worldIndex);
         <summary>
        /// Ottiene l'indice personaggio da sbloccare per un mondo
        /// </summary>

        private int GetCharacterIndexForWorld(int worldIndex);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/ProgressionSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce la progressione del giocatore attraverso i tutorial e i livelli.
    /// Monitora il completamento degli obiettivi e trigger eventi di progressione.
    /// </summary>

    public partial struct ProgressionSystem : ISystem
    {
        private EntityQuery _tutorialLevelQuery;
        private EntityQuery _tutorialProgressQuery;
        private EntityQuery _playerQuery;
        private bool _initializationComplete;
         <summary>
        /// Inizializza il sistema
        /// </summary>

        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna il sistema di progressione
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Verifica il raggiungimento degli obiettivi tutorial
        /// </summary>

        private void CheckTutorialObjectives(SystemState state);
         <summary>
        /// Aggiorna i timer per gli scenari attivati
        /// </summary>

        private void UpdateScenarioTimers(SystemState state);
         <summary>
        /// Inizializza i dati di progressione se non esistono già
        /// </summary>

        private void InitializeProgressionData(SystemState state);
         <summary>
        /// Ottiene o crea l'entità di progressione
        /// </summary>

        private Entity GetOrCreateProgressionEntity(SystemState state);
         <summary>
        /// Crea un messaggio UI per il completamento
        /// </summary>

        private void CreateCompletionMessage(EntityCommandBuffer commandBuffer, bool allCompleted);
    }
     <summary>
    /// Sistema per la gestione degli obiettivi specifici
    /// </summary>

    public partial struct ObjectiveSystem : ISystem
    {
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
         <summary>
        /// Coroutine per avanzare al prossimo tutorial dopo un ritardo
        /// </summary>

        private System.Collections.IEnumerator DelayedTutorialAdvance(RunawayHeroes.Runtime.Levels.TutorialLevelInitializer tutorialManager, float delay);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/DifficultySystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce la difficoltà progressiva del gioco, sia all'interno di un livello
    /// che tra diversi mondi tematici. Si occupa di regolare parametri di difficoltà in base
    /// al progresso del giocatore e al tema del mondo corrente.
    /// </summary>

    public partial struct DifficultySystem : ISystem
    {
        private EntityQuery _worldConfigQuery;
        private EntityQuery _segmentsQuery;
        private EntityQuery _obstaclesQuery;
        private const float DEFAULT_DIFFICULTY_UPDATE_INTERVAL;
        private float _timeSinceLastUpdate;
        public WorldDifficultyConfigComponent DifficultyConfig;
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<HealthComponent> HealthLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<HealthComponent> HealthLookup;
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<PhysicsComponent> PhysicsLookup;
        public ComponentLookup<DamagedStateComponent> DamagedStateLookup;
        public ComponentLookup<TemporaryObstacleComponent> TemporaryLookup;
         <summary>
        /// Inizializza il sistema di gestione difficoltà
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna i parametri di difficoltà di segmenti, nemici e ostacoli
        /// </summary>

        public void OnUpdate(SystemState state);
         <summary>
        /// Crea una configurazione di difficoltà predefinita nel mondo
        /// </summary>

        private void CreateDefaultWorldDifficultyConfig(SystemState state);
        private void Execute(PathSegmentComponent segment, LocalTransform transform);
        private void Execute(Entity entity, int sortKey, EnemyComponent enemy, SegmentReferenceComponent segmentRef);
        private void Execute(Entity entity, int sortKey, MidBossComponent midBoss, SegmentReferenceComponent segmentRef);
        private void Execute(Entity entity, int sortKey, BossComponent boss, SegmentReferenceComponent segmentRef);
        private void Execute(Entity entity, int sortKey, ObstacleComponent obstacle, SegmentReferenceComponent segmentRef);
    }
     <summary>
        /// Job che applica la difficoltà ai segmenti di percorso
        /// </summary>

    private partial struct ApplyDifficultyToSegmentsJob : IJobEntity
    {
        public WorldDifficultyConfigComponent DifficultyConfig;
        private void Execute(PathSegmentComponent segment, LocalTransform transform);
    }
     <summary>
        /// Job che applica la difficoltà ai nemici normali
        /// </summary>

    private partial struct ApplyDifficultyToEnemiesJob : IJobEntity
    {
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<HealthComponent> HealthLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        private void Execute(Entity entity, int sortKey, EnemyComponent enemy, SegmentReferenceComponent segmentRef);
    }
     <summary>
        /// Job che applica la difficoltà ai mid-boss
        /// </summary>

    private partial struct ApplyDifficultyToMidBossesJob : IJobEntity
    {
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<HealthComponent> HealthLookup;
        private void Execute(Entity entity, int sortKey, MidBossComponent midBoss, SegmentReferenceComponent segmentRef);
    }
     <summary>
        /// Job che applica la difficoltà ai boss
        /// </summary>

    private partial struct ApplyDifficultyToBossesJob : IJobEntity
    {
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        private void Execute(Entity entity, int sortKey, BossComponent boss, SegmentReferenceComponent segmentRef);
    }
     <summary>
        /// Job che applica la difficoltà agli ostacoli
        /// </summary>

    private partial struct ApplyDifficultyToObstaclesJob : IJobEntity
    {
        public WorldDifficultyConfigComponent DifficultyConfig;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PathSegmentComponent> PathSegments;
        public ComponentLookup<PhysicsComponent> PhysicsLookup;
        public ComponentLookup<DamagedStateComponent> DamagedStateLookup;
        public ComponentLookup<TemporaryObstacleComponent> TemporaryLookup;
        private void Execute(Entity entity, int sortKey, ObstacleComponent obstacle, SegmentReferenceComponent segmentRef);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/PowerupSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce i powerup nel gioco, inclusa la loro attivazione,
    /// effetti temporanei, e durata nel tempo.
    /// </summary>

    public partial struct PowerupSystem : ISystem
    {
        private EntityQuery _powerupEntitiesQuery;
        private EntityQuery _activePowerupEffectsQuery;
        private EntityQuery _powerupCollisionsQuery;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PowerupComponent> PowerupLookup;
        public ComponentLookup<TransformComponent> TransformLookup;
        public ComponentLookup<MovementComponent> MovementLookup;
        public ComponentLookup<CombatComponent> CombatLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        public ComponentLookup<HealthComponent> HealthLookup;
        public EntityStorageInfoLookup EntityStorageInfoLookup;
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<MovementComponent> MovementLookup;
        public ComponentLookup<CombatComponent> CombatLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        public ComponentLookup<HealthComponent> HealthLookup;
         <summary>
        /// Inizializza il sistema e configura le query necessarie
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Gestisce gli aggiornamenti di powerup, controllando collisioni, 
        /// applicando effetti e aggiornando durate
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(TransformComponent transform, PowerupComponent powerup);
        private void Execute(Entity entity, int sortKey, PowerupCollectedEvent collectionEvent);
        private void ApplyPowerupEffects(Entity characterEntity, PowerupComponent powerup, EntityCommandBuffer.ParallelWriter ecb, int sortKey);
        private void Execute(Entity entity, int sortKey, ActivePowerupComponent activePowerup);
        private void RevertPowerupEffects(Entity characterEntity, ActivePowerupComponent activePowerup, EntityCommandBuffer.ParallelWriter ecb, int sortKey);
    }
     <summary>
        /// Job che aggiorna l'aspetto visivo dei powerup nel mondo
        /// </summary>

    private partial struct UpdateWorldPowerupsJob : IJobEntity
    {
        public float DeltaTime;
        private void Execute(TransformComponent transform, PowerupComponent powerup);
    }
     <summary>
        /// Job che processa le collisioni con powerup
        /// </summary>

    private partial struct ProcessPowerupCollectionsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<PowerupComponent> PowerupLookup;
        public ComponentLookup<TransformComponent> TransformLookup;
        public ComponentLookup<MovementComponent> MovementLookup;
        public ComponentLookup<CombatComponent> CombatLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        public ComponentLookup<HealthComponent> HealthLookup;
        public EntityStorageInfoLookup EntityStorageInfoLookup;
        private void Execute(Entity entity, int sortKey, PowerupCollectedEvent collectionEvent);
        private void ApplyPowerupEffects(Entity characterEntity, PowerupComponent powerup, EntityCommandBuffer.ParallelWriter ecb, int sortKey);
    }
     <summary>
        /// Job che aggiorna i powerup attivi e rimuove quelli scaduti
        /// </summary>

    private partial struct UpdateActivePowerupsJob : IJobEntity
    {
        public float DeltaTime;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<MovementComponent> MovementLookup;
        public ComponentLookup<CombatComponent> CombatLookup;
        public ComponentLookup<DefenseComponent> DefenseLookup;
        public ComponentLookup<HealthComponent> HealthLookup;
        private void Execute(Entity entity, int sortKey, ActivePowerupComponent activePowerup);
        private void RevertPowerupEffects(Entity characterEntity, ActivePowerupComponent activePowerup, EntityCommandBuffer.ParallelWriter ecb, int sortKey);
    }
     <summary>
    /// Tipi di powerup disponibili
    /// </summary>

    public enum PowerupType
    {
        SpeedBoost = 0,
        DamageBoost = 1,
        DefenseBoost = 2,
        Invulnerability = 3,
        HealthRestore = 4,
        ManaRestore = 5,
        ScoreMultiplier = 6,
        ExtraLife = 7
    }
     <summary>
    /// Componente che definisce un powerup
    /// </summary>

    public struct PowerupComponent : IComponentData
    {
        public PowerupType PowerupType;
        public float Duration;
        public float StrengthMultiplier;
        public float SpeedMultiplier;
        public float DefenseMultiplier;
        public byte SpecialEffect;
        public float RotationSpeed;
        public bool HasVerticalBob;
        public float BobAmplitude;
        public float BobFrequency;
        public float OriginalHeight;
        public bool HasPulsation;
        public float PulseAmplitude;
        public float PulseFrequency;
        public float3 OriginalScale;
        public float AnimationTime;
        public float PulsationTime;
    }
     <summary>
    /// Componente per powerup attivi su un'entità
    /// </summary>

    public struct ActivePowerupComponent : IComponentData
    {
        public PowerupType PowerupType;
        public float Duration;
        public float RemainingTime;
        public float OriginalSpeed;
        public float OriginalDamage;
        public float OriginalDefense;
        public float StrengthMultiplier;
        public float SpeedMultiplier;
        public float DefenseMultiplier;
        public byte SpecialEffect;
        public bool WarningTriggered;
    }
     <summary>
    /// Evento generato quando viene raccolto un powerup
    /// </summary>

    public struct PowerupCollectedEvent : IComponentData
    {
        public Entity PowerupEntity;
        public Entity CollectorEntity;
    }
     <summary>
    /// Evento per l'effetto visivo/audio di raccolta powerup
    /// </summary>

    public struct PowerupFeedbackEvent : IComponentData
    {
        public PowerupType PowerupType;
        public Entity CollectorEntity;
        public float3 CollectionPoint;
    }
     <summary>
    /// Evento generato quando un powerup sta per scadere
    /// </summary>

    public struct PowerupExpiringWarningEvent : IComponentData
    {
        public Entity CharacterEntity;
        public PowerupType PowerupType;
        public float RemainingTime;
    }
     <summary>
    /// Evento generato quando un powerup è scaduto
    /// </summary>

    public struct PowerupExpiredEvent : IComponentData
    {
        public Entity CharacterEntity;
        public PowerupType PowerupType;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/CollectibleSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce i collezionabili nel gioco, inclusa la generazione,
    /// raccolta, e il conteggio dei collezionabili per i vari tipi.
    /// </summary>

    public partial struct CollectibleSystem : ISystem
    {
        private EntityQuery _collectiblesQuery;
        private EntityQuery _magnetizedCollectiblesQuery;
        private EntityQuery _collectibleEventsQuery;
        private EntityQuery _magnetSourcesQuery;
        public float DeltaTime;
        public float DeltaTime;
        public NativeArray<Entity> MagnetSources;
        public NativeArray<TransformComponent> MagnetPositions;
        public NativeArray<MagnetSourceComponent> MagnetProperties;
        public EntityCommandBuffer.ParallelWriter ECB;
        public float DeltaTime;
        public ComponentLookup<TransformComponent> TransformLookup;
        public EntityStorageInfoLookup EntityLookupTable;
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<CollectibleComponent> CollectibleLookup;
        public ComponentLookup<TransformComponent> TransformLookup;
        public ComponentLookup<ScoreComponent> ScoreLookup;
        public ComponentLookup<HealthComponent> HealthLookup;
        public ComponentLookup<FragmentInventoryComponent> FragmentInventoryLookup;
        public ComponentLookup<KeyInventoryComponent> KeyInventoryLookup;
        public EntityStorageInfoLookup EntityLookupTable;
         <summary>
        /// Inizializza il sistema e configura le query necessarie
        /// </summary>

        public void OnCreate(SystemState state);
         <summary>
        /// Pulisce le risorse quando il sistema viene distrutto
        /// </summary>

        public void OnDestroy(SystemState state);
         <summary>
        /// Aggiorna i collezionabili, gestisce le raccolte e magnetizzazioni
        /// </summary>

        public void OnUpdate(SystemState state);
        private void Execute(TransformComponent transform, CollectibleComponent collectible);
        private void Execute(Entity entity, int sortKey, TransformComponent transform, CollectibleComponent collectible);
        private void Execute(TransformComponent transform, MagnetizationMovementData magnetData);
        private void Execute(Entity entity, int sortKey, CollectibleCollectedEvent collectionEvent);
        private void ApplyCollectibleEffects(Entity collectibleEntity, Entity collectorEntity, CollectibleComponent collectible, EntityCommandBuffer.ParallelWriter ecb, int sortKey);
    }
     <summary>
        /// Job che aggiorna l'animazione dei collezionabili
        /// </summary>

    private partial struct UpdateCollectiblesAnimationJob : IJobEntity
    {
        public float DeltaTime;
        private void Execute(TransformComponent transform, CollectibleComponent collectible);
    }
     <summary>
        /// Job che aggiorna i collezionabili in risposta agli attrattori magnetici
        /// </summary>

    private partial struct UpdateMagnetEffectsJob : IJobEntity
    {
        public float DeltaTime;
        public NativeArray<Entity> MagnetSources;
        public NativeArray<TransformComponent> MagnetPositions;
        public NativeArray<MagnetSourceComponent> MagnetProperties;
        public EntityCommandBuffer.ParallelWriter ECB;
        private void Execute(Entity entity, int sortKey, TransformComponent transform, CollectibleComponent collectible);
    }
     <summary>
        /// Job che muove i collezionabili magnetizzati verso i loro attrattori
        /// </summary>

    private partial struct MoveMagnetizedCollectiblesJob : IJobEntity
    {
        public float DeltaTime;
        public ComponentLookup<TransformComponent> TransformLookup;
        public EntityStorageInfoLookup EntityLookupTable;
        private void Execute(TransformComponent transform, MagnetizationMovementData magnetData);
    }
     <summary>
        /// Job che processa gli eventi di raccolta dei collezionabili
        /// </summary>

    private partial struct ProcessCollectionEventsJob : IJobEntity
    {
        public EntityCommandBuffer.ParallelWriter ECB;
        public ComponentLookup<CollectibleComponent> CollectibleLookup;
        public ComponentLookup<TransformComponent> TransformLookup;
        public ComponentLookup<ScoreComponent> ScoreLookup;
        public ComponentLookup<HealthComponent> HealthLookup;
        public ComponentLookup<FragmentInventoryComponent> FragmentInventoryLookup;
        public ComponentLookup<KeyInventoryComponent> KeyInventoryLookup;
        public EntityStorageInfoLookup EntityLookupTable;
        private void Execute(Entity entity, int sortKey, CollectibleCollectedEvent collectionEvent);
        private void ApplyCollectibleEffects(Entity collectibleEntity, Entity collectorEntity, CollectibleComponent collectible, EntityCommandBuffer.ParallelWriter ecb, int sortKey);
    }
     <summary>
    /// Tipi di collezionabili
    /// </summary>

    public enum CollectibleType
    {
        Coin = 0,
        Gem = 1,
        HealthPickup = 2,
        Fragment = 3,
        Key = 4,
        PowerupPickup = 5
    }
     <summary>
    /// Componente che definisce un collezionabile
    /// </summary>

    public struct CollectibleComponent : IComponentData
    {
        public CollectibleType CollectibleType;
        public int ItemID;
        public float Value;
        public byte Rarity;
        public byte FragmentType;
        public byte KeyType;
        public bool HasRotation;
        public float3 RotationAxis;
        public float RotationSpeed;
        public bool HasFloating;
        public float FloatAmplitude;
        public float FloatFrequency;
        public float OriginalHeight;
        public bool HasPulsation;
        public float PulseAmplitude;
        public float PulseFrequency;
        public float3 OriginalScale;
        public bool HasGlow;
        public float GlowFrequency;
        public float GlowIntensity;
        public bool IsMagnetizable;
        public bool HasCollision;
        public float AnimationTime;
        public bool IsPlaced;
    }
     <summary>
    /// Tag per collezionabili magnetizzati
    /// </summary>

    public struct MagnetizedTag : IComponentData
    {
    }
     <summary>
    /// Dati di movimento per collezionabili magnetizzati
    /// </summary>

    public struct MagnetizationMovementData : IComponentData
    {
        public Entity TargetEntity;
        public float3 TargetPosition;
        public float MoveSpeed;
        public float AccelerationRate;
    }
     <summary>
    /// Componente che definisce una sorgente magnetica
    /// </summary>

    public struct MagnetSourceComponent : IComponentData
    {
        public float Radius;
        public float PullSpeed;
        public float AccelerationRate;
        public bool IsActive;
        public float Duration;
        public float RemainingTime;
    }
     <summary>
    /// Evento generato quando viene raccolto un collezionabile
    /// </summary>

    public struct CollectibleCollectedEvent : IComponentData
    {
        public Entity CollectibleEntity;
        public Entity CollectorEntity;
    }
     <summary>
    /// Evento per effetti visivi/audio di raccolta collezionabile
    /// </summary>

    public struct CollectibleFeedbackEvent : IComponentData
    {
        public CollectibleType CollectibleType;
        public Entity CollectorEntity;
        public float3 CollectionPoint;
        public float Value;
    }
     <summary>
    /// Eventi specifici per tipo di collezionabile
    /// </summary>

    public struct ScoreUpdatedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float NewScore;
        public float ScoreIncrement;
        public byte ScoreSource;
    }
    public struct HealthUpdatedEvent : IComponentData
    {
        public Entity PlayerEntity;
        public float NewHealth;
        public float HealthIncrement;
        public bool IsFullHeal;
    }
    public struct KeyCollectedEvent : IComponentData
    {
        public int KeyID;
        public byte KeyType;
        public Entity CollectorEntity;
    }
     <summary>
    /// Componente per inventario frammenti
    /// </summary>

    public struct FragmentInventoryComponent : IComponentData
    {
        public byte UrbanFragments;
        public byte ForestFragments;
        public byte TundraFragments;
        public byte VolcanoFragments;
        public byte AbyssFragments;
        public byte VirtualFragments;
        public byte GetFragmentCount(byte fragmentType);
    }
     <summary>
    /// Componente per inventario chiavi
    /// </summary>

    public struct KeyInventoryComponent : IComponentData
    {
        public byte CommonKeys;
        public byte RareKeys;
        public byte EpicKeys;
        public byte LegendaryKeys;
        public byte GetKeyCount(byte keyType);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/TutorialGuidanceSystem.cs

namespace RunawayHeroes.ECS.Systems.Gameplay
{
     <summary>
    /// Sistema che gestisce l'avanzamento del tutorial e la generazione degli scenari didattici
    /// </summary>

    public partial struct TutorialGuidanceSystem : ISystem
    {
        private EntityQuery _activePlayerQuery;
        private EntityQuery _scenarioQuery;
        private const float LANE_WIDTH;
        private const float LEFT_POSITION;
        private const float CENTER_POSITION;
        private const float RIGHT_POSITION;
        private uint _seed;
        public void OnCreate(SystemState state);
        public void OnDestroy(SystemState state);
        public void OnUpdate(SystemState state);
    }
     <summary>
    /// Job per controllare e attivare scenari tutorial
    /// </summary>

    public partial struct CheckScenarioTriggerJob : IJobEntity
    {
        public float3 PlayerPosition;
        public EntityCommandBuffer.ParallelWriter ECB;
        public uint Seed;
        public float LaneWidth;
        public float LeftPosition;
        public float CenterPosition;
        public float RightPosition;
        public void Execute(Entity entity, int entityInQueryIndex, TutorialScenarioComponent scenario, DynamicBuffer<TutorialObstacleBuffer> obstacleBuffer);
         <summary>
        /// Genera gli ostacoli per uno scenario di tutorial
        /// </summary>

        private void SpawnObstaclesForScenario(int entityInQueryIndex, TutorialScenarioComponent scenario, DynamicBuffer<TutorialObstacleBuffer> obstacleBuffer);
         <summary>
        /// Genera ostacoli per un tutorial con impostazioni avanzate
        /// </summary>

        private void SpawnTutorialObstaclesAdvanced(int entityInQueryIndex, float startZ, float spacing, bool randomPlacement, TutorialObstacleBuffer obstacleSetup);
         <summary>
        /// Crea un'entità ostacolo utilizzando il factory
        /// </summary>

        private Entity SpawnObstacle(int entityInQueryIndex, string obstacleCode, float3 position, float height, float scale);
    }
     <summary>
    /// Componente che identifica uno scenario tutorial
    /// </summary>

    public struct TutorialScenarioComponent : IComponentData
    {
        public FixedString64Bytes Name;
        public float DistanceFromStart;
        public FixedString128Bytes InstructionMessage;
        public float MessageDuration;
        public bool RandomPlacement;
        public float ObstacleSpacing;
        public float StartOffset;
    }
     <summary>
    /// Tag per gli scenari tutorial già attivati
    /// </summary>

    public struct TriggeredTag : IComponentData
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/ColosalYeti.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class ColosalYeti
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/CorruptedAI.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class CorruptedAI
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Ember.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Ember
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/SpiritGuardian.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class SpiritGuardian
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/MutantKraken.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class MutantKraken
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/MagmaElemental.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class MagmaElemental
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Marina.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Marina
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Kai.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Kai
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/CyborgSecurity.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class CyborgSecurity
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Maya.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Maya
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Alex.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Alex
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Blueprints/Neo.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class Neo
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/PlayerArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class PlayerArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/ObstacleArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class ObstacleArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/CollectibleArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class CollectibleArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Archetypes/EnemyArchetypes.cs

namespace RunawayHeroes.ECS.Entities
{
     <summary>
    /// 
    /// </summary>

    public static class EnemyArchetypes
    {
        public static Entity Create(EntityManager entityManager);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/CollectibleFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class CollectibleFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/FXFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class FXFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/PlayerFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// Factory che crea entità per i personaggi giocabili.
    /// Implementa metodi per creare i 6 protagonisti con configurazioni appropriate.
    /// </summary>

    public static class PlayerFactory
    {
         <summary>
        /// Crea un'entità giocatore con componenti base
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale del giocatore</param>
        /// <returns>Entità player creata</returns>

        public static Entity CreatePlayer(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Alex, il corriere urbano
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Alex creata</returns>

        public static Entity CreateAlex(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Maya, l'esploratrice della foresta
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Maya creata</returns>

        public static Entity CreateMaya(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Kai, l'alpinista della tundra
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Kai creata</returns>

        public static Entity CreateKai(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Ember, la sopravvissuta del vulcano
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Ember creata</returns>

        public static Entity CreateEmber(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Marina, la biologa degli abissi
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Marina creata</returns>

        public static Entity CreateMarina(EntityManager entityManager, float3 position);
         <summary>
        /// Crea un'entità per Neo, l'hacker della realtà virtuale
        /// </summary>
        /// <param name="entityManager">EntityManager per creare l'entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Entità Neo creata</returns>

        public static Entity CreateNeo(EntityManager entityManager, float3 position);
         <summary>
        /// Crea tutti i personaggi per testing
        /// </summary>
        /// <param name="entityManager">EntityManager per creare le entità</param>
        /// <param name="position">Posizione iniziale</param>
        /// <returns>Array delle entità create</returns>

        public static Entity[] CreateAllCharacters(EntityManager entityManager, float3 position);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/WorldEntityFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class WorldEntityFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/EnemyFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class EnemyFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Entities/Factory/BossFactory.cs

namespace RunawayHeroes.ECS.Entities.Factory
{
     <summary>
    /// 
    /// </summary>

    public static class BossFactory
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/TundraObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli della tundra specifici del tema Tundra
    /// </summary>

     <summary>
    /// Tag di ostacolo della tundra per raggruppamento
    /// </summary>

    public struct TundraObstacleTag : IComponentData
    {
    }
     <summary>
    /// T01: Muro di ghiaccio - Richiede salto o scivolata
    /// </summary>

    public struct T01_IceWall : IComponentData
    {
        public float Thickness;
        public float Integrity;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T02: Blocco di ghiaccio - Richiede salto
    /// </summary>

    public struct T02_IceBlock : IComponentData
    {
        public bool IsBreakable;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T03: Superficie ghiacciata - Causa scivolamento
    /// </summary>

    public struct T03_IcySurface : IComponentData
    {
        public float SlipperinessFactor;
        public float Length;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T04: Stalattiti di ghiaccio - Cadono quando ci si avvicina
    /// </summary>

    public struct T04_IceStalactite : IComponentData
    {
        public float FallDelay;
        public float TriggerDistance;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T05: Geyser gelato - Erutta periodicamente causando danno da gelo
    /// </summary>

    public struct T05_FrostGeyser : IComponentData
    {
        public float EruptionInterval;
        public float EruptionDuration;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T06: Valanga - Richiede reazione rapida
    /// </summary>

    public struct T06_Avalanche : IComponentData
    {
        public float Speed;
        public float Width;
        public float WarningTime;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T07: Ponte di ghiaccio - Si rompe dopo un po'
    /// </summary>

    public struct T07_IceBridge : IComponentData
    {
        public float BreakTime;
        public float Integrity;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// T08: Vento gelido - Spinge il giocatore e causa danno da freddo
    /// </summary>

    public struct T08_FreezingWind : IComponentData
    {
        public float Force;
        public float Direction;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/ObstacleTags.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Componente tag per identificare un'entità come ostacolo
    /// </summary>

    public struct ObstacleTag : IComponentData
    {
    }
     <summary>
    /// Tag per identificare le superfici di lava, utilizzato per l'abilità Corpo Ignifugo di Ember
    /// </summary>

    public struct LavaTag : IComponentData
    {
        public float DamagePerSecond;
    }
     <summary>
    /// Tag per identificare le zone di ghiaccio, utilizzato per l'abilità Aura di Calore di Kai
    /// </summary>

    public struct IceObstacleTag : IComponentData
    {
        public float SlipperyFactor;
    }
     <summary>
    /// Componente per tracciare l'integrità di un ostacolo di ghiaccio, utilizzato per l'effetto di scioglimento
    /// </summary>

    public struct IceIntegrityComponent : IComponentData
    {
        public float MaxIntegrity;
        public float CurrentIntegrity;
    }
     <summary>
    /// Tag per identificare barriere digitali, utilizzato per l'abilità Glitch Controllato di Neo
    /// </summary>

    public struct DigitalBarrierTag : IComponentData
    {
        public byte SecurityLevel;
    }
     <summary>
    /// Tag per identificare le zone sottomarine, utilizzato per l'abilità Bolla d'Aria di Marina
    /// </summary>

    public struct UnderwaterTag : IComponentData
    {
        public float DepthPressure;
    }
     <summary>
    /// Tag per identificare superfici scivolose o ghiacciate, utilizzato per l'abilità Aura di Calore di Kai
    /// </summary>

    public struct SlipperyTag : IComponentData
    {
        public float SlipFactor;
    }
     <summary>
    /// Tag per identificare terreni tossici, utilizzato per varie abilità di resistenza
    /// </summary>

    public struct ToxicGroundTag : IComponentData
    {
        public byte ToxicType;
        public float DamagePerSecond;
    }
     <summary>
    /// Tag per identificare correnti d'aria o d'acqua, utilizzato per varie abilità
    /// </summary>

    public struct CurrentTag : IComponentData
    {
        public float3 Direction;
        public float Strength;
        public byte CurrentType;
    }
     <summary>
    /// Componente per l'effetto visivo di scioglimento del ghiaccio
    /// </summary>

    public struct IceMeltEffectComponent : IComponentData
    {
        public float3 Position;
        public float Size;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/ObstacleTypeComponent.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Componente di base che definisce il tipo di ostacolo
    /// </summary>

    public struct ObstacleTypeComponent : IComponentData
    {
        public ushort ObstacleID;
        public ObstacleCategory Category;
        public bool IsUniversal;
        public bool IsUrbanObstacle;
        public bool IsForestObstacle;
        public bool IsTundraObstacle;
        public bool IsVolcanoObstacle;
        public bool IsAbyssObstacle;
        public bool IsVirtualObstacle;
        public float Height;
        public float Width;
        public float Depth;
        public bool RequiresJump;
        public bool RequiresSlide;
        public bool RequiresSideStep;
        public byte DifficultyLevel;
        public bool IsBreakable;
        public bool IsSlippery;
        public bool IsToxic;
        public bool IsLava;
        public bool IsIce;
        public bool IsDigital;
        public bool IsUnderwater;
        public string GetIDPrefix();
        public static ObstacleTypeComponent CreateUniversal(ushort id, ObstacleCategory category, float height, float width, float depth);
    }
     <summary>
    /// Enumerazione delle categorie di ostacoli
    /// </summary>

    public enum ObstacleCategory
    {
        None = 0,
        SmallBarrier = 1,
        MediumBarrier = 2,
        LargeBarrier = 3,
        Gap = 4,
        HangingObject = 5,
        MovingObstacle = 6,
        GroundHazard = 7,
        SpecialBarrier = 8,
        Vehicle = 9,
        NaturalObstacle = 10,
        ElectronicObstacle = 11,
        WaterObstacle = 12,
        FireObstacle = 13,
        IceObstacle = 14,
        DigitalObstacle = 15,
        AreaEffect = 16,
        SpecialEffect = 17
    }
     <summary>
    /// Componente tag per ostacoli universali
    /// </summary>

    public struct UniversalObstacleTag : IComponentData
    {
        public ushort ObstacleID;
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/VolcanoObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli vulcanici specifici del tema Volcano
    /// </summary>

     <summary>
    /// Tag di ostacolo vulcanico per raggruppamento
    /// </summary>

    public struct VolcanoObstacleTag : IComponentData
    {
    }
     <summary>
    /// V01: Pozza di lava - Causa danno continuo
    /// </summary>

    public struct V01_LavaPool : IComponentData
    {
        public float Temperature;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V02: Geyser di lava - Erutta periodicamente
    /// </summary>

    public struct V02_LavaGeyser : IComponentData
    {
        public float EruptionInterval;
        public float EruptionDuration;
        public float Height;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V03: Roccia vulcanica - Richiede salto o scivolata
    /// </summary>

    public struct V03_VolcanicRock : IComponentData
    {
        public bool IsHot;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V04: Parete di fiamme - Richiede salto speciale
    /// </summary>

    public struct V04_FireWall : IComponentData
    {
        public float Width;
        public float Height;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V05: Bomba vulcanica - Esplode dopo un po'
    /// </summary>

    public struct V05_VolcanicBomb : IComponentData
    {
        public float ExplosionDelay;
        public float ExplosionRadius;
        public float DamageAmount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V06: Cenere vulcanica - Riduce la visibilità
    /// </summary>

    public struct V06_VolcanicAsh : IComponentData
    {
        public float Density;
        public float Length;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V07: Flusso piroclastico - Avanza rapidamente
    /// </summary>

    public struct V07_PyroclasticFlow : IComponentData
    {
        public float Speed;
        public float Width;
        public float DamagePerSecond;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// V08: Terreno instabile - Si sgretola dopo un po'
    /// </summary>

    public struct V08_UnstableGround : IComponentData
    {
        public float BreakTime;
        public float WarningTime;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/UrbanObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli urbani specifici del tema City
    /// </summary>

     <summary>
    /// Tag di ostacolo urbano per raggruppamento
    /// </summary>

    public struct UrbanObstacleTag : IComponentData
    {
    }
     <summary>
    /// C01: Auto danneggiata - Richiede salto o scivolata
    /// </summary>

    public struct C01_Car : IComponentData
    {
        public byte CarType;
        public bool IsCrashed;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C02: Furgone danneggiato - Richiede salto alto o aggiramento
    /// </summary>

    public struct C02_Van : IComponentData
    {
        public bool IsTipped;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C03: Drone di sorveglianza - Si muove in pattern prevedibili
    /// </summary>

    public struct C03_SurveillanceDrone : IComponentData
    {
        public float MovementSpeed;
        public float DetectionRadius;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C04: Barricata di polizia - Richiede salto o scivolata
    /// </summary>

    public struct C04_PoliceBarricade : IComponentData
    {
        public bool HasFlashingLights;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C05: Idrante rotto - Crea getto d'acqua che spinge lateralmente
    /// </summary>

    public struct C05_FireHydrant : IComponentData
    {
        public float WaterForce;
        public bool IsSpraying;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C06: Veicolo fuori controllo - Si muove attraverso il percorso
    /// </summary>

    public struct C06_RunawayCar : IComponentData
    {
        public float Speed;
        public byte VehicleType;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C07: Cantiere stradale - Combinazione di coni e barriere
    /// </summary>

    public struct C07_RoadConstruction : IComponentData
    {
        public byte ConstructionType;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// C08: Insegna al neon caduta - Può essere elettrificata
    /// </summary>

    public struct C08_FallenNeonSign : IComponentData
    {
        public bool IsElectrified;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/UniversalObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli universali che appaiono in tutti i temi
    /// </summary>

     <summary>
    /// U01: Barriera bassa - Richiede salto
    /// </summary>

    public struct U01_LowBarrier : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U02: Barriera alta - Richiede scivolata
    /// </summary>

    public struct U02_HighBarrier : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U03: Gap/Buco - Richiede salto lungo
    /// </summary>

    public struct U03_Gap : IComponentData
    {
        public float Width;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U04: Ostacolo laterale - Richiede passo laterale
    /// </summary>

    public struct U04_SideObstacle : IComponentData
    {
        public bool IsLeftSide;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U05: Oggetto sospeso - Richiede scivolata
    /// </summary>

    public struct U05_HangingObject : IComponentData
    {
        public float Height;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U06: Barriera doppia - Richiede salto e scivolata in sequenza
    /// </summary>

    public struct U06_DoubleBarrier : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U07: Spuntoni a terra - Richiede salto
    /// </summary>

    public struct U07_FloorSpikes : IComponentData
    {
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// U08: Contenitore di energia - Può essere distrutto
    /// </summary>

    public struct U08_PowerContainer : IComponentData
    {
        public float Energy;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/AbyssObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli abissali specifici del tema Abyss
    /// </summary>

     <summary>
    /// Tag di ostacolo abissale per raggruppamento
    /// </summary>

    public struct AbyssObstacleTag : IComponentData
    {
    }
     <summary>
    /// A01: Sezione subacquea - Richiede nuoto e gestione dell'ossigeno
    /// </summary>

    public struct A01_UnderwaterSection : IComponentData
    {
        public float Length;
        public float Depth;
        public float CurrentStrength;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A02: Corrente abissale - Spinge in una direzione
    /// </summary>

    public struct A02_AbyssalCurrent : IComponentData
    {
        public float Strength;
        public float Direction;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A03: Tentacoli oscillanti - Richiede movimento preciso
    /// </summary>

    public struct A03_SwingingTentacles : IComponentData
    {
        public float SwingFrequency;
        public float SwingAmplitude;
        public int TentacleCount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A04: Alga avviluppante - Rallenta il movimento
    /// </summary>

    public struct A04_TanglingSeaweed : IComponentData
    {
        public float SlowFactor;
        public float BreakForce;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A05: Medusa abissale - Emette scariche elettriche
    /// </summary>

    public struct A05_AbyssalJellyfish : IComponentData
    {
        public float StingRadius;
        public float DamageAmount;
        public float MoveSpeed;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A06: Bolla di gas tossico - Riduce l'ossigeno
    /// </summary>

    public struct A06_ToxicGasBubble : IComponentData
    {
        public float Size;
        public float ToxicityLevel;
        public float ExpansionRate;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A07: Voragine abissale - Richiede salto lungo
    /// </summary>

    public struct A07_AbyssalChasm : IComponentData
    {
        public float Width;
        public float Depth;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// A08: Spruzzo di inchiostro - Riduce la visibilità
    /// </summary>

    public struct A08_InkSpray : IComponentData
    {
        public float BlindnessDuration;
        public float BlindnessIntensity;
        public float Radius;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/ForestObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli forestali specifici del tema Forest
    /// </summary>

     <summary>
    /// Tag di ostacolo forestale per raggruppamento
    /// </summary>

    public struct ForestObstacleTag : IComponentData
    {
    }
     <summary>
    /// F01: Tronco caduto - Richiede salto
    /// </summary>

    public struct F01_FallenLog : IComponentData
    {
        public float Length;
        public byte RottenLevel;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F02: Albero caduto - Richiede salto grande
    /// </summary>

    public struct F02_FallenTree : IComponentData
    {
        public bool HasBranches;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F03: Radici sporgenti - Richiede salto
    /// </summary>

    public struct F03_ProtrudingRoots : IComponentData
    {
        public float Height;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F04: Pianta velenosa - Causa danno continuo se toccata
    /// </summary>

    public struct F04_PoisonousPlant : IComponentData
    {
        public float ToxicityLevel;
        public float EffectRadius;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F05: Liane pendenti - Richiede scivolata
    /// </summary>

    public struct F05_HangingVines : IComponentData
    {
        public float Length;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F06: Nido di vespe - Attiva sciame se avvicinato
    /// </summary>

    public struct F06_WaspNest : IComponentData
    {
        public float ActivationDistance;
        public int WaspCount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F07: Fossa di fango - Rallenta il movimento
    /// </summary>

    public struct F07_MudPit : IComponentData
    {
        public float SlowFactor;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// F08: Tronco oscillante - Si muove da lato a lato
    /// </summary>

    public struct F08_SwingingLog : IComponentData
    {
        public float SwingSpeed;
        public float SwingRange;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/ObstacleCatalog.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Catalogo statico di tutti gli ostacoli per tema
    /// </summary>

    public static class ObstacleCatalog
    {
        private static Dictionary<string, ObstacleTypeComponent> _obstaclesByCode;
         <summary>
        /// Inizializza il catalogo se non è già stato fatto
        /// </summary>

        private static void InitializeIfNeeded();
         <summary>
        /// Ottiene un ostacolo in base al codice (es. "U01", "C03", ecc.)
        /// </summary>

        public static ObstacleTypeComponent GetObstacleByCode(string code);
         <summary>
        /// Ottiene ostacoli casuali per un tema specifico, filtrati per livello di difficoltà
        /// </summary>

        public static List<ObstacleTypeComponent> GetRandomObstaclesForTheme(WorldTheme theme, int count, int minDifficulty, int maxDifficulty, Unity.Mathematics.Random random);
        private static void RegisterUniversalObstacles();
        private static void RegisterUrbanObstacles();
        private static void RegisterForestObstacles();
        private static void RegisterTundraObstacles();
        private static void RegisterVolcanoObstacles();
        private static void RegisterAbyssObstacles();
        private static void RegisterVirtualObstacles();
        private static void RegisterObstacle(string code, ObstacleTypeComponent obstacle);
    }
     <summary>
    /// Factory per la creazione di ostacoli in base al tipo
    /// </summary>

    public static class ObstacleFactory
    {
         <summary>
        /// Crea un'entità ostacolo basata sul codice
        /// </summary>

        public static Entity CreateObstacle(EntityCommandBuffer commandBuffer, string obstacleCode, float3 position, quaternion rotation, float scale);
         <summary>
        /// Aggiunge i componenti specifici in base al codice dell'ostacolo
        /// </summary>

        private static void AddObstacleSpecificComponents(EntityCommandBuffer commandBuffer, Entity entity, string obstacleCode);
         <summary>
        /// Aggiunge i tag specifici per tema dell'ostacolo
        /// </summary>

        private static void AddThemeSpecificTags(EntityCommandBuffer commandBuffer, Entity entity, ObstacleTypeComponent obstacleType);
        private static void AddCityObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddForestObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddTundraObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddVolcanoObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddAbyssObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
        private static void AddVirtualObstacleComponents(EntityCommandBuffer commandBuffer, Entity entity, string id);
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Components/World/Obstacles/VirtualObstacles.cs

namespace RunawayHeroes.ECS.Components.World.Obstacles
{
     <summary>
    /// Definizioni dei componenti per ostacoli virtuali specifici del tema Virtual
    /// </summary>

     <summary>
    /// Tag di ostacolo virtuale per raggruppamento
    /// </summary>

    public struct VirtualObstacleTag : IComponentData
    {
    }
     <summary>
    /// D01: Barriera di dati - Richiede salto o glitch
    /// </summary>

    public struct D01_DataBarrier : IComponentData
    {
        public float Height;
        public float Integrity;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D02: Firewall - Causa danno continuo
    /// </summary>

    public struct D02_Firewall : IComponentData
    {
        public float DamagePerSecond;
        public float Width;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D03: Blocco di corruzione - Cambia forma periodicamente
    /// </summary>

    public struct D03_CorruptionBlock : IComponentData
    {
        public float MorphInterval;
        public byte MorphState;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D04: Glitch spaziale - Teletrasporta il giocatore
    /// </summary>

    public struct D04_SpatialGlitch : IComponentData
    {
        public float TeleportDistance;
        public byte TeleportDirection;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D05: Picco di dati - Richiede salto
    /// </summary>

    public struct D05_DataSpike : IComponentData
    {
        public float Height;
        public float Damage;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D06: Virus attivo - Si muove verso il giocatore
    /// </summary>

    public struct D06_ActiveVirus : IComponentData
    {
        public float MoveSpeed;
        public float DetectionRadius;
        public float DamageAmount;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D07: Campo di deformazione - Inverte i controlli
    /// </summary>

    public struct D07_DistortionField : IComponentData
    {
        public float Duration;
        public float Radius;
        public static ObstacleTypeComponent GetTypeData();
    }
     <summary>
    /// D08: Matrice di codice - Si ricompone in diversi pattern
    /// </summary>

    public struct D08_CodeMatrix : IComponentData
    {
        public byte PatternIndex;
        public float ShiftInterval;
        public static ObstacleTypeComponent GetTypeData();
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Movement/Group/MovementSystemGroup.cs

namespace RunawayHeroes.ECS.Systems.Movement.Group
{
     <summary>
    /// Gruppo di sistemi che gestisce tutti gli aspetti del movimento.
    /// </summary>

    public partial class MovementSystemGroup : ComponentSystemGroup
    {
    }
}


## File: /Users/gianlucaricaldone/Progetti/RunawayHeroes/Assets/_Project/ECS/Systems/Gameplay/Group/GameplaySystemGroup.cs

namespace RunawayHeroes.ECS.Systems.Gameplay.Group
{
     <summary>
    /// Gruppo di sistemi che gestisce tutti gli aspetti del gameplay.
    /// Include progressione, tutorial, meccaniche di gioco principali.
    /// </summary>

    public partial class GameplaySystemGroup : ComponentSystemGroup
    {
    }
}


